Args: llc tt.ll -o tt-2.s -debug -fast-isel=false 
	discovered a new reachable node %entry

Features:+64bit,+sse2,+fxsr,+mmx,+sse,+sse2,+x87
CPU:x86-64

Subtarget features: SSELevel 2, 3DNowLevel 1, 64bit 1
G_ADD (opcode 34): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SUB (opcode 35): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_MUL (opcode 36): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SDIV (opcode 37): 1 type index
.. opcode 37 is aliased to 84
.. opcode 84 is aliased to 0
.. the first uncovered type index: 1, OK
G_UDIV (opcode 38): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SREM (opcode 39): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_UREM (opcode 40): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_AND (opcode 41): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_OR (opcode 42): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_XOR (opcode 43): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_IMPLICIT_DEF (opcode 44): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_PHI (opcode 45): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FRAME_INDEX (opcode 46): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_GLOBAL_VALUE (opcode 47): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_EXTRACT (opcode 48): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UNMERGE_VALUES (opcode 49): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_INSERT (opcode 50): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_MERGE_VALUES (opcode 51): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_PTRTOINT (opcode 52): 2 type indices
.. the first uncovered type index: 2, OK
G_INTTOPTR (opcode 53): 2 type indices
.. the first uncovered type index: 2, OK
G_BITCAST (opcode 54): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_LOAD (opcode 55): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SEXTLOAD (opcode 56): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ZEXTLOAD (opcode 57): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_STORE (opcode 58): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG_WITH_SUCCESS (opcode 59): 3 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG (opcode 60): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XCHG (opcode 61): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_ADD (opcode 62): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_SUB (opcode 63): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_AND (opcode 64): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_NAND (opcode 65): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_OR (opcode 66): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XOR (opcode 67): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MAX (opcode 68): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MIN (opcode 69): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMAX (opcode 70): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMIN (opcode 71): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_BRCOND (opcode 72): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_BRINDIRECT (opcode 73): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_INTRINSIC (opcode 74): 0 type indices
.. type index coverage check SKIPPED: no rules defined
G_INTRINSIC_W_SIDE_EFFECTS (opcode 75): 0 type indices
.. type index coverage check SKIPPED: no rules defined
G_ANYEXT (opcode 76): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_TRUNC (opcode 77): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_CONSTANT (opcode 78): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FCONSTANT (opcode 79): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_VASTART (opcode 80): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_VAARG (opcode 81): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SEXT (opcode 82): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ZEXT (opcode 83): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SHL (opcode 84): 1 type index
.. the first uncovered type index: 1, OK
G_LSHR (opcode 85): 1 type index
.. opcode 85 is aliased to 84
.. opcode 84 is aliased to 0
.. the first uncovered type index: 1, OK
G_ASHR (opcode 86): 1 type index
.. opcode 86 is aliased to 84
.. opcode 84 is aliased to 0
.. the first uncovered type index: 1, OK
G_ICMP (opcode 87): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FCMP (opcode 88): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SELECT (opcode 89): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UADDE (opcode 90): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_USUBE (opcode 91): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SADDO (opcode 92): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SSUBO (opcode 93): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UMULO (opcode 94): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SMULO (opcode 95): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UMULH (opcode 96): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SMULH (opcode 97): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FADD (opcode 98): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FSUB (opcode 99): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FMUL (opcode 100): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FMA (opcode 101): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FDIV (opcode 102): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FREM (opcode 103): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FPOW (opcode 104): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FEXP (opcode 105): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FEXP2 (opcode 106): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FLOG (opcode 107): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FLOG2 (opcode 108): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FNEG (opcode 109): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FPEXT (opcode 110): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FPTRUNC (opcode 111): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FPTOSI (opcode 112): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FPTOUI (opcode 113): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SITOFP (opcode 114): 2 type indices
.. the first uncovered type index: 2, OK
G_UITOFP (opcode 115): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FABS (opcode 116): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_GEP (opcode 117): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_PTR_MASK (opcode 118): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_BR (opcode 119): 0 type indices
.. type index coverage check SKIPPED: no rules defined
G_INSERT_VECTOR_ELT (opcode 120): 3 type indices
.. type index coverage check SKIPPED: no rules defined
G_EXTRACT_VECTOR_ELT (opcode 121): 3 type indices
.. type index coverage check SKIPPED: no rules defined
G_SHUFFLE_VECTOR (opcode 122): 3 type indices
.. type index coverage check SKIPPED: no rules defined
G_BSWAP (opcode 123): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_ADDRSPACE_CAST (opcode 124): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_BLOCK_ADDR (opcode 125): 1 type index
.. type index coverage check SKIPPED: no rules defined
	discovered a new reachable node %entry
	discovered a new reachable node %entry
Skipping pass 'Merge contiguous icmps into a memcmp' on function fun
Skipping pass 'Expand memcmp() to load/stores' on function fun
	discovered a new reachable node %entry
---- Branch Probability Info : fun ----

Computing probabilities for entry

block-frequency: fun
====================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: fun
 - entry: float = 1.0, int = 8

Skipping pass 'Constant Hoisting' on function fun
Skipping pass 'Partially inline calls to library functions' on function fun
	discovered a new reachable node %entry
*** Interleaved Access Pass: fun
	discovered a new reachable node %entry
Skipping pass 'CodeGen Prepare' on function fun
	discovered a new reachable node %entry
[SafeStack] Function: fun
[SafeStack]     safestack is not requested for this function
	discovered a new reachable node %entry
	discovered a new reachable node %entry
---- Branch Probability Info : fun ----

Computing probabilities for entry
Skipping pass 'X86 DAG->DAG Instruction Selection' on function fun

Changing optimization level for Function fun
	Before: -O2 ; After: -O0
	FastISel is disabled



=== fun
Found argument copy elision candidate:   %a.addr = alloca i32, align 4
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Creating constant: t4: i64 = Constant<0>
Creating new node: t5: i64 = undef
Creating new node: t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Creating new node: t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
Creating constant: t8: i32 = Constant<1>
Creating new node: t9: i32 = add nsw t7, Constant:i32<1>
Creating new node: t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64
Creating new node: t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64
Creating constant: t13: i32 = TargetConstant<0>
Creating new node: t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12
Creating new node: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1
Initial selection DAG: %bb.0 'fun:entry'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
  t4: i64 = Constant<0>
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
  t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
    t9: i32 = add nsw t7, Constant:i32<1>
  t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64
    t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64
  t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12
  t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1



Combining: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1

Combining: t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12

Combining: t14: i32 = Register $eax

Combining: t13: i32 = TargetConstant<0>

Combining: t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64

Combining: t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64

Combining: t10: i64 = FrameIndex<1>

Combining: t9: i32 = add nsw t7, Constant:i32<1>

Combining: t8: i32 = Constant<1>

Combining: t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64

Combining: t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64

Combining: t5: i64 = undef

Combining: t3: i64 = FrameIndex<0>

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t1: i32 = Register %0

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'fun:entry'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
  t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
    t9: i32 = add nsw t7, Constant:i32<1>
  t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64
    t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64
  t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12
  t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1


Legalizing node: t14: i32 = Register $eax
Ignoring node results
Legally typed node: t14: i32 = Register $eax

Legalizing node: t13: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t13: i32 = TargetConstant<0>

Legalizing node: t10: i64 = FrameIndex<1>
Analyzing result type: i64
Legal result type
Legally typed node: t10: i64 = FrameIndex<1>

Legalizing node: t8: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t8: i32 = Constant<1>

Legalizing node: t5: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t5: i64 = undef

Legalizing node: t3: i64 = FrameIndex<0>
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = FrameIndex<0>

Legalizing node: t1: i32 = Register %0
Ignoring node results
Legally typed node: t1: i32 = Register %0

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing node: t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal operand
Analyzing operand: t3: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t5: i64 = undef
Legal operand
Legally typed node: t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64

Legalizing node: t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t3: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t5: i64 = undef
Legal operand
Legally typed node: t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64

Legalizing node: t9: i32 = add nsw t7, Constant:i32<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t8: i32 = Constant<1>
Legal operand
Legally typed node: t9: i32 = add nsw t7, Constant:i32<1>

Legalizing node: t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t9: i32 = add nsw t7, Constant:i32<1>
Legal operand
Analyzing operand: t10: i64 = FrameIndex<1>
Legal operand
Analyzing operand: t5: i64 = undef
Legal operand
Legally typed node: t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64

Legalizing node: t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t10: i64 = FrameIndex<1>
Legal operand
Analyzing operand: t5: i64 = undef
Legal operand
Legally typed node: t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64

Legalizing node: t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64
Legal operand
Legally typed node: t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12

Legalizing node: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12
Legal operand
Analyzing operand: t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12
Legal operand
Legally typed node: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1

Legalizing node: t65535: ch = handlenode t16
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1
Legal operand
Legally typed node: t65535: ch = handlenode t16

Type-legalized selection DAG: %bb.0 'fun:entry'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
  t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
    t9: i32 = add nsw t7, Constant:i32<1>
  t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64
    t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64
  t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12
  t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1



Legalizing: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1
Legal node: nothing to do

Legalizing: t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12
Legal node: nothing to do

Legalizing: t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64
Legalizing non-extending load operation

Legalizing: t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t9: i32 = add nsw t7, Constant:i32<1>
Legal node: nothing to do

Legalizing: t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
Legalizing non-extending load operation

Legalizing: t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Legalizing: t14: i32 = Register $eax

Legalizing: t13: i32 = TargetConstant<0>

Legalizing: t10: i64 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t8: i32 = Constant<1>
Legal node: nothing to do

Legalizing: t5: i64 = undef
Legal node: nothing to do

Legalizing: t3: i64 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t1: i32 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.0 'fun:entry'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
  t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
    t9: i32 = add nsw t7, Constant:i32<1>
  t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64
    t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64
  t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12
  t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1



Legalizing: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1
Legal node: nothing to do

Combining: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1

Legalizing: t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12
Legal node: nothing to do

Combining: t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12

Legalizing: t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64
Legalizing non-extending load operation

Combining: t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64

Legalizing: t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64

Legalizing: t9: i32 = add nsw t7, Constant:i32<1>
Legal node: nothing to do

Combining: t9: i32 = add nsw t7, Constant:i32<1>

Legalizing: t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
Legalizing non-extending load operation

Combining: t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64

Legalizing: t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing: t14: i32 = Register $eax

Combining: t14: i32 = Register $eax

Legalizing: t13: i32 = TargetConstant<0>

Combining: t13: i32 = TargetConstant<0>

Legalizing: t10: i64 = FrameIndex<1>
Legal node: nothing to do

Combining: t10: i64 = FrameIndex<1>

Legalizing: t8: i32 = Constant<1>
Legal node: nothing to do

Combining: t8: i32 = Constant<1>

Legalizing: t5: i64 = undef
Legal node: nothing to do

Combining: t5: i64 = undef

Legalizing: t3: i64 = FrameIndex<0>
Legal node: nothing to do

Combining: t3: i64 = FrameIndex<0>

Legalizing: t1: i32 = Register %0

Combining: t1: i32 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'fun:entry'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
  t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
    t9: i32 = add nsw t7, Constant:i32<1>
  t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64
    t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64
  t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12
  t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t16: ch = X86ISD::RET_FLAG t15, TargetConstant:i32<0>, Register:i32 $eax, t15:1
ISEL: Starting pattern match
  Morphed node: t16: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t15, t15:1
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12

ISEL: Starting selection on root node: t12: i32,ch = load<(dereferenceable load 4 from %ir.b)> t11, FrameIndex:i64<1>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fff34cc2e30
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t19: i8 = TargetConstant<1>
  Morphed node: t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.b)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t11
ISEL: Match complete!

ISEL: Starting selection on root node: t11: ch = store<(store 4 into %ir.b)> t7:1, t9, FrameIndex:i64<1>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  OpcodeSwitch from 1029 to 5817
  Match failed at index 5826
  Continuing at 6606
  Match failed at index 6616
  Continuing at 6659
  Match failed at index 6664
  Continuing at 6707
  Match failed at index 6712
  Continuing at 6755
  Continuing at 6756
  Match failed at index 6764
  Continuing at 6886
  Match failed at index 6890
  Continuing at 7016
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fff34cc2e30
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t11: ch = MOV32mr<Mem:(store 4 into %ir.b)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t9, t7:1
ISEL: Match complete!

ISEL: Starting selection on root node: t9: i32 = add nsw t7, Constant:i32<1>
ISEL: Starting pattern match
  Initial Opcode index to 17918
  Skipped scope entry (due to false predicate) at index 17924, continuing at 17944
  Match failed at index 17946
  Continuing at 18049
  Continuing at 18050
  OpcodeSwitch from 18053 to 18057
  Match failed at index 18059
  Continuing at 18230
  Match failed at index 18233
  Continuing at 18300
  TypeSwitch[i32] from 18302 to 18305
  Skipped scope entry (due to false predicate) at index 18307, continuing at 18323
MatchAddress: X86ISelAddressMode 0x7fff34cc2cf0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff34cc2cf0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fff34cc2cf0
Base_Reg t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Match failed at index 18326
  Continuing at 18340
  Continuing at 18358
  Match failed at index 18361
  Continuing at 18382
  Match failed at index 18384
  Continuing at 18406
  TypeSwitch[i32] from 18413 to 18440
  Match failed at index 18440
  Continuing at 18463
  Match failed at index 18464
  Continuing at 18525
  Match failed at index 18526
  Continuing at 18600
  Match failed at index 18601
  Continuing at 18630
  Match failed at index 18644
  Continuing at 18657
Creating constant: t21: i32 = TargetConstant<1>
  Morphed node: t9: i32,i32 = ADD32ri8 nsw t7, TargetConstant:i32<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t7: i32,ch = load<(dereferenceable load 4 from %ir.a.addr)> t6, FrameIndex:i64<0>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fff34cc2e30
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t7: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = store<(store 4 into %ir.a.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  Match failed at index 1029
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fff34cc2e30
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t6: ch = MOV32mr<Mem:(store 4 into %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t2, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %0

ISEL: Starting selection on root node: t14: i32 = Register $eax

ISEL: Starting selection on root node: t13: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t1: i32 = Register %0

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'fun:entry'
SelectionDAG has 18 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t6: ch = MOV32mr<Mem:(store 4 into %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t2, t0
  t7: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6
    t9: i32,i32 = ADD32ri8 nsw t7, TargetConstant:i32<1>
  t11: ch = MOV32mr<Mem:(store 4 into %ir.b)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t9, t7:1
    t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.b)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t11
  t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12
  t16: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t15, t15:1


********** List Scheduling %bb.0 'entry' **********
SU(0): t16: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t15, t15:1

    t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
    SU(2): Ord  Latency=1 Barrier
    SU(1): Data Latency=1
SU(1): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.b)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t11

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Data Latency=1
SU(2): t11: ch = MOV32mr<Mem:(store 4 into %ir.b)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t9, t7:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
    SU(1): Ord  Latency=1 Barrier
SU(3): t7: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(6): Data Latency=1
SU(4): t6: ch = MOV32mr<Mem:(store 4 into %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t2, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(3): Ord  Latency=1 Barrier
SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(4): Data Latency=1
SU(6): t9: i32,i32 = ADD32ri8 nsw t7, TargetConstant:i32<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t16: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t15, t15:1

    t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12


*** Scheduling [0]: SU(0): t16: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t15, t15:1

    t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12


Examining Available:
Height 1: SU(1): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.b)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t11


*** Scheduling [1]: SU(1): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.b)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t11


Examining Available:
Height 2: SU(2): t11: ch = MOV32mr<Mem:(store 4 into %ir.b)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t9, t7:1


*** Scheduling [2]: SU(2): t11: ch = MOV32mr<Mem:(store 4 into %ir.b)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t9, t7:1


Examining Available:
Height 3: SU(6): t9: i32,i32 = ADD32ri8 nsw t7, TargetConstant:i32<1>


*** Scheduling [3]: SU(6): t9: i32,i32 = ADD32ri8 nsw t7, TargetConstant:i32<1>


Examining Available:
Height 4: SU(3): t7: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6


*** Scheduling [4]: SU(3): t7: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6


Examining Available:
Height 5: SU(4): t6: ch = MOV32mr<Mem:(store 4 into %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t2, t0


*** Scheduling [5]: SU(4): t6: ch = MOV32mr<Mem:(store 4 into %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t2, t0


Examining Available:
Height 6: SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %0


*** Scheduling [6]: SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %0

*** Final schedule ***
SU(5): t2: i32,ch = CopyFromReg t0, Register:i32 %0

SU(4): t6: ch = MOV32mr<Mem:(store 4 into %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t2, t0

SU(3): t7: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.a.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6

SU(6): t9: i32,i32 = ADD32ri8 nsw t7, TargetConstant:i32<1>

SU(2): t11: ch = MOV32mr<Mem:(store 4 into %ir.b)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t9, t7:1

SU(1): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.b)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t11

SU(0): t16: ch = RET TargetConstant:i32<0>, Register:i32 $eax, t15, t15:1

    t15: ch,glue = CopyToReg t11, Register:i32 $eax, t12


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function fun: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $edi in %0

bb.0.entry:
  liveins: $edi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.a.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.a.addr)
  %1:gr32 = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.a.addr)
  %2:gr32 = ADD32ri8 %1:gr32, 1, implicit-def dead $eflags
  MOV32mr %stack.1.b, 1, $noreg, 0, $noreg, killed %2:gr32 :: (store 4 into %ir.b)
  %3:gr32 = MOV32rm %stack.1.b, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.b)
  $eax = COPY %3:gr32
  RET 0, $eax

# End machine code for function fun.


Restoring optimization level for Function fun
	Before: -O0 ; After: -O2
	discovered a new reachable node %bb.0
Skipping pass 'Local Dynamic TLS Access Clean-up' on function fun
Skipping pass 'X86 Domain Reassignment Pass' on function fun
Skipping pass 'Early Tail Duplication' on function fun
Skipping pass 'Optimize machine instruction PHIs' on function fun
# Machine code for function fun: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $edi in %0

0B	bb.0.entry:
	  liveins: $edi
16B	  %0:gr32 = COPY $edi
32B	  MOV32mr %stack.0.a.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.a.addr)
48B	  %1:gr32 = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.a.addr)
64B	  %2:gr32 = ADD32ri8 %1:gr32, 1, implicit-def dead $eflags
80B	  MOV32mr %stack.1.b, 1, $noreg, 0, $noreg, killed %2:gr32 :: (store 4 into %ir.b)
96B	  %3:gr32 = MOV32rm %stack.1.b, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.b)
112B	  $eax = COPY %3:gr32
128B	  RET 0, $eax

# End machine code for function fun.

********** Stack Coloring **********
********** Function: fun
Found 0 markers and 2 slots
Slot structure:
Slot #0 - 4 bytes.
Slot #1 - 4 bytes.
Total Stack size: 8 bytes

Will not try to merge slots.
Removed 0 markers.
Skipping pass 'Remove dead machine instructions' on function fun
	discovered a new reachable node %bb.0
********** EARLY IF-CONVERSION **********
********** Function: fun
Skipping pass 'Early If-Conversion' on function fun
Machine InstCombiner: fun
Combining MBB entry
Skipping pass 'X86 cmov Conversion' on function fun
	discovered a new reachable node %bb.0
Skipping pass 'Early Machine Loop Invariant Code Motion' on function fun
Skipping pass 'Machine Common Subexpression Elimination' on function fun
		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.0

block-frequency: fun
====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: fun
 - BB0[entry]: float = 1.0, int = 8

Skipping pass 'Machine code sinking' on function fun
Skipping pass 'Peephole Optimizations' on function fun
Skipping pass 'Remove dead machine instructions' on function fun
Skipping pass 'Live Range Shrink' on function fun
Skipping pass 'X86 LEA Optimize' on function fun
Skipping pass 'X86 Optimize Call Frame' on function fun
Skipping pass 'X86 Avoid Store Forwarding Blocks' on function fun
	discovered a new reachable node %bb.0
********** X86 EFLAGS copy lowering : fun **********
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: fun
	discovered a new reachable node %bb.0
Skipping pass 'Two-Address instruction pass' on function fun
********** REWRITING TWO-ADDR INSTRS **********
********** Function: fun
	%2:gr32 = ADD32ri8 killed %1:gr32, 1, implicit-def dead $eflags
		prepend:	%2:gr32 = COPY %1:gr32
		rewrite to:	%2:gr32 = ADD32ri8 %2:gr32, 1, implicit-def dead $eflags
# Machine code for function fun: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $edi in %0

0B	bb.0.entry:
	  liveins: $edi
16B	  %0:gr32 = COPY killed $edi
32B	  MOV32mr %stack.0.a.addr, 1, $noreg, 0, $noreg, killed %0:gr32 :: (store 4 into %ir.a.addr)
48B	  %1:gr32 = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.a.addr)
64B	  %2:gr32 = COPY killed %1:gr32
80B	  %2:gr32 = ADD32ri8 %2:gr32, 1, implicit-def dead $eflags
96B	  MOV32mr %stack.1.b, 1, $noreg, 0, $noreg, killed %2:gr32 :: (store 4 into %ir.b)
112B	  %3:gr32 = MOV32rm %stack.1.b, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.b)
128B	  $eax = COPY killed %3:gr32
144B	  RET 0, killed $eax

# End machine code for function fun.

Computing live-in reg-units in ABI blocks.
0B	%bb.0 DIL#0 DIH#0 HDI#0
Created 3 new intervals.
********** INTERVALS **********
DIL [0B,16r:0)  0@0B-phi
DIH [0B,16r:0)  0@0B-phi
HDI [0B,16r:0)  0@0B-phi
%0 [16r,32r:0)  0@16r weight:0.000000e+00
%1 [48r,64r:0)  0@48r weight:0.000000e+00
%2 [64r,80r:0)[80r,96r:1)  0@64r 1@80r weight:0.000000e+00
%3 [112r,128r:0)  0@112r weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function fun: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $edi in %0

0B	bb.0.entry:
	  liveins: $edi
16B	  %0:gr32 = COPY $edi
32B	  MOV32mr %stack.0.a.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.a.addr)
48B	  %1:gr32 = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.a.addr)
64B	  %2:gr32 = COPY %1:gr32
80B	  %2:gr32 = ADD32ri8 %2:gr32, 1, implicit-def dead $eflags
96B	  MOV32mr %stack.1.b, 1, $noreg, 0, $noreg, %2:gr32 :: (store 4 into %ir.b)
112B	  %3:gr32 = MOV32rm %stack.1.b, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.b)
128B	  $eax = COPY %3:gr32
144B	  RET 0, killed $eax

# End machine code for function fun.

********** SIMPLE REGISTER COALESCING **********
********** Function: fun
********** JOINING INTERVALS ***********
entry:
16B	%0:gr32 = COPY $edi
	Considering merging %0 with $edi
	Can only merge into reserved registers.
128B	$eax = COPY %3:gr32
	Considering merging %3 with $eax
	Can only merge into reserved registers.
64B	%2:gr32 = COPY %1:gr32
	Considering merging to GR32 with %1 in %2
		RHS = %1 [48r,64r:0)  0@48r weight:0.000000e+00
		LHS = %2 [64r,80r:0)[80r,96r:1)  0@64r 1@80r weight:0.000000e+00
		merge %2:0@64r into %1:0@48r --> @48r
		erased:	64r	%2:gr32 = COPY %1:gr32
AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $r14d $r15d $r12d $r13d ]
		updated: 48B	%2:gr32 = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.a.addr)
	Success: %1 -> %2
	Result = %2 [48r,80r:0)[80r,96r:1)  0@48r 1@80r weight:0.000000e+00
Trying to inflate 0 regs.
********** INTERVALS **********
DIL [0B,16r:0)  0@0B-phi
DIH [0B,16r:0)  0@0B-phi
HDI [0B,16r:0)  0@0B-phi
%0 [16r,32r:0)  0@16r weight:0.000000e+00
%2 [48r,80r:0)[80r,96r:1)  0@48r 1@80r weight:0.000000e+00
%3 [112r,128r:0)  0@112r weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function fun: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $edi in %0

0B	bb.0.entry:
	  liveins: $edi
16B	  %0:gr32 = COPY $edi
32B	  MOV32mr %stack.0.a.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.a.addr)
48B	  %2:gr32 = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.a.addr)
80B	  %2:gr32 = ADD32ri8 %2:gr32, 1, implicit-def dead $eflags
96B	  MOV32mr %stack.1.b, 1, $noreg, 0, $noreg, %2:gr32 :: (store 4 into %ir.b)
112B	  %3:gr32 = MOV32rm %stack.1.b, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.b)
128B	  $eax = COPY %3:gr32
144B	  RET 0, killed $eax

# End machine code for function fun.

Skipping pass 'Machine Instruction Scheduler' on function fun

block-frequency: fun
====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: fun
 - BB0[entry]: float = 1.0, int = 8

********** GREEDY REGISTER ALLOCATION **********
********** Function: fun
********** Compute Spill Weights **********
********** Function: fun
********** INTERVALS **********
DIL [0B,16r:0)  0@0B-phi
DIH [0B,16r:0)  0@0B-phi
HDI [0B,16r:0)  0@0B-phi
%0 [16r,32r:0)  0@16r weight:INF
%2 [48r,80r:0)[80r,96r:1)  0@48r 1@80r weight:INF
%3 [112r,128r:0)  0@112r weight:INF
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function fun: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $edi in %0

0B	bb.0.entry:
	  liveins: $edi
16B	  %0:gr32 = COPY $edi
32B	  MOV32mr %stack.0.a.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.a.addr)
48B	  %2:gr32 = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.a.addr)
80B	  %2:gr32 = ADD32ri8 %2:gr32, 1, implicit-def dead $eflags
96B	  MOV32mr %stack.1.b, 1, $noreg, 0, $noreg, %2:gr32 :: (store 4 into %ir.b)
112B	  %3:gr32 = MOV32rm %stack.1.b, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.b)
128B	  $eax = COPY %3:gr32
144B	  RET 0, killed $eax

# End machine code for function fun.


selectOrSplit GR32:%0 [16r,32r:0)  0@16r weight:INF w=INF
AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $r14d $r15d $r12d $r13d ]
hints: $edi
assigning %0 to $edi: DIL [16r,32r:0)  0@16r DIH [16r,32r:0)  0@16r HDI [16r,32r:0)  0@16r

selectOrSplit GR32:%3 [112r,128r:0)  0@112r weight:INF w=INF
hints: $eax
assigning %3 to $eax: AH [112r,128r:0)  0@112r AL [112r,128r:0)  0@112r HAX [112r,128r:0)  0@112r

selectOrSplit GR32:%2 [48r,80r:0)[80r,96r:1)  0@48r 1@80r weight:INF w=INF
assigning %2 to $eax: AH [48r,80r:0)[80r,96r:1)  0@48r 1@80r AL [48r,80r:0)[80r,96r:1)  0@48r 1@80r HAX [48r,80r:0)[80r,96r:1)  0@48r 1@80r
********** REWRITE VIRTUAL REGISTERS **********
********** Function: fun
********** REGISTER MAP **********
[%0 -> $edi] GR32
[%2 -> $eax] GR32
[%3 -> $eax] GR32

0B	bb.0.entry:
	  liveins: $edi
16B	  %0:gr32 = COPY $edi
32B	  MOV32mr %stack.0.a.addr, 1, $noreg, 0, $noreg, killed %0:gr32 :: (store 4 into %ir.a.addr)
48B	  %2:gr32 = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.a.addr)
80B	  %2:gr32 = ADD32ri8 killed %2:gr32, 1, implicit-def dead $eflags
96B	  MOV32mr %stack.1.b, 1, $noreg, 0, $noreg, killed %2:gr32 :: (store 4 into %ir.b)
112B	  %3:gr32 = MOV32rm %stack.1.b, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.b)
128B	  $eax = COPY killed %3:gr32
144B	  RET 0, $eax
> renamable $edi = COPY $edi
Identity copy: renamable $edi = COPY $edi
  deleted.
> MOV32mr %stack.0.a.addr, 1, $noreg, 0, $noreg, killed renamable $edi :: (store 4 into %ir.a.addr)
> renamable $eax = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.a.addr)
> renamable $eax = ADD32ri8 killed renamable $eax, 1, implicit-def dead $eflags
> MOV32mr %stack.1.b, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.b)
> renamable $eax = MOV32rm %stack.1.b, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.b)
> $eax = COPY killed renamable $eax
Identity copy: $eax = COPY killed renamable $eax
  deleted.
> RET 0, $eax
********** Stack Slot Coloring **********
********** Function: fun
Skipping pass 'Stack Slot Coloring' on function fun
Skipping pass 'Machine Copy Propagation Pass' on function fun
Skipping pass 'Machine Loop Invariant Code Motion' on function fun

block-frequency: fun
====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: fun
 - BB0[entry]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.0
Skipping pass 'Shrink Wrapping analysis' on function fun
alloc FI(1) at SP[-20]
alloc FI(0) at SP[-24]
Skipping pass 'Control Flow Optimizer' on function fun
Skipping pass 'Tail Duplication' on function fun
Skipping pass 'Machine Copy Propagation Pass' on function fun
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: fun
	discovered a new reachable node %bb.0
Skipping pass 'Post RA top-down list latency scheduler' on function fun

block-frequency: fun
====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: fun
 - BB0[entry]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.0
Skipping pass 'Branch Probability Basic Block Placement' on function fun
Skipping pass 'ReachingDefAnalysis' on function fun
Skipping pass 'X86 Execution Dependency Fix' on function fun
Skipping pass 'BreakFalseDeps' on function fun
	discovered a new reachable node %bb.0
Skipping pass 'X86 Byte/Word Instruction Fixup' on function fun
Skipping pass 'X86 Atom pad short functions' on function fun
Skipping pass 'X86 LEA Fixup' on function fun
********** COMPUTING STACKMAP LIVENESS: fun **********
X86 Retpoline Thunks
	discovered a new reachable node %bb.0
