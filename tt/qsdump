Args: /home/zl/work/llvm7/build/bin/llc qs.ll -debug -fast-isel=false -o tt.s 
	discovered a new reachable node %entry
	discovered a new reachable node %if.then
	discovered a new reachable node %while.cond
	discovered a new reachable node %while.body
	discovered a new reachable node %while.cond2
	discovered a new reachable node %land.rhs
	discovered a new reachable node %land.end
	discovered a new reachable node %while.body7
	discovered a new reachable node %while.end
	discovered a new reachable node %if.then9
	discovered a new reachable node %if.end
	discovered a new reachable node %while.cond14
	discovered a new reachable node %land.rhs16
	discovered a new reachable node %land.end20
	discovered a new reachable node %while.body21
	discovered a new reachable node %while.end23
	discovered a new reachable node %if.then25
	discovered a new reachable node %if.end31
	discovered a new reachable node %while.end32
	discovered a new reachable node %if.end35

Features:+64bit,+sse2,+fxsr,+mmx,+sse,+sse2,+x87
CPU:x86-64

Subtarget features: SSELevel 2, 3DNowLevel 1, 64bit 1
G_ADD (opcode 34): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SUB (opcode 35): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_MUL (opcode 36): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SDIV (opcode 37): 1 type index
.. opcode 37 is aliased to 84
.. opcode 84 is aliased to 0
.. the first uncovered type index: 1, OK
G_UDIV (opcode 38): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SREM (opcode 39): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_UREM (opcode 40): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_AND (opcode 41): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_OR (opcode 42): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_XOR (opcode 43): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_IMPLICIT_DEF (opcode 44): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_PHI (opcode 45): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FRAME_INDEX (opcode 46): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_GLOBAL_VALUE (opcode 47): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_EXTRACT (opcode 48): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UNMERGE_VALUES (opcode 49): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_INSERT (opcode 50): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_MERGE_VALUES (opcode 51): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_PTRTOINT (opcode 52): 2 type indices
.. the first uncovered type index: 2, OK
G_INTTOPTR (opcode 53): 2 type indices
.. the first uncovered type index: 2, OK
G_BITCAST (opcode 54): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_LOAD (opcode 55): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SEXTLOAD (opcode 56): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ZEXTLOAD (opcode 57): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_STORE (opcode 58): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG_WITH_SUCCESS (opcode 59): 3 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG (opcode 60): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XCHG (opcode 61): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_ADD (opcode 62): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_SUB (opcode 63): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_AND (opcode 64): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_NAND (opcode 65): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_OR (opcode 66): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XOR (opcode 67): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MAX (opcode 68): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MIN (opcode 69): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMAX (opcode 70): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMIN (opcode 71): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_BRCOND (opcode 72): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_BRINDIRECT (opcode 73): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_INTRINSIC (opcode 74): 0 type indices
.. type index coverage check SKIPPED: no rules defined
G_INTRINSIC_W_SIDE_EFFECTS (opcode 75): 0 type indices
.. type index coverage check SKIPPED: no rules defined
G_ANYEXT (opcode 76): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_TRUNC (opcode 77): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_CONSTANT (opcode 78): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FCONSTANT (opcode 79): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_VASTART (opcode 80): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_VAARG (opcode 81): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SEXT (opcode 82): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_ZEXT (opcode 83): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SHL (opcode 84): 1 type index
.. the first uncovered type index: 1, OK
G_LSHR (opcode 85): 1 type index
.. opcode 85 is aliased to 84
.. opcode 84 is aliased to 0
.. the first uncovered type index: 1, OK
G_ASHR (opcode 86): 1 type index
.. opcode 86 is aliased to 84
.. opcode 84 is aliased to 0
.. the first uncovered type index: 1, OK
G_ICMP (opcode 87): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FCMP (opcode 88): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SELECT (opcode 89): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UADDE (opcode 90): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_USUBE (opcode 91): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SADDO (opcode 92): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SSUBO (opcode 93): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UMULO (opcode 94): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SMULO (opcode 95): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_UMULH (opcode 96): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_SMULH (opcode 97): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FADD (opcode 98): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FSUB (opcode 99): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FMUL (opcode 100): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FMA (opcode 101): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FDIV (opcode 102): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FREM (opcode 103): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FPOW (opcode 104): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FEXP (opcode 105): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FEXP2 (opcode 106): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FLOG (opcode 107): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FLOG2 (opcode 108): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FNEG (opcode 109): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_FPEXT (opcode 110): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FPTRUNC (opcode 111): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FPTOSI (opcode 112): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FPTOUI (opcode 113): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_SITOFP (opcode 114): 2 type indices
.. the first uncovered type index: 2, OK
G_UITOFP (opcode 115): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_FABS (opcode 116): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_GEP (opcode 117): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_PTR_MASK (opcode 118): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_BR (opcode 119): 0 type indices
.. type index coverage check SKIPPED: no rules defined
G_INSERT_VECTOR_ELT (opcode 120): 3 type indices
.. type index coverage check SKIPPED: no rules defined
G_EXTRACT_VECTOR_ELT (opcode 121): 3 type indices
.. type index coverage check SKIPPED: no rules defined
G_SHUFFLE_VECTOR (opcode 122): 3 type indices
.. type index coverage check SKIPPED: no rules defined
G_BSWAP (opcode 123): 1 type index
.. type index coverage check SKIPPED: no rules defined
G_ADDRSPACE_CAST (opcode 124): 2 type indices
.. type index coverage check SKIPPED: no rules defined
G_BLOCK_ADDR (opcode 125): 1 type index
.. type index coverage check SKIPPED: no rules defined
	discovered a new reachable node %entry
	discovered a new reachable node %if.then
	discovered a new reachable node %while.cond
	discovered a new reachable node %while.body
	discovered a new reachable node %while.cond2
	discovered a new reachable node %land.rhs
	discovered a new reachable node %land.end
	discovered a new reachable node %while.body7
	discovered a new reachable node %while.end
	discovered a new reachable node %if.then9
	discovered a new reachable node %if.end
	discovered a new reachable node %while.cond14
	discovered a new reachable node %land.rhs16
	discovered a new reachable node %land.end20
	discovered a new reachable node %while.body21
	discovered a new reachable node %while.end23
	discovered a new reachable node %if.then25
	discovered a new reachable node %if.end31
	discovered a new reachable node %while.end32
	discovered a new reachable node %if.end35
	discovered a new reachable node %entry
	discovered a new reachable node %if.then
	discovered a new reachable node %while.cond
	discovered a new reachable node %while.body
	discovered a new reachable node %while.cond2
	discovered a new reachable node %land.rhs
	discovered a new reachable node %land.end
	discovered a new reachable node %while.body7
	discovered a new reachable node %while.end
	discovered a new reachable node %if.then9
	discovered a new reachable node %if.end
	discovered a new reachable node %while.cond14
	discovered a new reachable node %land.rhs16
	discovered a new reachable node %land.end20
	discovered a new reachable node %while.body21
	discovered a new reachable node %while.end23
	discovered a new reachable node %if.then25
	discovered a new reachable node %if.end31
	discovered a new reachable node %while.end32
	discovered a new reachable node %if.end35
Skipping pass 'Loop Strength Reduction' in function quick_sort
Skipping pass 'Loop Strength Reduction' in function quick_sort
Skipping pass 'Loop Strength Reduction' in function quick_sort
Skipping pass 'Merge contiguous icmps into a memcmp' on function quick_sort
Skipping pass 'Expand memcmp() to load/stores' on function quick_sort
	discovered a new reachable node %entry
	discovered a new reachable node %if.then
	discovered a new reachable node %while.cond
	discovered a new reachable node %while.body
	discovered a new reachable node %while.cond2
	discovered a new reachable node %land.rhs
	discovered a new reachable node %land.end
	discovered a new reachable node %while.body7
	discovered a new reachable node %while.end
	discovered a new reachable node %if.then9
	discovered a new reachable node %if.end
	discovered a new reachable node %while.cond14
	discovered a new reachable node %land.rhs16
	discovered a new reachable node %land.end20
	discovered a new reachable node %while.body21
	discovered a new reachable node %while.end23
	discovered a new reachable node %if.then25
	discovered a new reachable node %if.end31
	discovered a new reachable node %while.end32
	discovered a new reachable node %if.end35
---- Branch Probability Info : quick_sort ----

BPI: SCC 2: if.end31 if.then25 while.end23 while.body21 land.end20 land.rhs16 while.cond14 if.end if.then9 while.end while.body7 land.end land.rhs while.cond2 while.body while.cond
Computing probabilities for while.body7
Computing probabilities for while.body21
Computing probabilities for if.end31
Computing probabilities for if.then25
Computing probabilities for while.end23
Computing probabilities for land.end20
set edge land.end20 -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge land.end20 -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for land.rhs16
Computing probabilities for while.cond14
Computing probabilities for if.end
Computing probabilities for if.then9
Computing probabilities for while.end
Computing probabilities for land.end
set edge land.end -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge land.end -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for land.rhs
Computing probabilities for while.cond2
Computing probabilities for while.body
Computing probabilities for if.end35
Computing probabilities for while.end32
Computing probabilities for while.cond
set edge while.cond -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge while.cond -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for if.then
Computing probabilities for entry

block-frequency: quick_sort
===========================
reverse-post-order-traversal
 - 0: entry
 - 1: if.then
 - 2: while.cond
 - 3: while.end32
 - 4: if.end35
 - 5: while.body
 - 6: while.cond2
 - 7: land.rhs
 - 8: land.end
 - 9: while.end
 - 10: if.then9
 - 11: if.end
 - 12: while.cond14
 - 13: land.rhs16
 - 14: land.end20
 - 15: while.end23
 - 16: if.then25
 - 17: if.end31
 - 18: while.body21
 - 19: while.body7
loop-detection
 - loop = while.cond
 - loop = while.cond2
 - loop = while.cond14
 - loop = while.cond: member = while.body
 - loop = while.cond2: member = land.rhs
 - loop = while.cond2: member = land.end
 - loop = while.cond: member = while.end
 - loop = while.cond: member = if.then9
 - loop = while.cond: member = if.end
 - loop = while.cond14: member = land.rhs16
 - loop = while.cond14: member = land.end20
 - loop = while.cond: member = while.end23
 - loop = while.cond: member = if.then25
 - loop = while.cond: member = if.end31
 - loop = while.cond14: member = while.body21
 - loop = while.cond2: member = while.body7
compute-mass-in-loop: while.cond14*
 - node: while.cond14
  => [ local  ] weight = 1073741824, succ = land.rhs16
  => [ local  ] weight = 1073741824, succ = land.end20
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to land.rhs16
  => assign 8000000000000000 (0000000000000000) to land.end20
 - node: land.rhs16
  => [ local  ] weight = 2147483648, succ = land.end20
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to land.end20
 - node: land.end20
  => [ local  ] weight = 2080374784, succ = while.body21
  => [  exit  ] weight = 67108864, succ = while.end23
  => mass:  ffffffffffffffff
  => assign 07ffffffffffffff (f800000000000000) [exit] to while.end23
  => assign f800000000000000 (0000000000000000) to while.body21
 - node: while.body21
  => [backedge] weight = 2147483648
  => mass:  f800000000000000
  => assign f800000000000000 (0000000000000000) [back] to while.cond14
compute-loop-scale: while.cond14*
 - exit-mass = 07ffffffffffffff (ffffffffffffffff - f800000000000000)
 - scale = 32.0
packaging-loop: while.cond14*
 - node: while.cond14
 - node: land.rhs16
 - node: land.end20
 - node: while.body21
compute-mass-in-loop: while.cond2*
 - node: while.cond2
  => [ local  ] weight = 1073741824, succ = land.rhs
  => [ local  ] weight = 1073741824, succ = land.end
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to land.rhs
  => assign 8000000000000000 (0000000000000000) to land.end
 - node: land.rhs
  => [ local  ] weight = 2147483648, succ = land.end
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to land.end
 - node: land.end
  => [ local  ] weight = 2080374784, succ = while.body7
  => [  exit  ] weight = 67108864, succ = while.end
  => mass:  ffffffffffffffff
  => assign 07ffffffffffffff (f800000000000000) [exit] to while.end
  => assign f800000000000000 (0000000000000000) to while.body7
 - node: while.body7
  => [backedge] weight = 2147483648
  => mass:  f800000000000000
  => assign f800000000000000 (0000000000000000) [back] to while.cond2
compute-loop-scale: while.cond2*
 - exit-mass = 07ffffffffffffff (ffffffffffffffff - f800000000000000)
 - scale = 32.0
packaging-loop: while.cond2*
 - node: while.cond2
 - node: land.rhs
 - node: land.end
 - node: while.body7
compute-mass-in-loop: while.cond*
 - node: while.cond
  => [ local  ] weight = 2080374784, succ = while.body
  => [  exit  ] weight = 67108864, succ = while.end32
  => mass:  ffffffffffffffff
  => assign 07ffffffffffffff (f800000000000000) [exit] to while.end32
  => assign f800000000000000 (0000000000000000) to while.body
 - node: while.body
  => [ local  ] weight = 2147483648, succ = while.cond2
  => mass:  f800000000000000
  => assign f800000000000000 (0000000000000000) to while.cond2
 - node: while.cond2
  => [ local  ] weight = 576460752303423487, succ = while.end
  => mass:  f800000000000000
  => assign f800000000000000 (0000000000000000) to while.end
 - node: while.end
  => [ local  ] weight = 1073741824, succ = if.then9
  => [ local  ] weight = 1073741824, succ = if.end
  => mass:  f800000000000000
  => assign 7c00000000000000 (7c00000000000000) to if.then9
  => assign 7c00000000000000 (0000000000000000) to if.end
 - node: if.then9
  => [ local  ] weight = 2147483648, succ = if.end
  => mass:  7c00000000000000
  => assign 7c00000000000000 (0000000000000000) to if.end
 - node: if.end
  => [ local  ] weight = 2147483648, succ = while.cond14
  => mass:  f800000000000000
  => assign f800000000000000 (0000000000000000) to while.cond14
 - node: while.cond14
  => [ local  ] weight = 576460752303423487, succ = while.end23
  => mass:  f800000000000000
  => assign f800000000000000 (0000000000000000) to while.end23
 - node: while.end23
  => [ local  ] weight = 1073741824, succ = if.then25
  => [ local  ] weight = 1073741824, succ = if.end31
  => mass:  f800000000000000
  => assign 7c00000000000000 (7c00000000000000) to if.then25
  => assign 7c00000000000000 (0000000000000000) to if.end31
 - node: if.then25
  => [ local  ] weight = 2147483648, succ = if.end31
  => mass:  7c00000000000000
  => assign 7c00000000000000 (0000000000000000) to if.end31
 - node: if.end31
  => [backedge] weight = 2147483648
  => mass:  f800000000000000
  => assign f800000000000000 (0000000000000000) [back] to while.cond
compute-loop-scale: while.cond*
 - exit-mass = 07ffffffffffffff (ffffffffffffffff - f800000000000000)
 - scale = 32.0
packaging-loop: while.cond*
 - node: while.cond
 - node: while.body
 - node: while.cond2
 - node: while.end
 - node: if.then9
 - node: if.end
 - node: while.cond14
 - node: while.end23
 - node: if.then25
 - node: if.end31
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1073741824, succ = if.then
  => [ local  ] weight = 1073741824, succ = if.end35
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to if.then
  => assign 8000000000000000 (0000000000000000) to if.end35
 - node: if.then
  => [ local  ] weight = 2147483648, succ = while.cond
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to while.cond
 - node: while.cond
  => [ local  ] weight = 576460752303423487, succ = while.end32
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to while.end32
 - node: while.end32
  => [ local  ] weight = 2147483648, succ = if.end35
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to if.end35
 - node: if.end35
  => mass:  ffffffffffffffff
unwrap-loop-package: while.cond*: mass = 7fffffffffffffff, scale = 32.0
  => combined-scale = 16.0
 - while.cond: 1.0 => 16.0
 - while.body: 0.96875 => 15.5
 - while.cond2: 32.0 => 512.0
 - while.end: 0.96875 => 15.5
 - if.then9: 0.484375 => 7.75
 - if.end: 0.96875 => 15.5
 - while.cond14: 32.0 => 512.0
 - while.end23: 0.96875 => 15.5
 - if.then25: 0.484375 => 7.75
 - if.end31: 0.96875 => 15.5
unwrap-loop-package: while.cond2*: mass = f800000000000000, scale = 512.0
  => combined-scale = 496.0
 - while.cond2: 1.0 => 496.0
 - land.rhs: 0.5 => 248.0
 - land.end: 1.0 => 496.0
 - while.body7: 0.96875 => 480.5
unwrap-loop-package: while.cond14*: mass = f800000000000000, scale = 512.0
  => combined-scale = 496.0
 - while.cond14: 1.0 => 496.0
 - land.rhs16: 0.5 => 248.0
 - land.end20: 1.0 => 496.0
 - while.body21: 0.96875 => 480.5
float-to-int: min = 0.5, max = 496.0, factor = 16.0
 - entry: float = 1.0, scaled = 16.0, int = 16
 - if.then: float = 0.5, scaled = 8.0, int = 8
 - while.cond: float = 16.0, scaled = 256.0, int = 256
 - while.end32: float = 0.5, scaled = 8.0, int = 8
 - if.end35: float = 1.0, scaled = 16.0, int = 16
 - while.body: float = 15.5, scaled = 248.0, int = 248
 - while.cond2: float = 496.0, scaled = 7936.0, int = 7936
 - land.rhs: float = 248.0, scaled = 3968.0, int = 3968
 - land.end: float = 496.0, scaled = 7936.0, int = 7936
 - while.end: float = 15.5, scaled = 248.0, int = 248
 - if.then9: float = 7.75, scaled = 124.0, int = 124
 - if.end: float = 15.5, scaled = 248.0, int = 248
 - while.cond14: float = 496.0, scaled = 7936.0, int = 7936
 - land.rhs16: float = 248.0, scaled = 3968.0, int = 3968
 - land.end20: float = 496.0, scaled = 7936.0, int = 7936
 - while.end23: float = 15.5, scaled = 248.0, int = 248
 - if.then25: float = 7.75, scaled = 124.0, int = 124
 - if.end31: float = 15.5, scaled = 248.0, int = 248
 - while.body21: float = 480.5, scaled = 7688.0, int = 7688
 - while.body7: float = 480.5, scaled = 7688.0, int = 7688
block-frequency-info: quick_sort
 - entry: float = 1.0, int = 16
 - if.then: float = 0.5, int = 8
 - while.cond: float = 16.0, int = 256
 - while.body: float = 15.5, int = 248
 - while.cond2: float = 496.0, int = 7936
 - land.rhs: float = 248.0, int = 3968
 - land.end: float = 496.0, int = 7936
 - while.body7: float = 480.5, int = 7688
 - while.end: float = 15.5, int = 248
 - if.then9: float = 7.75, int = 124
 - if.end: float = 15.5, int = 248
 - while.cond14: float = 496.0, int = 7936
 - land.rhs16: float = 248.0, int = 3968
 - land.end20: float = 496.0, int = 7936
 - while.body21: float = 480.5, int = 7688
 - while.end23: float = 15.5, int = 248
 - if.then25: float = 7.75, int = 124
 - if.end31: float = 15.5, int = 248
 - while.end32: float = 0.5, int = 8
 - if.end35: float = 1.0, int = 16

Skipping pass 'Constant Hoisting' on function quick_sort
Skipping pass 'Partially inline calls to library functions' on function quick_sort
	discovered a new reachable node %entry
	discovered a new reachable node %if.then
	discovered a new reachable node %while.cond
	discovered a new reachable node %while.body
	discovered a new reachable node %while.cond2
	discovered a new reachable node %land.rhs
	discovered a new reachable node %land.end
	discovered a new reachable node %while.body7
	discovered a new reachable node %while.end
	discovered a new reachable node %if.then9
	discovered a new reachable node %if.end
	discovered a new reachable node %while.cond14
	discovered a new reachable node %land.rhs16
	discovered a new reachable node %land.end20
	discovered a new reachable node %while.body21
	discovered a new reachable node %while.end23
	discovered a new reachable node %if.then25
	discovered a new reachable node %if.end31
	discovered a new reachable node %while.end32
	discovered a new reachable node %if.end35
*** Interleaved Access Pass: quick_sort
	discovered a new reachable node %entry
	discovered a new reachable node %if.then
	discovered a new reachable node %while.cond
	discovered a new reachable node %while.body
	discovered a new reachable node %while.cond2
	discovered a new reachable node %land.rhs
	discovered a new reachable node %land.end
	discovered a new reachable node %while.body7
	discovered a new reachable node %while.end
	discovered a new reachable node %if.then9
	discovered a new reachable node %if.end
	discovered a new reachable node %while.cond14
	discovered a new reachable node %land.rhs16
	discovered a new reachable node %land.end20
	discovered a new reachable node %while.body21
	discovered a new reachable node %while.end23
	discovered a new reachable node %if.then25
	discovered a new reachable node %if.end31
	discovered a new reachable node %while.end32
	discovered a new reachable node %if.end35
Skipping pass 'CodeGen Prepare' on function quick_sort
	discovered a new reachable node %entry
	discovered a new reachable node %if.then
	discovered a new reachable node %while.cond
	discovered a new reachable node %while.body
	discovered a new reachable node %while.cond2
	discovered a new reachable node %land.rhs
	discovered a new reachable node %land.end
	discovered a new reachable node %while.body7
	discovered a new reachable node %while.end
	discovered a new reachable node %if.then9
	discovered a new reachable node %if.end
	discovered a new reachable node %while.cond14
	discovered a new reachable node %land.rhs16
	discovered a new reachable node %land.end20
	discovered a new reachable node %while.body21
	discovered a new reachable node %while.end23
	discovered a new reachable node %if.then25
	discovered a new reachable node %if.end31
	discovered a new reachable node %while.end32
	discovered a new reachable node %if.end35
[SafeStack] Function: quick_sort
[SafeStack]     safestack is not requested for this function
	discovered a new reachable node %entry
	discovered a new reachable node %if.then
	discovered a new reachable node %while.cond
	discovered a new reachable node %while.body
	discovered a new reachable node %while.cond2
	discovered a new reachable node %land.rhs
	discovered a new reachable node %land.end
	discovered a new reachable node %while.body7
	discovered a new reachable node %while.end
	discovered a new reachable node %if.then9
	discovered a new reachable node %if.end
	discovered a new reachable node %while.cond14
	discovered a new reachable node %land.rhs16
	discovered a new reachable node %land.end20
	discovered a new reachable node %while.body21
	discovered a new reachable node %while.end23
	discovered a new reachable node %if.then25
	discovered a new reachable node %if.end31
	discovered a new reachable node %while.end32
	discovered a new reachable node %if.end35
	discovered a new reachable node %entry
	discovered a new reachable node %if.then
	discovered a new reachable node %while.cond
	discovered a new reachable node %while.body
	discovered a new reachable node %while.cond2
	discovered a new reachable node %land.rhs
	discovered a new reachable node %land.end
	discovered a new reachable node %while.body7
	discovered a new reachable node %while.end
	discovered a new reachable node %if.then9
	discovered a new reachable node %if.end
	discovered a new reachable node %while.cond14
	discovered a new reachable node %land.rhs16
	discovered a new reachable node %land.end20
	discovered a new reachable node %while.body21
	discovered a new reachable node %while.end23
	discovered a new reachable node %if.then25
	discovered a new reachable node %if.end31
	discovered a new reachable node %while.end32
	discovered a new reachable node %if.end35
---- Branch Probability Info : quick_sort ----

BPI: SCC 2: if.end31 if.then25 while.end23 while.body21 land.end20 land.rhs16 while.cond14 if.end if.then9 while.end while.body7 land.end land.rhs while.cond2 while.body while.cond
Computing probabilities for while.body7
Computing probabilities for while.body21
Computing probabilities for if.end31
Computing probabilities for if.then25
Computing probabilities for while.end23
Computing probabilities for land.end20
set edge land.end20 -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge land.end20 -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for land.rhs16
Computing probabilities for while.cond14
Computing probabilities for if.end
Computing probabilities for if.then9
Computing probabilities for while.end
Computing probabilities for land.end
set edge land.end -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge land.end -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for land.rhs
Computing probabilities for while.cond2
Computing probabilities for while.body
Computing probabilities for if.end35
Computing probabilities for while.end32
Computing probabilities for while.cond
set edge while.cond -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge while.cond -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for if.then
Computing probabilities for entry
Skipping pass 'X86 DAG->DAG Instruction Selection' on function quick_sort

Changing optimization level for Function quick_sort
	Before: -O2 ; After: -O0
	FastISel is disabled



=== quick_sort
Found argument copy elision candidate:   %l.addr = alloca i32, align 4
Found argument copy elision candidate:   %r.addr = alloca i32, align 4
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %4
Creating new node: t4: i32,ch = CopyFromReg t0, Register:i32 %5
Creating constant: t6: i64 = Constant<0>
Creating new node: t7: i64 = undef
Creating new node: t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Creating new node: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
Creating new node: t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
Creating new node: t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64
Creating new node: t14: i1 = setcc t11, t12, setlt:ch
Creating constant: t15: i1 = Constant<-1>
Creating new node: t16: i1 = xor t14, Constant:i1<-1>
Creating new node: t18: ch = brcond t10, t16, BasicBlock:ch<if.end35 0x77486d0>
Creating new node: t20: ch = br t18, BasicBlock:ch<if.then 0x773fa80>
Initial selection DAG: %bb.0 'quick_sort:entry'
SelectionDAG has 21 nodes:
  t0: ch = EntryToken
  t6: i64 = Constant<0>
      t2: i32,ch = CopyFromReg t0, Register:i32 %4
    t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
    t4: i32,ch = CopyFromReg t0, Register:i32 %5
  t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
          t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
          t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64
        t14: i1 = setcc t11, t12, setlt:ch
      t16: i1 = xor t14, Constant:i1<-1>
    t18: ch = brcond t10, t16, BasicBlock:ch<if.end35 0x77486d0>
  t20: ch = br t18, BasicBlock:ch<if.then 0x773fa80>



Combining: t20: ch = br t18, BasicBlock:ch<if.then 0x773fa80>

Combining: t19: ch = BasicBlock<if.then 0x773fa80>

Combining: t18: ch = brcond t10, t16, BasicBlock:ch<if.end35 0x77486d0>
Creating new node: t22: i1 = setcc t11, t12, setge:ch
Creating new node: t23: ch = brcond t10, t22, BasicBlock:ch<if.end35 0x77486d0>
 ... into: t23: ch = brcond t10, t22, BasicBlock:ch<if.end35 0x77486d0>

Combining: t20: ch = br t23, BasicBlock:ch<if.then 0x773fa80>

Combining: t23: ch = brcond t10, t22, BasicBlock:ch<if.end35 0x77486d0>

Combining: t22: i1 = setcc t11, t12, setge:ch

Combining: t21: ch = setge

Combining: t17: ch = BasicBlock<if.end35 0x77486d0>

Combining: t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64

Combining: t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64

Combining: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64

Combining: t9: i64 = FrameIndex<1>

Combining: t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64

Combining: t7: i64 = undef

Combining: t5: i64 = FrameIndex<0>

Combining: t4: i32,ch = CopyFromReg t0, Register:i32 %5

Combining: t3: i32 = Register %5

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %4

Combining: t1: i32 = Register %4

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'quick_sort:entry'
SelectionDAG has 18 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %4
    t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
    t4: i32,ch = CopyFromReg t0, Register:i32 %5
  t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
        t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
        t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64
      t22: i1 = setcc t11, t12, setge:ch
    t23: ch = brcond t10, t22, BasicBlock:ch<if.end35 0x77486d0>
  t20: ch = br t23, BasicBlock:ch<if.then 0x773fa80>


Legalizing node: t21: ch = setge
Analyzing result type: ch
Legal result type
Legally typed node: t21: ch = setge

Legalizing node: t19: ch = BasicBlock<if.then 0x773fa80>
Analyzing result type: ch
Legal result type
Legally typed node: t19: ch = BasicBlock<if.then 0x773fa80>

Legalizing node: t17: ch = BasicBlock<if.end35 0x77486d0>
Analyzing result type: ch
Legal result type
Legally typed node: t17: ch = BasicBlock<if.end35 0x77486d0>

Legalizing node: t9: i64 = FrameIndex<1>
Analyzing result type: i64
Legal result type
Legally typed node: t9: i64 = FrameIndex<1>

Legalizing node: t7: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = undef

Legalizing node: t5: i64 = FrameIndex<0>
Analyzing result type: i64
Legal result type
Legally typed node: t5: i64 = FrameIndex<0>

Legalizing node: t3: i32 = Register %5
Ignoring node results
Legally typed node: t3: i32 = Register %5

Legalizing node: t1: i32 = Register %4
Ignoring node results
Legally typed node: t1: i32 = Register %4

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %4
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %4

Legalizing node: t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %4
Legal operand
Analyzing operand: t5: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t7: i64 = undef
Legal operand
Legally typed node: t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64

Legalizing node: t4: i32,ch = CopyFromReg t0, Register:i32 %5
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: i32,ch = CopyFromReg t0, Register:i32 %5

Legalizing node: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t4: i32,ch = CopyFromReg t0, Register:i32 %5
Legal operand
Analyzing operand: t9: i64 = FrameIndex<1>
Legal operand
Analyzing operand: t7: i64 = undef
Legal operand
Legally typed node: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64

Legalizing node: t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t5: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t7: i64 = undef
Legal operand
Legally typed node: t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64

Legalizing node: t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t9: i64 = FrameIndex<1>
Legal operand
Analyzing operand: t7: i64 = undef
Legal operand
Legally typed node: t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64

Legalizing node: t22: i1 = setcc t11, t12, setge:ch
Analyzing result type: i1
Promote integer result: t22: i1 = setcc t11, t12, setge:ch

Creating new node: t24: i8 = setcc t11, t12, setge:ch
Legalizing node: t23: ch = brcond t10, t22, BasicBlock:ch<if.end35 0x77486d0>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t22: i1 = setcc t11, t12, setge:ch
Promote integer operand: t23: ch = brcond t10, t22, BasicBlock:ch<if.end35 0x77486d0>

Creating new node: t25: i8 = zero_extend t22
Legalizing node: t25: i8 = zero_extend t22
Analyzing result type: i8
Legal result type
Analyzing operand: t22: i1 = setcc t11, t12, setge:ch
Promote integer operand: t25: i8 = zero_extend t22

Creating constant: t26: i8 = Constant<1>
Creating new node: t27: i8 = and t24, Constant:i8<1>
Legalizing node: t26: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t26: i8 = Constant<1>

Legalizing node: t24: i8 = setcc t11, t12, setge:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t21: ch = setge
Legal operand
Legally typed node: t24: i8 = setcc t11, t12, setge:ch

Legalizing node: t27: i8 = and t24, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t24: i8 = setcc t11, t12, setge:ch
Legal operand
Analyzing operand: t26: i8 = Constant<1>
Legal operand
Legally typed node: t27: i8 = and t24, Constant:i8<1>

Legalizing node: t23: ch = brcond t10, t27, BasicBlock:ch<if.end35 0x77486d0>
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t27: i8 = and t24, Constant:i8<1>
Legal operand
Analyzing operand: t17: ch = BasicBlock<if.end35 0x77486d0>
Legal operand
Legally typed node: t23: ch = brcond t10, t27, BasicBlock:ch<if.end35 0x77486d0>

Legalizing node: t20: ch = br t23, BasicBlock:ch<if.then 0x773fa80>
Analyzing result type: ch
Legal result type
Analyzing operand: t23: ch = brcond t10, t27, BasicBlock:ch<if.end35 0x77486d0>
Legal operand
Analyzing operand: t19: ch = BasicBlock<if.then 0x773fa80>
Legal operand
Legally typed node: t20: ch = br t23, BasicBlock:ch<if.then 0x773fa80>

Legalizing node: t65535: ch = handlenode t20
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = br t23, BasicBlock:ch<if.then 0x773fa80>
Legal operand
Legally typed node: t65535: ch = handlenode t20

Type-legalized selection DAG: %bb.0 'quick_sort:entry'
SelectionDAG has 20 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %4
    t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
    t4: i32,ch = CopyFromReg t0, Register:i32 %5
  t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
          t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
          t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64
        t24: i8 = setcc t11, t12, setge:ch
      t27: i8 = and t24, Constant:i8<1>
    t23: ch = brcond t10, t27, BasicBlock:ch<if.end35 0x77486d0>
  t20: ch = br t23, BasicBlock:ch<if.then 0x773fa80>



Combining: t27: i8 = and t24, Constant:i8<1>

Replacing.2 t27: i8 = and t24, Constant:i8<1>

With: t24: i8 = setcc t11, t12, setge:ch


Combining: t24: i8 = setcc t11, t12, setge:ch

Combining: t23: ch = brcond t10, t24, BasicBlock:ch<if.end35 0x77486d0>

Combining: t21: ch = setge

Combining: t20: ch = br t23, BasicBlock:ch<if.then 0x773fa80>

Combining: t19: ch = BasicBlock<if.then 0x773fa80>

Combining: t17: ch = BasicBlock<if.end35 0x77486d0>

Combining: t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64

Combining: t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64

Combining: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64

Combining: t9: i64 = FrameIndex<1>

Combining: t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64

Combining: t7: i64 = undef

Combining: t5: i64 = FrameIndex<0>

Combining: t4: i32,ch = CopyFromReg t0, Register:i32 %5

Combining: t3: i32 = Register %5

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %4

Combining: t1: i32 = Register %4

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.0 'quick_sort:entry'
SelectionDAG has 18 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %4
    t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
    t4: i32,ch = CopyFromReg t0, Register:i32 %5
  t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
        t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
        t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64
      t24: i8 = setcc t11, t12, setge:ch
    t23: ch = brcond t10, t24, BasicBlock:ch<if.end35 0x77486d0>
  t20: ch = br t23, BasicBlock:ch<if.then 0x773fa80>



Legalizing: t20: ch = br t23, BasicBlock:ch<if.then 0x773fa80>
Legal node: nothing to do

Legalizing: t23: ch = brcond t10, t24, BasicBlock:ch<if.end35 0x77486d0>
Trying custom legalization
Creating new node: t28: i32,i32 = X86ISD::SUB t11, t12
Creating constant: t29: i8 = Constant<6>
Creating new node: t30: i8 = X86ISD::SETCC Constant:i8<6>, t28:1
Creating new node: t31: ch = X86ISD::BRCOND t10, BasicBlock:ch<if.end35 0x77486d0>, Constant:i8<6>, t28:1
Successfully custom legalized node
 ... replacing: t23: ch = brcond t10, t24, BasicBlock:ch<if.end35 0x77486d0>
     with:      t31: ch = X86ISD::BRCOND t10, BasicBlock:ch<if.end35 0x77486d0>, Constant:i8<6>, t28:1

Legalizing: t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
Legalizing non-extending load operation

Legalizing: t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64
Legalizing non-extending load operation

Legalizing: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t4: i32,ch = CopyFromReg t0, Register:i32 %5
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %4
Legal node: nothing to do

Legalizing: t19: ch = BasicBlock<if.then 0x773fa80>
Legal node: nothing to do

Legalizing: t17: ch = BasicBlock<if.end35 0x77486d0>
Legal node: nothing to do

Legalizing: t9: i64 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t7: i64 = undef
Legal node: nothing to do

Legalizing: t5: i64 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t3: i32 = Register %5

Legalizing: t1: i32 = Register %4

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t31: ch = X86ISD::BRCOND t10, BasicBlock:ch<if.end35 0x77486d0>, Constant:i8<6>, t28:1
Legal node: nothing to do

Legalizing: t29: i8 = Constant<6>
Legal node: nothing to do

Legalizing: t28: i32,i32 = X86ISD::SUB t11, t12
Legal node: nothing to do
Legalized selection DAG: %bb.0 'quick_sort:entry'
SelectionDAG has 18 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %4
    t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
    t4: i32,ch = CopyFromReg t0, Register:i32 %5
  t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
        t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
        t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64
      t28: i32,i32 = X86ISD::SUB t11, t12
    t31: ch = X86ISD::BRCOND t10, BasicBlock:ch<if.end35 0x77486d0>, Constant:i8<6>, t28:1
  t20: ch = br t31, BasicBlock:ch<if.then 0x773fa80>



Legalizing: t31: ch = X86ISD::BRCOND t10, BasicBlock:ch<if.end35 0x77486d0>, Constant:i8<6>, t28:1
Legal node: nothing to do

Combining: t31: ch = X86ISD::BRCOND t10, BasicBlock:ch<if.end35 0x77486d0>, Constant:i8<6>, t28:1

Legalizing: t29: i8 = Constant<6>
Legal node: nothing to do

Combining: t29: i8 = Constant<6>

Legalizing: t28: i32,i32 = X86ISD::SUB t11, t12
Legal node: nothing to do

Combining: t28: i32,i32 = X86ISD::SUB t11, t12

Legalizing: t20: ch = br t31, BasicBlock:ch<if.then 0x773fa80>
Legal node: nothing to do

Combining: t20: ch = br t31, BasicBlock:ch<if.then 0x773fa80>

Legalizing: t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
Legalizing non-extending load operation

Combining: t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64

Legalizing: t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64
Legalizing non-extending load operation

Combining: t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64

Legalizing: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64

Legalizing: t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64

Legalizing: t4: i32,ch = CopyFromReg t0, Register:i32 %5
Legal node: nothing to do

Combining: t4: i32,ch = CopyFromReg t0, Register:i32 %5

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %4
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %4

Legalizing: t19: ch = BasicBlock<if.then 0x773fa80>
Legal node: nothing to do

Combining: t19: ch = BasicBlock<if.then 0x773fa80>

Legalizing: t17: ch = BasicBlock<if.end35 0x77486d0>
Legal node: nothing to do

Combining: t17: ch = BasicBlock<if.end35 0x77486d0>

Legalizing: t9: i64 = FrameIndex<1>
Legal node: nothing to do

Combining: t9: i64 = FrameIndex<1>

Legalizing: t7: i64 = undef
Legal node: nothing to do

Combining: t7: i64 = undef

Legalizing: t5: i64 = FrameIndex<0>
Legal node: nothing to do

Combining: t5: i64 = FrameIndex<0>

Legalizing: t3: i32 = Register %5

Combining: t3: i32 = Register %5

Legalizing: t1: i32 = Register %4

Combining: t1: i32 = Register %4

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'quick_sort:entry'
SelectionDAG has 18 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %4
    t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
    t4: i32,ch = CopyFromReg t0, Register:i32 %5
  t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
        t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
        t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64
      t28: i32,i32 = X86ISD::SUB t11, t12
    t31: ch = X86ISD::BRCOND t10, BasicBlock:ch<if.end35 0x77486d0>, Constant:i8<6>, t28:1
  t20: ch = br t31, BasicBlock:ch<if.then 0x773fa80>


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t20: ch = br t31, BasicBlock:ch<if.then 0x773fa80>
ISEL: Starting pattern match
  Morphed node: t20: ch = JMP_1 BasicBlock:ch<if.then 0x773fa80>, t31
ISEL: Match complete!

ISEL: Starting selection on root node: t31: ch = X86ISD::BRCOND t10, BasicBlock:ch<if.end35 0x77486d0>, Constant:i8<6>, t28:1
ISEL: Starting pattern match
  Initial Opcode index to 150935
  Skipped scope entry (due to false predicate) at index 150944, continuing at 150957
  Skipped scope entry (due to false predicate) at index 150958, continuing at 150971
  Skipped scope entry (due to false predicate) at index 150972, continuing at 150985
  Skipped scope entry (due to false predicate) at index 150986, continuing at 150999
  Skipped scope entry (due to false predicate) at index 151000, continuing at 151013
  Skipped scope entry (due to false predicate) at index 151014, continuing at 151027
  Skipped scope entry (due to false predicate) at index 151028, continuing at 151041
  Skipped scope entry (due to false predicate) at index 151042, continuing at 151055
  Skipped scope entry (due to false predicate) at index 151056, continuing at 151069
  Skipped scope entry (due to false predicate) at index 151070, continuing at 151083
  Skipped scope entry (due to false predicate) at index 151084, continuing at 151097
  Skipped scope entry (due to false predicate) at index 151098, continuing at 151111
  Skipped scope entry (due to false predicate) at index 151112, continuing at 151125
Creating new node: t33: ch,glue = CopyToReg t10, Register:i32 $eflags, t28:1
  Morphed node: t31: ch = JGE_1 BasicBlock:ch<if.end35 0x77486d0>, t33, t33:1
ISEL: Match complete!

ISEL: Starting selection on root node: t28: i32,i32 = X86ISD::SUB t11, t12
ISEL: Starting pattern match
  Initial Opcode index to 119640
  Match failed at index 119649
  Continuing at 119747
  Match failed at index 119748
  Continuing at 119793
  Skipped scope entry (due to false predicate) at index 119803, continuing at 119884
  Match failed at index 119888
  Continuing at 119902
  Match failed at index 119906
  Continuing at 119920
  Match failed at index 119926
  Continuing at 119938
  Match failed at index 119939
  Continuing at 119958
  Match failed at index 119959
  Continuing at 119978
  Continuing at 119979
  Match failed at index 119980
  Continuing at 119991
  Match failed at index 119992
  Continuing at 120003
  Morphed node: t28: i32,i32 = SUB32rr t11, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t36: i8 = TargetConstant<1>
Creating constant: t37: i32 = TargetConstant<0>
  Morphed node: t11: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t12: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t10, FrameIndex:i64<1>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch = store<(store 4 into %ir.r.addr)> t8, t4, FrameIndex:i64<1>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  Match failed at index 1029
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t10: ch = MOV32mr<Mem:(store 4 into %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t4, t8
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch = store<(store 4 into %ir.l.addr)> t0, t2, FrameIndex:i64<0>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  Match failed at index 1029
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t8: ch = MOV32mr<Mem:(store 4 into %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t2, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = CopyFromReg t0, Register:i32 %5

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %4

ISEL: Starting selection on root node: t19: ch = BasicBlock<if.then 0x773fa80>

ISEL: Starting selection on root node: t17: ch = BasicBlock<if.end35 0x77486d0>

ISEL: Starting selection on root node: t3: i32 = Register %5

ISEL: Starting selection on root node: t1: i32 = Register %4

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'quick_sort:entry'
SelectionDAG has 22 nodes:
  t0: ch = EntryToken
    t4: i32,ch = CopyFromReg t0, Register:i32 %5
      t2: i32,ch = CopyFromReg t0, Register:i32 %4
    t8: ch = MOV32mr<Mem:(store 4 into %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t2, t0
  t10: ch = MOV32mr<Mem:(store 4 into %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t4, t8
      t11: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10
      t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10
    t28: i32,i32 = SUB32rr t11, t12
  t33: ch,glue = CopyToReg t10, Register:i32 $eflags, t28:1
    t31: ch = JGE_1 BasicBlock:ch<if.end35 0x77486d0>, t33, t33:1
  t20: ch = JMP_1 BasicBlock:ch<if.then 0x773fa80>, t31


********** List Scheduling %bb.0 'entry' **********
SU(0): t20: ch = JMP_1 BasicBlock:ch<if.then 0x773fa80>, t31

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t31: ch = JGE_1 BasicBlock:ch<if.end35 0x77486d0>, t33, t33:1

    t33: ch,glue = CopyToReg t10, Register:i32 $eflags, t28:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 1
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t28: i32,i32 = SUB32rr t11, t12

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(2): Data Latency=1
SU(4): t11: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 3
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(2): Data Latency=1
SU(5): t10: ch = MOV32mr<Mem:(store 4 into %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t4, t8

  # preds left       : 2
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 4
  Predecessors:
    SU(8): Data Latency=1
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
    SU(3): Ord  Latency=1 Barrier
    SU(4): Ord  Latency=1 Barrier
SU(6): t8: ch = MOV32mr<Mem:(store 4 into %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t2, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
    SU(7): Data Latency=1
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(7): t2: i32,ch = CopyFromReg t0, Register:i32 %4

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(6): Data Latency=1
SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %5

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(5): Data Latency=1

Examining Available:
Height 0: SU(0): t20: ch = JMP_1 BasicBlock:ch<if.then 0x773fa80>, t31


*** Scheduling [0]: SU(0): t20: ch = JMP_1 BasicBlock:ch<if.then 0x773fa80>, t31


Examining Available:
Height 1: SU(1): t31: ch = JGE_1 BasicBlock:ch<if.end35 0x77486d0>, t33, t33:1

    t33: ch,glue = CopyToReg t10, Register:i32 $eflags, t28:1


*** Scheduling [1]: SU(1): t31: ch = JGE_1 BasicBlock:ch<if.end35 0x77486d0>, t33, t33:1

    t33: ch,glue = CopyToReg t10, Register:i32 $eflags, t28:1


Examining Available:
Height 2: SU(2): t28: i32,i32 = SUB32rr t11, t12


*** Scheduling [2]: SU(2): t28: i32,i32 = SUB32rr t11, t12


Examining Available:
Height 3: SU(3): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10

Height 3: SU(4): t11: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10


*** Scheduling [3]: SU(3): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10


Examining Available:
Height 3: SU(4): t11: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10


*** Scheduling [4]: SU(4): t11: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10


Examining Available:
Height 5: SU(5): t10: ch = MOV32mr<Mem:(store 4 into %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t4, t8


*** Scheduling [5]: SU(5): t10: ch = MOV32mr<Mem:(store 4 into %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t4, t8


Examining Available:
Height 6: SU(6): t8: ch = MOV32mr<Mem:(store 4 into %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t2, t0

Height 6: SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %5


*** Scheduling [6]: SU(6): t8: ch = MOV32mr<Mem:(store 4 into %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t2, t0


Examining Available:
Height 7: SU(7): t2: i32,ch = CopyFromReg t0, Register:i32 %4

Height 6: SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %5


*** Scheduling [7]: SU(7): t2: i32,ch = CopyFromReg t0, Register:i32 %4


Examining Available:
Height 6: SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %5


*** Scheduling [8]: SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %5

*** Final schedule ***
SU(8): t4: i32,ch = CopyFromReg t0, Register:i32 %5

SU(7): t2: i32,ch = CopyFromReg t0, Register:i32 %4

SU(6): t8: ch = MOV32mr<Mem:(store 4 into %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t2, t0

SU(5): t10: ch = MOV32mr<Mem:(store 4 into %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t4, t8

SU(4): t11: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10

SU(3): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10

SU(2): t28: i32,i32 = SUB32rr t11, t12

SU(1): t31: ch = JGE_1 BasicBlock:ch<if.end35 0x77486d0>, t33, t33:1

    t33: ch,glue = CopyToReg t10, Register:i32 $eflags, t28:1

SU(0): t20: ch = JMP_1 BasicBlock:ch<if.then 0x773fa80>, t31


Total amount of phi nodes to update: 0
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64
Creating new node: t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64
Creating new node: t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64
Creating new node: t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64
Creating new node: t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
Creating new node: t12: i64 = sign_extend t11
Creating constant: t14: i64 = Constant<2>
Creating new node: t15: i64 = shl t12, Constant:i64<2>
Creating new node: t16: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t15
Creating new node: t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t16, undef:i64
Creating new node: t19: ch = TokenFactor t11:1, t17:1
Creating new node: t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64
Creating new node: t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>
Initial selection DAG: %bb.1 'quick_sort:if.then'
SelectionDAG has 23 nodes:
  t2: i64 = Constant<0>
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64
    t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64
  t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64
  t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64
  t11: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t10, FrameIndex:i64<0>, undef:i64
        t12: i64 = sign_extend t11
      t15: i64 = shl t12, Constant:i64<2>
    t16: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t15
  t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t16, undef:i64
      t19: ch = TokenFactor t11:1, t17:1
    t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64
  t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>



Combining: t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>

Combining: t21: ch = BasicBlock<while.cond 0x773fb48>

Combining: t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64

Combining: t19: ch = TokenFactor t11:1, t17:1

Combining: t18: i64 = FrameIndex<4>

Combining: t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t16, undef:i64

Combining: t16: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t15
Creating new node: t23: i64 = add t15, GlobalAddress:i64<[100 x i32]* @s> 0
 ... into: t23: i64 = add t15, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64

Combining: t23: i64 = add t15, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t15: i64 = shl t12, Constant:i64<2>

Combining: t14: i64 = Constant<2>

Combining: t13: i64 = GlobalAddress<[100 x i32]* @s> 0

Combining: t12: i64 = sign_extend t11
Creating new node: t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64

Replacing.1 t12: i64 = sign_extend t11

With: t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64
 and 0 other values

Combining: t15: i64 = shl t24, Constant:i64<2>

Combining: t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64

Combining: t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64

Combining: t9: i64 = FrameIndex<3>

Combining: t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64

Combining: t7: i64 = FrameIndex<1>

Combining: t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64

Combining: t5: i64 = FrameIndex<2>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<0>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.1 'quick_sort:if.then'
SelectionDAG has 21 nodes:
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64
    t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64
  t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64
  t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64
      t15: i64 = shl t24, Constant:i64<2>
    t23: i64 = add t15, GlobalAddress:i64<[100 x i32]* @s> 0
  t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64
  t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64
      t19: ch = TokenFactor t24:1, t17:1
    t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64
  t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>


Legalizing node: t21: ch = BasicBlock<while.cond 0x773fb48>
Analyzing result type: ch
Legal result type
Legally typed node: t21: ch = BasicBlock<while.cond 0x773fb48>

Legalizing node: t18: i64 = FrameIndex<4>
Analyzing result type: i64
Legal result type
Legally typed node: t18: i64 = FrameIndex<4>

Legalizing node: t14: i64 = Constant<2>
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = Constant<2>

Legalizing node: t13: i64 = GlobalAddress<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Legally typed node: t13: i64 = GlobalAddress<[100 x i32]* @s> 0

Legalizing node: t9: i64 = FrameIndex<3>
Analyzing result type: i64
Legal result type
Legally typed node: t9: i64 = FrameIndex<3>

Legalizing node: t7: i64 = FrameIndex<1>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = FrameIndex<1>

Legalizing node: t5: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t5: i64 = FrameIndex<2>

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<0>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<0>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64

Legalizing node: t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t5: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64

Legalizing node: t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t7: i64 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64

Legalizing node: t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t9: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64

Legalizing node: t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t1: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64

Legalizing node: t15: i64 = shl t24, Constant:i64<2>
Analyzing result type: i64
Legal result type
Analyzing operand: t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t14: i64 = Constant<2>
Legal operand
Legally typed node: t15: i64 = shl t24, Constant:i64<2>

Legalizing node: t23: i64 = add t15, GlobalAddress:i64<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Analyzing operand: t15: i64 = shl t24, Constant:i64<2>
Legal operand
Analyzing operand: t13: i64 = GlobalAddress<[100 x i32]* @s> 0
Legal operand
Legally typed node: t23: i64 = add t15, GlobalAddress:i64<[100 x i32]* @s> 0

Legalizing node: t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t23: i64 = add t15, GlobalAddress:i64<[100 x i32]* @s> 0
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64

Legalizing node: t19: ch = TokenFactor t24:1, t17:1
Analyzing result type: ch
Legal result type
Analyzing operand: t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64
Legal operand
Legally typed node: t19: ch = TokenFactor t24:1, t17:1

Legalizing node: t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t19: ch = TokenFactor t24:1, t17:1
Legal operand
Analyzing operand: t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64
Legal operand
Analyzing operand: t18: i64 = FrameIndex<4>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64

Legalizing node: t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64
Legal operand
Analyzing operand: t21: ch = BasicBlock<while.cond 0x773fb48>
Legal operand
Legally typed node: t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>

Legalizing node: t65535: ch = handlenode t22
Analyzing result type: ch
Legal result type
Analyzing operand: t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>
Legal operand
Legally typed node: t65535: ch = handlenode t22

Type-legalized selection DAG: %bb.1 'quick_sort:if.then'
SelectionDAG has 21 nodes:
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64
    t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64
  t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64
  t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64
      t15: i64 = shl t24, Constant:i64<2>
    t23: i64 = add t15, GlobalAddress:i64<[100 x i32]* @s> 0
  t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64
  t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64
      t19: ch = TokenFactor t24:1, t17:1
    t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64
  t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>



Legalizing: t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>
Legal node: nothing to do

Legalizing: t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t19: ch = TokenFactor t24:1, t17:1
Legal node: nothing to do

Legalizing: t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64
Legalizing non-extending load operation

Legalizing: t23: i64 = add t15, GlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t15: i64 = shl t24, Constant:i64<2>
Creating constant: t25: i8 = Constant<2>
Legal node: nothing to do

Legalizing: t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64
Legalizing extending load operation

Legalizing: t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64
Legalizing non-extending load operation

Legalizing: t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64
Legalizing non-extending load operation

Legalizing: t21: ch = BasicBlock<while.cond 0x773fb48>
Legal node: nothing to do

Legalizing: t18: i64 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t13: i64 = GlobalAddress<[100 x i32]* @s> 0
Trying custom legalization
Creating new node: t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Successfully custom legalized node
 ... replacing: t13: i64 = GlobalAddress<[100 x i32]* @s> 0
     with:      t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0

Legalizing: t9: i64 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t7: i64 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t5: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t26: i64 = TargetGlobalAddress<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t25: i8 = Constant<2>
Legal node: nothing to do
Legalized selection DAG: %bb.1 'quick_sort:if.then'
SelectionDAG has 22 nodes:
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64
    t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64
  t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64
  t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64
  t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64
      t15: i64 = shl t24, Constant:i8<2>
      t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
    t23: i64 = add t15, t27
  t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64
      t19: ch = TokenFactor t24:1, t17:1
    t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64
  t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>



Legalizing: t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Combining: t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0

Legalizing: t26: i64 = TargetGlobalAddress<[100 x i32]* @s> 0
Legal node: nothing to do

Combining: t26: i64 = TargetGlobalAddress<[100 x i32]* @s> 0

Legalizing: t25: i8 = Constant<2>
Legal node: nothing to do

Combining: t25: i8 = Constant<2>

Legalizing: t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>
Legal node: nothing to do

Combining: t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>

Legalizing: t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64

Legalizing: t19: ch = TokenFactor t24:1, t17:1
Legal node: nothing to do

Combining: t19: ch = TokenFactor t24:1, t17:1

Legalizing: t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64
Legalizing non-extending load operation

Combining: t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64

Legalizing: t23: i64 = add t15, t27
Legal node: nothing to do

Combining: t23: i64 = add t15, t27

Legalizing: t15: i64 = shl t24, Constant:i8<2>
Legal node: nothing to do

Combining: t15: i64 = shl t24, Constant:i8<2>

Legalizing: t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64
Legalizing extending load operation

Combining: t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64

Legalizing: t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64

Legalizing: t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64
Legalizing non-extending load operation

Combining: t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64

Legalizing: t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64

Legalizing: t21: ch = BasicBlock<while.cond 0x773fb48>
Legal node: nothing to do

Combining: t21: ch = BasicBlock<while.cond 0x773fb48>

Legalizing: t18: i64 = FrameIndex<4>
Legal node: nothing to do

Combining: t18: i64 = FrameIndex<4>

Legalizing: t9: i64 = FrameIndex<3>
Legal node: nothing to do

Combining: t9: i64 = FrameIndex<3>

Legalizing: t7: i64 = FrameIndex<1>
Legal node: nothing to do

Combining: t7: i64 = FrameIndex<1>

Legalizing: t5: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t5: i64 = FrameIndex<2>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<0>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.1 'quick_sort:if.then'
SelectionDAG has 22 nodes:
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64
    t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64
  t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64
  t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64
  t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64
      t15: i64 = shl t24, Constant:i8<2>
      t27: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
    t23: i64 = add t15, t27
  t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64
      t19: ch = TokenFactor t24:1, t17:1
    t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64
  t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>


===== Instruction selection begins: %bb.1 'if.then'

ISEL: Starting selection on root node: t22: ch = br t20, BasicBlock:ch<while.cond 0x773fb48>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t22: ch = JMP_1 BasicBlock:ch<while.cond 0x773fb48>, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: ch = store<(store 4 into %ir.x)> t19, t17, FrameIndex:i64<4>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  Match failed at index 1029
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t30: i8 = TargetConstant<1>
Creating constant: t31: i32 = TargetConstant<0>
  Morphed node: t20: ch = MOV32mr<Mem:(store 4 into %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t17, t19
ISEL: Match complete!

ISEL: Starting selection on root node: t19: ch = TokenFactor t24:1, t17:1

ISEL: Starting selection on root node: t17: i32,ch = load<(load 4 from %ir.arrayidx)> t10, t23, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 4
IndexReg t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t33: i8 = TargetConstant<4>
  Morphed node: t17: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t24: i64,ch = load<(dereferenceable load 4 from %ir.l.addr), sext from i32> t10, FrameIndex:i64<0>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Skipped scope entry (due to false predicate) at index 137189, continuing at 137208
  Skipped scope entry (due to false predicate) at index 137209, continuing at 137228
  Skipped scope entry (due to false predicate) at index 137229, continuing at 137248
  Skipped scope entry (due to false predicate) at index 137249, continuing at 137268
  Match failed at index 137271
  Continuing at 137311
  Match failed at index 137312
  Continuing at 137354
  Skipped scope entry (due to false predicate) at index 137361, continuing at 137378
  Skipped scope entry (due to false predicate) at index 137379, continuing at 137396
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10
ISEL: Match complete!

ISEL: Starting selection on root node: t10: ch = store<(store 4 into %ir.j)> t8:1, t8, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  Match failed at index 1029
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t10: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t8, t8:1
ISEL: Match complete!

ISEL: Starting selection on root node: t8: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t6, FrameIndex:i64<1>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t8: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6
ISEL: Match complete!

ISEL: Starting selection on root node: t6: ch = store<(store 4 into %ir.i)> t4:1, t4, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  Match failed at index 1029
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t6: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t4, t4:1
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t0, FrameIndex:i64<0>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = BasicBlock<while.cond 0x773fb48>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.1 'quick_sort:if.then'
SelectionDAG has 22 nodes:
    t0: ch = EntryToken
  t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
    t6: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t4, t4:1
  t8: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6
  t10: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t8, t8:1
  t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10
  t17: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10
      t19: ch = TokenFactor t24:1, t17:1
    t20: ch = MOV32mr<Mem:(store 4 into %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t17, t19
  t22: ch = JMP_1 BasicBlock:ch<while.cond 0x773fb48>, t20


********** List Scheduling %bb.1 'if.then' **********
SU(0): t22: ch = JMP_1 BasicBlock:ch<while.cond 0x773fb48>, t20

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t20: ch = MOV32mr<Mem:(store 4 into %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t17, t19

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 1
  Predecessors:
    SU(8): Data Latency=1
    SU(2): Ord  Latency=0 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t19: ch = TokenFactor t24:1, t17:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 1
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(3): t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 3
  Predecessors:
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(8): Data Latency=1
SU(4): t10: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t8, t8:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 4
  Predecessors:
    SU(5): Data Latency=1
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(3): Ord  Latency=1 Barrier
    SU(8): Ord  Latency=1 Barrier
SU(5): t8: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 5
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
SU(6): t6: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t4, t4:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 6
  Predecessors:
    SU(7): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
SU(7): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(6): Data Latency=1
    SU(6): Ord  Latency=1 Barrier
SU(8): t17: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
    SU(4): Ord  Latency=1 Barrier
  Successors:
    SU(1): Data Latency=1
    SU(2): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t22: ch = JMP_1 BasicBlock:ch<while.cond 0x773fb48>, t20


*** Scheduling [0]: SU(0): t22: ch = JMP_1 BasicBlock:ch<while.cond 0x773fb48>, t20


Examining Available:
Height 1: SU(1): t20: ch = MOV32mr<Mem:(store 4 into %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t17, t19


*** Scheduling [1]: SU(1): t20: ch = MOV32mr<Mem:(store 4 into %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t17, t19


Examining Available:
Height 1: SU(2): t19: ch = TokenFactor t24:1, t17:1


*** Scheduling [2]: SU(2): t19: ch = TokenFactor t24:1, t17:1


Examining Available:
Height 3: SU(8): t17: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10


*** Scheduling [3]: SU(8): t17: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10


Examining Available:
Height 4: SU(3): t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10


*** Scheduling [4]: SU(3): t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10


Examining Available:
Height 5: SU(4): t10: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t8, t8:1


*** Scheduling [5]: SU(4): t10: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t8, t8:1


Examining Available:
Height 6: SU(5): t8: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6


*** Scheduling [6]: SU(5): t8: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6


Examining Available:
Height 7: SU(6): t6: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t4, t4:1


*** Scheduling [7]: SU(6): t6: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t4, t4:1


Examining Available:
Height 8: SU(7): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [8]: SU(7): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(7): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(6): t6: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t4, t4:1

SU(5): t8: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6

SU(4): t10: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t8, t8:1

SU(3): t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t10

SU(8): t17: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10

SU(2): t19: ch = TokenFactor t24:1, t17:1

SU(1): t20: ch = MOV32mr<Mem:(store 4 into %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t17, t19

SU(0): t22: ch = JMP_1 BasicBlock:ch<while.cond 0x773fb48>, t20


Total amount of phi nodes to update: 0
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Creating new node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Creating new node: t8: i1 = setcc t4, t6, setlt:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch<while.end32 0x7748608>
Creating new node: t14: ch = br t12, BasicBlock:ch<while.body 0x773fc10>
Initial selection DAG: %bb.2 'quick_sort:while.cond'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
  t2: i64 = Constant<0>
          t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
          t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
        t8: i1 = setcc t4, t6, setlt:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch<while.end32 0x7748608>
  t14: ch = br t12, BasicBlock:ch<while.body 0x773fc10>



Combining: t14: ch = br t12, BasicBlock:ch<while.body 0x773fc10>

Combining: t13: ch = BasicBlock<while.body 0x773fc10>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch<while.end32 0x7748608>
Creating new node: t16: i1 = setcc t4, t6, setge:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch<while.end32 0x7748608>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch<while.end32 0x7748608>

Combining: t14: ch = br t17, BasicBlock:ch<while.body 0x773fc10>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch<while.end32 0x7748608>

Combining: t16: i1 = setcc t4, t6, setge:ch

Combining: t15: ch = setge

Combining: t11: ch = BasicBlock<while.end32 0x7748608>

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Combining: t5: i64 = FrameIndex<3>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.2 'quick_sort:while.cond'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t16: i1 = setcc t4, t6, setge:ch
    t17: ch = brcond t0, t16, BasicBlock:ch<while.end32 0x7748608>
  t14: ch = br t17, BasicBlock:ch<while.body 0x773fc10>


Legalizing node: t15: ch = setge
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = setge

Legalizing node: t13: ch = BasicBlock<while.body 0x773fc10>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock<while.body 0x773fc10>

Legalizing node: t11: ch = BasicBlock<while.end32 0x7748608>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock<while.end32 0x7748608>

Legalizing node: t5: i64 = FrameIndex<3>
Analyzing result type: i64
Legal result type
Legally typed node: t5: i64 = FrameIndex<3>

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<2>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Legalizing node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t5: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Legalizing node: t16: i1 = setcc t4, t6, setge:ch
Analyzing result type: i1
Promote integer result: t16: i1 = setcc t4, t6, setge:ch

Creating new node: t18: i8 = setcc t4, t6, setge:ch
Legalizing node: t17: ch = brcond t0, t16, BasicBlock:ch<while.end32 0x7748608>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t16: i1 = setcc t4, t6, setge:ch
Promote integer operand: t17: ch = brcond t0, t16, BasicBlock:ch<while.end32 0x7748608>

Creating new node: t19: i8 = zero_extend t16
Legalizing node: t19: i8 = zero_extend t16
Analyzing result type: i8
Legal result type
Analyzing operand: t16: i1 = setcc t4, t6, setge:ch
Promote integer operand: t19: i8 = zero_extend t16

Creating constant: t20: i8 = Constant<1>
Creating new node: t21: i8 = and t18, Constant:i8<1>
Legalizing node: t20: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t20: i8 = Constant<1>

Legalizing node: t18: i8 = setcc t4, t6, setge:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t15: ch = setge
Legal operand
Legally typed node: t18: i8 = setcc t4, t6, setge:ch

Legalizing node: t21: i8 = and t18, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t18: i8 = setcc t4, t6, setge:ch
Legal operand
Analyzing operand: t20: i8 = Constant<1>
Legal operand
Legally typed node: t21: i8 = and t18, Constant:i8<1>

Legalizing node: t17: ch = brcond t0, t21, BasicBlock:ch<while.end32 0x7748608>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t21: i8 = and t18, Constant:i8<1>
Legal operand
Analyzing operand: t11: ch = BasicBlock<while.end32 0x7748608>
Legal operand
Legally typed node: t17: ch = brcond t0, t21, BasicBlock:ch<while.end32 0x7748608>

Legalizing node: t14: ch = br t17, BasicBlock:ch<while.body 0x773fc10>
Analyzing result type: ch
Legal result type
Analyzing operand: t17: ch = brcond t0, t21, BasicBlock:ch<while.end32 0x7748608>
Legal operand
Analyzing operand: t13: ch = BasicBlock<while.body 0x773fc10>
Legal operand
Legally typed node: t14: ch = br t17, BasicBlock:ch<while.body 0x773fc10>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t17, BasicBlock:ch<while.body 0x773fc10>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.2 'quick_sort:while.cond'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
          t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
          t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
        t18: i8 = setcc t4, t6, setge:ch
      t21: i8 = and t18, Constant:i8<1>
    t17: ch = brcond t0, t21, BasicBlock:ch<while.end32 0x7748608>
  t14: ch = br t17, BasicBlock:ch<while.body 0x773fc10>



Combining: t21: i8 = and t18, Constant:i8<1>

Replacing.2 t21: i8 = and t18, Constant:i8<1>

With: t18: i8 = setcc t4, t6, setge:ch


Combining: t18: i8 = setcc t4, t6, setge:ch

Combining: t17: ch = brcond t0, t18, BasicBlock:ch<while.end32 0x7748608>

Combining: t15: ch = setge

Combining: t14: ch = br t17, BasicBlock:ch<while.body 0x773fc10>

Combining: t13: ch = BasicBlock<while.body 0x773fc10>

Combining: t11: ch = BasicBlock<while.end32 0x7748608>

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Combining: t5: i64 = FrameIndex<3>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.2 'quick_sort:while.cond'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t18: i8 = setcc t4, t6, setge:ch
    t17: ch = brcond t0, t18, BasicBlock:ch<while.end32 0x7748608>
  t14: ch = br t17, BasicBlock:ch<while.body 0x773fc10>



Legalizing: t14: ch = br t17, BasicBlock:ch<while.body 0x773fc10>
Legal node: nothing to do

Legalizing: t17: ch = brcond t0, t18, BasicBlock:ch<while.end32 0x7748608>
Trying custom legalization
Creating new node: t22: i32,i32 = X86ISD::SUB t4, t6
Creating constant: t23: i8 = Constant<6>
Creating new node: t24: i8 = X86ISD::SETCC Constant:i8<6>, t22:1
Creating new node: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end32 0x7748608>, Constant:i8<6>, t22:1
Successfully custom legalized node
 ... replacing: t17: ch = brcond t0, t18, BasicBlock:ch<while.end32 0x7748608>
     with:      t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end32 0x7748608>, Constant:i8<6>, t22:1

Legalizing: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Legalizing: t13: ch = BasicBlock<while.body 0x773fc10>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock<while.end32 0x7748608>
Legal node: nothing to do

Legalizing: t5: i64 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end32 0x7748608>, Constant:i8<6>, t22:1
Legal node: nothing to do

Legalizing: t23: i8 = Constant<6>
Legal node: nothing to do

Legalizing: t22: i32,i32 = X86ISD::SUB t4, t6
Legal node: nothing to do
Legalized selection DAG: %bb.2 'quick_sort:while.cond'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t22: i32,i32 = X86ISD::SUB t4, t6
    t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end32 0x7748608>, Constant:i8<6>, t22:1
  t14: ch = br t25, BasicBlock:ch<while.body 0x773fc10>



Legalizing: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end32 0x7748608>, Constant:i8<6>, t22:1
Legal node: nothing to do

Combining: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end32 0x7748608>, Constant:i8<6>, t22:1

Legalizing: t23: i8 = Constant<6>
Legal node: nothing to do

Combining: t23: i8 = Constant<6>

Legalizing: t22: i32,i32 = X86ISD::SUB t4, t6
Legal node: nothing to do

Combining: t22: i32,i32 = X86ISD::SUB t4, t6

Legalizing: t14: ch = br t25, BasicBlock:ch<while.body 0x773fc10>
Legal node: nothing to do

Combining: t14: ch = br t25, BasicBlock:ch<while.body 0x773fc10>

Legalizing: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Legalizing: t13: ch = BasicBlock<while.body 0x773fc10>
Legal node: nothing to do

Combining: t13: ch = BasicBlock<while.body 0x773fc10>

Legalizing: t11: ch = BasicBlock<while.end32 0x7748608>
Legal node: nothing to do

Combining: t11: ch = BasicBlock<while.end32 0x7748608>

Legalizing: t5: i64 = FrameIndex<3>
Legal node: nothing to do

Combining: t5: i64 = FrameIndex<3>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<2>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.2 'quick_sort:while.cond'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t22: i32,i32 = X86ISD::SUB t4, t6
    t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end32 0x7748608>, Constant:i8<6>, t22:1
  t14: ch = br t25, BasicBlock:ch<while.body 0x773fc10>


===== Instruction selection begins: %bb.2 'while.cond'

ISEL: Starting selection on root node: t14: ch = br t25, BasicBlock:ch<while.body 0x773fc10>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t14: ch = JMP_1 BasicBlock:ch<while.body 0x773fc10>, t25
ISEL: Match complete!

ISEL: Starting selection on root node: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end32 0x7748608>, Constant:i8<6>, t22:1
ISEL: Starting pattern match
  Initial Opcode index to 150935
  Skipped scope entry (due to false predicate) at index 150944, continuing at 150957
  Skipped scope entry (due to false predicate) at index 150958, continuing at 150971
  Skipped scope entry (due to false predicate) at index 150972, continuing at 150985
  Skipped scope entry (due to false predicate) at index 150986, continuing at 150999
  Skipped scope entry (due to false predicate) at index 151000, continuing at 151013
  Skipped scope entry (due to false predicate) at index 151014, continuing at 151027
  Skipped scope entry (due to false predicate) at index 151028, continuing at 151041
  Skipped scope entry (due to false predicate) at index 151042, continuing at 151055
  Skipped scope entry (due to false predicate) at index 151056, continuing at 151069
  Skipped scope entry (due to false predicate) at index 151070, continuing at 151083
  Skipped scope entry (due to false predicate) at index 151084, continuing at 151097
  Skipped scope entry (due to false predicate) at index 151098, continuing at 151111
  Skipped scope entry (due to false predicate) at index 151112, continuing at 151125
Creating new node: t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1
  Morphed node: t25: ch = JGE_1 BasicBlock:ch<while.end32 0x7748608>, t27, t27:1
ISEL: Match complete!

ISEL: Starting selection on root node: t22: i32,i32 = X86ISD::SUB t4, t6
ISEL: Starting pattern match
  Initial Opcode index to 119640
  Match failed at index 119649
  Continuing at 119747
  Match failed at index 119748
  Continuing at 119793
  Skipped scope entry (due to false predicate) at index 119803, continuing at 119884
  Match failed at index 119888
  Continuing at 119902
  Match failed at index 119906
  Continuing at 119920
  Match failed at index 119926
  Continuing at 119938
  Match failed at index 119939
  Continuing at 119958
  Match failed at index 119959
  Continuing at 119978
  Continuing at 119979
  Match failed at index 119980
  Continuing at 119991
  Match failed at index 119992
  Continuing at 120003
  Morphed node: t22: i32,i32 = SUB32rr t4, t6
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t30: i8 = TargetConstant<1>
Creating constant: t31: i32 = TargetConstant<0>
  Morphed node: t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = BasicBlock<while.body 0x773fc10>

ISEL: Starting selection on root node: t11: ch = BasicBlock<while.end32 0x7748608>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.2 'quick_sort:while.cond'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
      t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
      t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
    t22: i32,i32 = SUB32rr t4, t6
  t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1
    t25: ch = JGE_1 BasicBlock:ch<while.end32 0x7748608>, t27, t27:1
  t14: ch = JMP_1 BasicBlock:ch<while.body 0x773fc10>, t25


********** List Scheduling %bb.2 'while.cond' **********
SU(0): t14: ch = JMP_1 BasicBlock:ch<while.body 0x773fc10>, t25

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t25: ch = JGE_1 BasicBlock:ch<while.end32 0x7748608>, t27, t27:1

    t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t22: i32,i32 = SUB32rr t4, t6

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1
SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMP_1 BasicBlock:ch<while.body 0x773fc10>, t25


*** Scheduling [0]: SU(0): t14: ch = JMP_1 BasicBlock:ch<while.body 0x773fc10>, t25


Examining Available:
Height 1: SU(1): t25: ch = JGE_1 BasicBlock:ch<while.end32 0x7748608>, t27, t27:1

    t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1


*** Scheduling [1]: SU(1): t25: ch = JGE_1 BasicBlock:ch<while.end32 0x7748608>, t27, t27:1

    t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1


Examining Available:
Height 2: SU(2): t22: i32,i32 = SUB32rr t4, t6


*** Scheduling [2]: SU(2): t22: i32,i32 = SUB32rr t4, t6


Examining Available:
Height 3: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [3]: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


Examining Available:
Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [4]: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(2): t22: i32,i32 = SUB32rr t4, t6

SU(1): t25: ch = JGE_1 BasicBlock:ch<while.end32 0x7748608>, t27, t27:1

    t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1

SU(0): t14: ch = JMP_1 BasicBlock:ch<while.body 0x773fc10>, t25


Total amount of phi nodes to update: 0
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Creating new node: t6: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Creating new node: t7: i64 = sign_extend t6
Creating constant: t9: i64 = Constant<2>
Creating new node: t10: i64 = shl t7, Constant:i64<2>
Creating new node: t11: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t10
Creating new node: t12: ch = TokenFactor t4:1, t6:1
Creating new node: t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t11, undef:i64
Creating new node: t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64
Creating new node: t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
Creating constant: t17: i32 = Constant<1>
Creating new node: t18: i32 = sub nsw t16, Constant:i32<1>
Creating new node: t20: ch = TokenFactor t15:1, t16:1
Creating constant: t21: i64 = TargetConstant<0>
Creating new node: t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15
Creating new node: t26: ch,glue = CopyToReg t24, Register:i32 $esi, t18, t24:1
Creating new node: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1
Creating new node: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
Creating new node: t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
Creating new node: t32: i32 = add nsw t31, Constant:i32<1>
Creating new node: t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64
Creating new node: t35: ch = TokenFactor t31:1, t34:1
Creating new node: t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>
Creating new node: t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32
Creating new node: t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1
Creating new node: t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1
Creating new node: t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1
Creating new node: t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>
Initial selection DAG: %bb.18 'quick_sort:while.end32'
SelectionDAG has 43 nodes:
  t0: ch = EntryToken
  t2: i64 = Constant<0>
  t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
  t6: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
    t12: ch = TokenFactor t4:1, t6:1
        t7: i64 = sign_extend t6
      t10: i64 = shl t7, Constant:i64<2>
    t11: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t10
  t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t11, undef:i64
  t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64
  t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
  t19: i64 = GlobalAddress<void (i32, i32)* @quick_sort> 0
      t20: ch = TokenFactor t15:1, t16:1
    t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>
  t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15
    t18: i32 = sub nsw t16, Constant:i32<1>
  t26: ch,glue = CopyToReg t24, Register:i32 $esi, t18, t24:1
  t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1
  t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
  t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
  t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64
      t35: ch = TokenFactor t31:1, t34:1
    t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>
    t32: i32 = add nsw t31, Constant:i32<1>
  t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32
  t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1
  t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1
    t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1
  t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>



Combining: t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>

Combining: t41: ch = BasicBlock<if.end35 0x77486d0>

Combining: t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1

Combining: t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1

Combining: t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1

Combining: t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32

Combining: t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t35: ch = TokenFactor t31:1, t34:1

Combining: t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64

Combining: t33: i64 = FrameIndex<1>

Combining: t32: i32 = add nsw t31, Constant:i32<1>

Combining: t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64

Combining: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1

Combining: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1

Combining: t28: Untyped = RegisterMask

Combining: t27: i64 = TargetGlobalAddress<void (i32, i32)* @quick_sort> 0

Combining: t26: ch,glue = CopyToReg t24, Register:i32 $esi, t18, t24:1

Combining: t25: i32 = Register $esi

Combining: t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15

Combining: t23: i32 = Register $edi

Combining: t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t21: i64 = TargetConstant<0>

Combining: t20: ch = TokenFactor t15:1, t16:1

Combining: t18: i32 = sub nsw t16, Constant:i32<1>
Creating constant: t43: i32 = Constant<-1>
Creating new node: t44: i32 = add t16, Constant:i32<-1>
 ... into: t44: i32 = add t16, Constant:i32<-1>

Combining: t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1

Combining: t44: i32 = add t16, Constant:i32<-1>

Combining: t43: i32 = Constant<-1>

Combining: t17: i32 = Constant<1>

Combining: t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64

Combining: t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64

Combining: t14: i64 = FrameIndex<0>

Combining: t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t11, undef:i64

Combining: t12: ch = TokenFactor t4:1, t6:1

Combining: t11: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t10
Creating new node: t45: i64 = add t10, GlobalAddress:i64<[100 x i32]* @s> 0
 ... into: t45: i64 = add t10, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64

Combining: t45: i64 = add t10, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t10: i64 = shl t7, Constant:i64<2>

Combining: t9: i64 = Constant<2>

Combining: t8: i64 = GlobalAddress<[100 x i32]* @s> 0

Combining: t7: i64 = sign_extend t6
Creating new node: t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Replacing.1 t7: i64 = sign_extend t6

With: t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
 and 0 other values

Combining: t10: i64 = shl t46, Constant:i64<2>

Combining: t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Combining: t5: i64 = FrameIndex<2>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<4>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.18 'quick_sort:while.end32'
SelectionDAG has 41 nodes:
  t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
    t12: ch = TokenFactor t4:1, t46:1
      t10: i64 = shl t46, Constant:i64<2>
    t45: i64 = add t10, GlobalAddress:i64<[100 x i32]* @s> 0
  t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64
  t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64
  t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
      t20: ch = TokenFactor t15:1, t16:1
    t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>
  t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15
    t44: i32 = add t16, Constant:i32<-1>
  t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1
  t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1
  t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
  t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
  t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64
      t35: ch = TokenFactor t31:1, t34:1
    t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>
    t32: i32 = add nsw t31, Constant:i32<1>
  t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32
  t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1
  t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1
  t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
    t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1
  t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>


Legalizing node: t43: i32 = Constant<-1>
Analyzing result type: i32
Legal result type
Legally typed node: t43: i32 = Constant<-1>

Legalizing node: t41: ch = BasicBlock<if.end35 0x77486d0>
Analyzing result type: ch
Legal result type
Legally typed node: t41: ch = BasicBlock<if.end35 0x77486d0>

Legalizing node: t33: i64 = FrameIndex<1>
Analyzing result type: i64
Legal result type
Legally typed node: t33: i64 = FrameIndex<1>

Legalizing node: t28: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t28: Untyped = RegisterMask

Legalizing node: t27: i64 = TargetGlobalAddress<void (i32, i32)* @quick_sort> 0
Analyzing result type: i64
Legal result type
Legally typed node: t27: i64 = TargetGlobalAddress<void (i32, i32)* @quick_sort> 0

Legalizing node: t25: i32 = Register $esi
Ignoring node results
Legally typed node: t25: i32 = Register $esi

Legalizing node: t23: i32 = Register $edi
Ignoring node results
Legally typed node: t23: i32 = Register $edi

Legalizing node: t21: i64 = TargetConstant<0>
Ignoring node results
Legally typed node: t21: i64 = TargetConstant<0>

Legalizing node: t17: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t17: i32 = Constant<1>

Legalizing node: t14: i64 = FrameIndex<0>
Analyzing result type: i64
Legal result type
Legally typed node: t14: i64 = FrameIndex<0>

Legalizing node: t9: i64 = Constant<2>
Analyzing result type: i64
Legal result type
Legally typed node: t9: i64 = Constant<2>

Legalizing node: t8: i64 = GlobalAddress<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Legally typed node: t8: i64 = GlobalAddress<[100 x i32]* @s> 0

Legalizing node: t5: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t5: i64 = FrameIndex<2>

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<4>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<4>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<4>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64

Legalizing node: t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t5: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Legalizing node: t10: i64 = shl t46, Constant:i64<2>
Analyzing result type: i64
Legal result type
Analyzing operand: t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t9: i64 = Constant<2>
Legal operand
Legally typed node: t10: i64 = shl t46, Constant:i64<2>

Legalizing node: t45: i64 = add t10, GlobalAddress:i64<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Analyzing operand: t10: i64 = shl t46, Constant:i64<2>
Legal operand
Analyzing operand: t8: i64 = GlobalAddress<[100 x i32]* @s> 0
Legal operand
Legally typed node: t45: i64 = add t10, GlobalAddress:i64<[100 x i32]* @s> 0

Legalizing node: t12: ch = TokenFactor t4:1, t46:1
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Legal operand
Analyzing operand: t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Legally typed node: t12: ch = TokenFactor t4:1, t46:1

Legalizing node: t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = TokenFactor t4:1, t46:1
Legal operand
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Legal operand
Analyzing operand: t45: i64 = add t10, GlobalAddress:i64<[100 x i32]* @s> 0
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64

Legalizing node: t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64
Legal operand
Analyzing operand: t14: i64 = FrameIndex<0>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64

Legalizing node: t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64
Legal operand
Analyzing operand: t5: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64

Legalizing node: t20: ch = TokenFactor t15:1, t16:1
Analyzing result type: ch
Legal result type
Analyzing operand: t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64
Legal operand
Analyzing operand: t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
Legal operand
Legally typed node: t20: ch = TokenFactor t15:1, t16:1

Legalizing node: t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t20: ch = TokenFactor t15:1, t16:1
Legal operand
Legally typed node: t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64
Legal operand
Legally typed node: t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15

Legalizing node: t44: i32 = add t16, Constant:i32<-1>
Analyzing result type: i32
Legal result type
Analyzing operand: t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t43: i32 = Constant<-1>
Legal operand
Legally typed node: t44: i32 = add t16, Constant:i32<-1>

Legalizing node: t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15
Legal operand
Analyzing operand: t44: i32 = add t16, Constant:i32<-1>
Legal operand
Analyzing operand: t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15
Legal operand
Legally typed node: t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1

Legalizing node: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1
Legal operand
Analyzing operand: t27: i64 = TargetGlobalAddress<void (i32, i32)* @quick_sort> 0
Legal operand
Analyzing operand: t28: Untyped = RegisterMask
Legal operand
Analyzing operand: t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1
Legal operand
Legally typed node: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1

Legalizing node: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1
Legal operand
Analyzing operand: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1
Legal operand
Legally typed node: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1

Legalizing node: t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
Legal operand
Analyzing operand: t5: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64

Legalizing node: t32: i32 = add nsw t31, Constant:i32<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t17: i32 = Constant<1>
Legal operand
Legally typed node: t32: i32 = add nsw t31, Constant:i32<1>

Legalizing node: t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
Legal operand
Analyzing operand: t33: i64 = FrameIndex<1>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64

Legalizing node: t35: ch = TokenFactor t31:1, t34:1
Analyzing result type: ch
Legal result type
Analyzing operand: t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64
Legal operand
Legally typed node: t35: ch = TokenFactor t31:1, t34:1

Legalizing node: t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t35: ch = TokenFactor t31:1, t34:1
Legal operand
Legally typed node: t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing node: t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>
Legal operand
Analyzing operand: t32: i32 = add nsw t31, Constant:i32<1>
Legal operand
Legally typed node: t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32

Legalizing node: t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32
Legal operand
Analyzing operand: t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64
Legal operand
Analyzing operand: t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32
Legal operand
Legally typed node: t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1

Legalizing node: t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1
Legal operand
Analyzing operand: t27: i64 = TargetGlobalAddress<void (i32, i32)* @quick_sort> 0
Legal operand
Analyzing operand: t28: Untyped = RegisterMask
Legal operand
Analyzing operand: t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1
Legal operand
Legally typed node: t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1

Legalizing node: t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1
Legal operand
Analyzing operand: t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1
Legal operand
Legally typed node: t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1

Legalizing node: t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>
Analyzing result type: ch
Legal result type
Analyzing operand: t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1
Legal operand
Analyzing operand: t41: ch = BasicBlock<if.end35 0x77486d0>
Legal operand
Legally typed node: t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>

Legalizing node: t65535: ch = handlenode t42
Analyzing result type: ch
Legal result type
Analyzing operand: t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>
Legal operand
Legally typed node: t65535: ch = handlenode t42

Type-legalized selection DAG: %bb.18 'quick_sort:while.end32'
SelectionDAG has 41 nodes:
  t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
    t12: ch = TokenFactor t4:1, t46:1
      t10: i64 = shl t46, Constant:i64<2>
    t45: i64 = add t10, GlobalAddress:i64<[100 x i32]* @s> 0
  t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64
  t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64
  t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
      t20: ch = TokenFactor t15:1, t16:1
    t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>
  t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15
    t44: i32 = add t16, Constant:i32<-1>
  t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1
  t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1
  t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
  t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
  t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64
      t35: ch = TokenFactor t31:1, t34:1
    t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>
    t32: i32 = add nsw t31, Constant:i32<1>
  t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32
  t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1
  t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1
  t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
    t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1
  t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>



Legalizing: t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>
Legal node: nothing to do

Legalizing: t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1

Legalizing: t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1
Legal node: nothing to do

Legalizing: t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1
Legal node: nothing to do

Legalizing: t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32
Legal node: nothing to do

Legalizing: t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t32: i32 = add nsw t31, Constant:i32<1>
Legal node: nothing to do

Legalizing: t35: ch = TokenFactor t31:1, t34:1
Legal node: nothing to do

Legalizing: t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Legalizing: t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64
Legalizing non-extending load operation

Legalizing: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1

Legalizing: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1
Legal node: nothing to do

Legalizing: t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1
Legal node: nothing to do

Legalizing: t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15
Legal node: nothing to do

Legalizing: t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t20: ch = TokenFactor t15:1, t16:1
Legal node: nothing to do

Legalizing: t44: i32 = add t16, Constant:i32<-1>
Legal node: nothing to do

Legalizing: t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64
Legalizing non-extending load operation

Legalizing: t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Legalizing: t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t45: i64 = add t10, GlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t10: i64 = shl t46, Constant:i64<2>
Creating constant: t47: i8 = Constant<2>
Legal node: nothing to do

Legalizing: t12: ch = TokenFactor t4:1, t46:1
Legal node: nothing to do

Legalizing: t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legalizing extending load operation

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Legalizing non-extending load operation

Legalizing: t43: i32 = Constant<-1>
Legal node: nothing to do

Legalizing: t41: ch = BasicBlock<if.end35 0x77486d0>
Legal node: nothing to do

Legalizing: t33: i64 = FrameIndex<1>
Legal node: nothing to do

Legalizing: t28: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t27: i64 = TargetGlobalAddress<void (i32, i32)* @quick_sort> 0
Legal node: nothing to do

Legalizing: t25: i32 = Register $esi

Legalizing: t23: i32 = Register $edi

Legalizing: t21: i64 = TargetConstant<0>

Legalizing: t17: i32 = Constant<1>
Legal node: nothing to do

Legalizing: t14: i64 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t8: i64 = GlobalAddress<[100 x i32]* @s> 0
Trying custom legalization
Creating new node: t49: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Successfully custom legalized node
 ... replacing: t8: i64 = GlobalAddress<[100 x i32]* @s> 0
     with:      t49: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0

Legalizing: t5: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t49: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t48: i64 = TargetGlobalAddress<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t47: i8 = Constant<2>
Legal node: nothing to do
Legalized selection DAG: %bb.18 'quick_sort:while.end32'
SelectionDAG has 42 nodes:
  t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
  t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
    t12: ch = TokenFactor t4:1, t46:1
      t10: i64 = shl t46, Constant:i8<2>
      t49: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
    t45: i64 = add t10, t49
  t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64
  t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
  t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64
      t20: ch = TokenFactor t15:1, t16:1
    t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>
  t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15
    t44: i32 = add t16, Constant:i32<-1>
  t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1
  t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1
  t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
  t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64
  t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
      t35: ch = TokenFactor t31:1, t34:1
    t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>
    t32: i32 = add nsw t31, Constant:i32<1>
  t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32
  t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1
  t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1
    t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1
  t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>



Legalizing: t49: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Combining: t49: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0

Legalizing: t48: i64 = TargetGlobalAddress<[100 x i32]* @s> 0
Legal node: nothing to do

Combining: t48: i64 = TargetGlobalAddress<[100 x i32]* @s> 0

Legalizing: t47: i8 = Constant<2>
Legal node: nothing to do

Combining: t47: i8 = Constant<2>

Legalizing: t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>
Legal node: nothing to do

Combining: t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>

Legalizing: t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1

Combining: t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1

Legalizing: t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1
Legal node: nothing to do

Combining: t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1

Legalizing: t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1
Legal node: nothing to do

Combining: t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1

Legalizing: t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32
Legal node: nothing to do

Combining: t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32

Legalizing: t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t32: i32 = add nsw t31, Constant:i32<1>
Legal node: nothing to do

Combining: t32: i32 = add nsw t31, Constant:i32<1>

Legalizing: t35: ch = TokenFactor t31:1, t34:1
Legal node: nothing to do

Combining: t35: ch = TokenFactor t31:1, t34:1

Legalizing: t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Combining: t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64

Legalizing: t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64
Legalizing non-extending load operation

Combining: t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64

Legalizing: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1

Combining: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1

Legalizing: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1
Legal node: nothing to do

Combining: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1

Legalizing: t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1
Legal node: nothing to do

Combining: t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1

Legalizing: t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15
Legal node: nothing to do

Combining: t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15

Legalizing: t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>

Combining: t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>

Legalizing: t20: ch = TokenFactor t15:1, t16:1
Legal node: nothing to do

Combining: t20: ch = TokenFactor t15:1, t16:1

Legalizing: t44: i32 = add t16, Constant:i32<-1>
Legal node: nothing to do

Combining: t44: i32 = add t16, Constant:i32<-1>

Legalizing: t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64
Legalizing non-extending load operation

Combining: t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64

Legalizing: t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Combining: t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64

Legalizing: t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64

Legalizing: t45: i64 = add t10, t49
Legal node: nothing to do

Combining: t45: i64 = add t10, t49

Legalizing: t10: i64 = shl t46, Constant:i8<2>
Legal node: nothing to do

Combining: t10: i64 = shl t46, Constant:i8<2>

Legalizing: t12: ch = TokenFactor t4:1, t46:1
Legal node: nothing to do

Combining: t12: ch = TokenFactor t4:1, t46:1

Legalizing: t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legalizing extending load operation

Combining: t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64

Legalizing: t43: i32 = Constant<-1>
Legal node: nothing to do

Combining: t43: i32 = Constant<-1>

Legalizing: t41: ch = BasicBlock<if.end35 0x77486d0>
Legal node: nothing to do

Combining: t41: ch = BasicBlock<if.end35 0x77486d0>

Legalizing: t33: i64 = FrameIndex<1>
Legal node: nothing to do

Combining: t33: i64 = FrameIndex<1>

Legalizing: t28: Untyped = RegisterMask
Legal node: nothing to do

Combining: t28: Untyped = RegisterMask

Legalizing: t27: i64 = TargetGlobalAddress<void (i32, i32)* @quick_sort> 0
Legal node: nothing to do

Combining: t27: i64 = TargetGlobalAddress<void (i32, i32)* @quick_sort> 0

Legalizing: t25: i32 = Register $esi

Combining: t25: i32 = Register $esi

Legalizing: t23: i32 = Register $edi

Combining: t23: i32 = Register $edi

Legalizing: t21: i64 = TargetConstant<0>

Combining: t21: i64 = TargetConstant<0>

Legalizing: t17: i32 = Constant<1>
Legal node: nothing to do

Combining: t17: i32 = Constant<1>

Legalizing: t14: i64 = FrameIndex<0>
Legal node: nothing to do

Combining: t14: i64 = FrameIndex<0>

Legalizing: t5: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t5: i64 = FrameIndex<2>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<4>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<4>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.18 'quick_sort:while.end32'
SelectionDAG has 42 nodes:
  t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
  t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
    t12: ch = TokenFactor t4:1, t46:1
      t10: i64 = shl t46, Constant:i8<2>
      t49: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
    t45: i64 = add t10, t49
  t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64
  t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
  t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64
      t20: ch = TokenFactor t15:1, t16:1
    t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>
  t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15
    t44: i32 = add t16, Constant:i32<-1>
  t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1
  t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1
  t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
  t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64
  t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
      t35: ch = TokenFactor t31:1, t34:1
    t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>
    t32: i32 = add nsw t31, Constant:i32<1>
  t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32
  t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1
  t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1
    t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1
  t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>


===== Instruction selection begins: %bb.18 'while.end32'

ISEL: Starting selection on root node: t42: ch = br t40, BasicBlock:ch<if.end35 0x77486d0>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t42: ch = JMP_1 BasicBlock:ch<if.end35 0x77486d0>, t40
ISEL: Match complete!

ISEL: Starting selection on root node: t40: ch,glue = callseq_end t39, TargetConstant:i64<0>, TargetConstant:i64<0>, t39:1
ISEL: Starting pattern match
  Initial Opcode index to 150137
  Skipped scope entry (due to false predicate) at index 150153, continuing at 150164
  Morphed node: t40: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t39, t39:1
ISEL: Match complete!

ISEL: Starting selection on root node: t39: ch,glue = X86ISD::CALL t38, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38:1
ISEL: Starting pattern match
  Initial Opcode index to 120659
  Match failed at index 120664
  Continuing at 120747
  OpcodeSwitch from 120753 to 120757
  TypeSwitch[i64] from 120757 to 120760
  Morphed node: t39: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38, t38:1
ISEL: Match complete!

ISEL: Starting selection on root node: t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1

ISEL: Starting selection on root node: t37: ch,glue = CopyToReg t36, Register:i32 $edi, t32

ISEL: Starting selection on root node: t36: ch,glue = callseq_start t35, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 150180
  Skipped scope entry (due to false predicate) at index 150195, continuing at 150210
Creating constant: t50: i32 = TargetConstant<0>
  Morphed node: t36: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t35
ISEL: Match complete!

ISEL: Starting selection on root node: t32: i32 = add nsw t31, Constant:i32<1>
ISEL: Starting pattern match
  Initial Opcode index to 17918
  Skipped scope entry (due to false predicate) at index 17924, continuing at 17944
  Match failed at index 17946
  Continuing at 18049
  Continuing at 18050
  OpcodeSwitch from 18053 to 18057
  Match failed at index 18059
  Continuing at 18230
  Match failed at index 18233
  Continuing at 18300
  TypeSwitch[i32] from 18302 to 18305
  Skipped scope entry (due to false predicate) at index 18307, continuing at 18323
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Match failed at index 18326
  Continuing at 18340
  Continuing at 18358
  Match failed at index 18361
  Continuing at 18382
  Match failed at index 18384
  Continuing at 18406
  TypeSwitch[i32] from 18413 to 18440
  Match failed at index 18440
  Continuing at 18463
  Match failed at index 18464
  Continuing at 18525
  Match failed at index 18526
  Continuing at 18600
  Match failed at index 18601
  Continuing at 18630
  Match failed at index 18644
  Continuing at 18657
Creating constant: t52: i32 = TargetConstant<1>
  Morphed node: t32: i32,i32 = ADD32ri8 nsw t31, TargetConstant:i32<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t35: ch = TokenFactor t31:1, t34:1

ISEL: Starting selection on root node: t31: i32,ch = load<(dereferenceable load 4 from %ir.i)> t30, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t55: i8 = TargetConstant<1>
  Morphed node: t31: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t34: i32,ch = load<(dereferenceable load 4 from %ir.r.addr)> t30, FrameIndex:i64<1>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t34: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t30
ISEL: Match complete!

ISEL: Starting selection on root node: t30: ch,glue = callseq_end t29, TargetConstant:i64<0>, TargetConstant:i64<0>, t29:1
ISEL: Starting pattern match
  Initial Opcode index to 150137
  Skipped scope entry (due to false predicate) at index 150153, continuing at 150164
  Morphed node: t30: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t29, t29:1
ISEL: Match complete!

ISEL: Starting selection on root node: t29: ch,glue = X86ISD::CALL t26, TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26:1
ISEL: Starting pattern match
  Initial Opcode index to 120659
  Match failed at index 120664
  Continuing at 120747
  OpcodeSwitch from 120753 to 120757
  TypeSwitch[i64] from 120757 to 120760
  Morphed node: t29: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26, t26:1
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1

ISEL: Starting selection on root node: t24: ch,glue = CopyToReg t22, Register:i32 $edi, t15

ISEL: Starting selection on root node: t22: ch,glue = callseq_start t20, TargetConstant:i64<0>, TargetConstant:i64<0>
ISEL: Starting pattern match
  Initial Opcode index to 150180
  Skipped scope entry (due to false predicate) at index 150195, continuing at 150210
  Morphed node: t22: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: ch = TokenFactor t15:1, t16:1

ISEL: Starting selection on root node: t44: i32 = add t16, Constant:i32<-1>
ISEL: Starting pattern match
  Initial Opcode index to 17918
  Skipped scope entry (due to false predicate) at index 17924, continuing at 17944
  Match failed at index 17946
  Continuing at 18049
  Continuing at 18050
  OpcodeSwitch from 18053 to 18057
  Match failed at index 18059
  Continuing at 18230
  Match failed at index 18233
  Continuing at 18300
  TypeSwitch[i32] from 18302 to 18305
  Skipped scope entry (due to false predicate) at index 18307, continuing at 18323
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Match failed at index 18326
  Continuing at 18340
  Continuing at 18358
  Match failed at index 18361
  Continuing at 18382
  Match failed at index 18384
  Continuing at 18406
  Skipped scope entry (due to false predicate) at index 18411, continuing at 18463
  TypeSwitch[i32] from 18475 to 18502
  Match failed at index 18502
  Continuing at 18525
  Match failed at index 18526
  Continuing at 18600
  Match failed at index 18601
  Continuing at 18630
  Match failed at index 18644
  Continuing at 18657
Creating constant: t57: i32 = TargetConstant<-1>
  Morphed node: t44: i32,i32 = ADD32ri8 t16, TargetConstant:i32<-1>
ISEL: Match complete!

ISEL: Starting selection on root node: t15: i32,ch = load<(dereferenceable load 4 from %ir.l.addr)> t13, FrameIndex:i64<0>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t15: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t16: i32,ch = load<(dereferenceable load 4 from %ir.i)> t13, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t16: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = store<(store 4 into %ir.arrayidx34)> t12, t4, t45, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  Match failed at index 1029
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 4
IndexReg t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t59: i8 = TargetConstant<4>
  Morphed node: t13: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx34)> Register:i64 $noreg, TargetConstant:i8<4>, t46, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t4, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = TokenFactor t4:1, t46:1

ISEL: Starting selection on root node: t46: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Skipped scope entry (due to false predicate) at index 137189, continuing at 137208
  Skipped scope entry (due to false predicate) at index 137209, continuing at 137228
  Skipped scope entry (due to false predicate) at index 137229, continuing at 137248
  Skipped scope entry (due to false predicate) at index 137249, continuing at 137268
  Match failed at index 137271
  Continuing at 137311
  Match failed at index 137312
  Continuing at 137354
  Skipped scope entry (due to false predicate) at index 137361, continuing at 137378
  Skipped scope entry (due to false predicate) at index 137379, continuing at 137396
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t46: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t41: ch = BasicBlock<if.end35 0x77486d0>

ISEL: Starting selection on root node: t28: Untyped = RegisterMask

ISEL: Starting selection on root node: t27: i64 = TargetGlobalAddress<void (i32, i32)* @quick_sort> 0

ISEL: Starting selection on root node: t25: i32 = Register $esi

ISEL: Starting selection on root node: t23: i32 = Register $edi

ISEL: Starting selection on root node: t21: i64 = TargetConstant<0>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.18 'quick_sort:while.end32'
SelectionDAG has 42 nodes:
  t0: ch = EntryToken
  t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
  t46: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
    t12: ch = TokenFactor t4:1, t46:1
  t13: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx34)> Register:i64 $noreg, TargetConstant:i8<4>, t46, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t4, t12
  t16: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13
  t15: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13
      t20: ch = TokenFactor t15:1, t16:1
    t22: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t20
  t24: ch,glue = CopyToReg t22:1, Register:i32 $edi, t15
    t44: i32,i32 = ADD32ri8 t16, TargetConstant:i32<-1>
  t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1
  t29: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26, t26:1
  t30: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t29, t29:1
  t34: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t30:1
  t31: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t30:1
      t35: ch = TokenFactor t31:1, t34:1
    t36: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t35
    t32: i32,i32 = ADD32ri8 nsw t31, TargetConstant:i32<1>
  t37: ch,glue = CopyToReg t36:1, Register:i32 $edi, t32
  t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1
  t39: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38, t38:1
    t40: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t39, t39:1
  t42: ch = JMP_1 BasicBlock:ch<if.end35 0x77486d0>, t40:1


********** List Scheduling %bb.18 'while.end32' **********
SU(0): t42: ch = JMP_1 BasicBlock:ch<if.end35 0x77486d0>, t40:1

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 8
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t40: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t39, t39:1

    t37: ch,glue = CopyToReg t36:1, Register:i32 $edi, t32

    t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1

    t39: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38, t38:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
    SU(15): Ord  Latency=1 Barrier
    SU(13): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t34: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t30:1

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 3
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(1): Data Latency=1
    SU(16): Ord  Latency=1 Barrier
SU(3): t30: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t29, t29:1

    t24: ch,glue = CopyToReg t22:1, Register:i32 $edi, t15

    t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1

    t29: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26, t26:1

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 4
  Predecessors:
    SU(4): Data Latency=1
    SU(11): Ord  Latency=1 Barrier
    SU(10): Data Latency=1
  Successors:
    SU(2): Ord  Latency=1 Barrier
    SU(14): Ord  Latency=1 Barrier
SU(4): t44: i32,i32 = ADD32ri8 t16, TargetConstant:i32<-1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 5
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(5): t16: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 6
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1
    SU(12): Ord  Latency=1 Barrier
SU(6): t13: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx34)> Register:i64 $noreg, TargetConstant:i8<4>, t46, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t4, t12

  # preds left       : 3
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 7
  Predecessors:
    SU(9): Data Latency=1
    SU(8): Data Latency=1
    SU(7): Ord  Latency=0 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
    SU(10): Ord  Latency=1 Barrier
SU(7): t12: ch = TokenFactor t4:1, t46:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 7
  Predecessors:
    SU(8): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
  Successors:
    SU(6): Ord  Latency=0 Barrier
SU(8): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 8
  Successors:
    SU(6): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
SU(9): t46: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 8
  Successors:
    SU(6): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
SU(10): t15: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 6
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(3): Data Latency=1
    SU(12): Ord  Latency=1 Barrier
SU(11): t22: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t20

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 5
  Predecessors:
    SU(12): Ord  Latency=0 Barrier
  Successors:
    SU(3): Ord  Latency=1 Barrier
SU(12): t20: ch = TokenFactor t15:1, t16:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 5
  Predecessors:
    SU(10): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(11): Ord  Latency=0 Barrier
SU(13): t32: i32,i32 = ADD32ri8 nsw t31, TargetConstant:i32<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 2
  Predecessors:
    SU(14): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(14): t31: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t30:1

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 3
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
  Successors:
    SU(13): Data Latency=1
    SU(16): Ord  Latency=1 Barrier
SU(15): t36: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t35

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 2
  Predecessors:
    SU(16): Ord  Latency=0 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(16): t35: ch = TokenFactor t31:1, t34:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 6
  Height             : 2
  Predecessors:
    SU(14): Ord  Latency=1 Barrier
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(15): Ord  Latency=0 Barrier

Examining Available:
Height 0: SU(0): t42: ch = JMP_1 BasicBlock:ch<if.end35 0x77486d0>, t40:1


*** Scheduling [0]: SU(0): t42: ch = JMP_1 BasicBlock:ch<if.end35 0x77486d0>, t40:1


Examining Available:
Height 1: SU(1): t40: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t39, t39:1

    t37: ch,glue = CopyToReg t36:1, Register:i32 $edi, t32

    t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1

    t39: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38, t38:1


*** Scheduling [1]: SU(1): t40: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t39, t39:1

    t37: ch,glue = CopyToReg t36:1, Register:i32 $edi, t32

    t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1

    t39: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38, t38:1


Examining Available:
Height 2: SU(15): t36: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t35

Height 2: SU(13): t32: i32,i32 = ADD32ri8 nsw t31, TargetConstant:i32<1>


*** Scheduling [2]: SU(15): t36: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t35


Examining Available:
Height 2: SU(16): t35: ch = TokenFactor t31:1, t34:1

Height 2: SU(13): t32: i32,i32 = ADD32ri8 nsw t31, TargetConstant:i32<1>


*** Scheduling [3]: SU(16): t35: ch = TokenFactor t31:1, t34:1


Examining Available:
Height 4: SU(2): t34: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t30:1

Height 2: SU(13): t32: i32,i32 = ADD32ri8 nsw t31, TargetConstant:i32<1>


*** Scheduling [4]: SU(2): t34: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t30:1


Examining Available:
Height 2: SU(13): t32: i32,i32 = ADD32ri8 nsw t31, TargetConstant:i32<1>


*** Scheduling [5]: SU(13): t32: i32,i32 = ADD32ri8 nsw t31, TargetConstant:i32<1>


Examining Available:
Height 6: SU(14): t31: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t30:1


*** Scheduling [6]: SU(14): t31: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t30:1


Examining Available:
Height 7: SU(3): t30: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t29, t29:1

    t24: ch,glue = CopyToReg t22:1, Register:i32 $edi, t15

    t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1

    t29: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26, t26:1


*** Scheduling [7]: SU(3): t30: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t29, t29:1

    t24: ch,glue = CopyToReg t22:1, Register:i32 $edi, t15

    t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1

    t29: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26, t26:1


Examining Available:
Height 8: SU(11): t22: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t20

Height 8: SU(4): t44: i32,i32 = ADD32ri8 t16, TargetConstant:i32<-1>


*** Scheduling [8]: SU(11): t22: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t20


Examining Available:
Height 8: SU(12): t20: ch = TokenFactor t15:1, t16:1

Height 8: SU(4): t44: i32,i32 = ADD32ri8 t16, TargetConstant:i32<-1>


*** Scheduling [9]: SU(12): t20: ch = TokenFactor t15:1, t16:1


Examining Available:
Height 8: SU(4): t44: i32,i32 = ADD32ri8 t16, TargetConstant:i32<-1>

Height 10: SU(10): t15: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13


*** Scheduling [10]: SU(4): t44: i32,i32 = ADD32ri8 t16, TargetConstant:i32<-1>


Examining Available:
Height 11: SU(5): t16: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13

Height 10: SU(10): t15: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13


*** Scheduling [11]: SU(5): t16: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13


Examining Available:
Height 10: SU(10): t15: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13


*** Scheduling [12]: SU(10): t15: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13


Examining Available:
Height 13: SU(6): t13: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx34)> Register:i64 $noreg, TargetConstant:i8<4>, t46, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t4, t12


*** Scheduling [13]: SU(6): t13: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx34)> Register:i64 $noreg, TargetConstant:i8<4>, t46, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t4, t12


Examining Available:
Height 13: SU(7): t12: ch = TokenFactor t4:1, t46:1


*** Scheduling [14]: SU(7): t12: ch = TokenFactor t4:1, t46:1


Examining Available:
Height 15: SU(9): t46: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 15: SU(8): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [15]: SU(9): t46: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


Examining Available:
Height 15: SU(8): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [16]: SU(8): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(8): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(9): t46: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(7): t12: ch = TokenFactor t4:1, t46:1

SU(6): t13: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx34)> Register:i64 $noreg, TargetConstant:i8<4>, t46, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t4, t12

SU(10): t15: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.l.addr)> TargetFrameIndex:i64<0>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13

SU(5): t16: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t13

SU(4): t44: i32,i32 = ADD32ri8 t16, TargetConstant:i32<-1>

SU(12): t20: ch = TokenFactor t15:1, t16:1

SU(11): t22: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t20

SU(3): t30: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t29, t29:1

    t24: ch,glue = CopyToReg t22:1, Register:i32 $edi, t15

    t26: ch,glue = CopyToReg t24, Register:i32 $esi, t44, t24:1

    t29: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t26, t26:1

SU(14): t31: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t30:1

SU(13): t32: i32,i32 = ADD32ri8 nsw t31, TargetConstant:i32<1>

SU(2): t34: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.r.addr)> TargetFrameIndex:i64<1>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t30:1

SU(16): t35: ch = TokenFactor t31:1, t34:1

SU(15): t36: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64<0>, TargetConstant:i64<0>, TargetConstant:i32<0>, t35

SU(1): t40: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64<0>, TargetConstant:i64<0>, t39, t39:1

    t37: ch,glue = CopyToReg t36:1, Register:i32 $edi, t32

    t38: ch,glue = CopyToReg t37, Register:i32 $esi, t34, t37:1

    t39: ch,glue = CALL64pcrel32 TargetGlobalAddress:i64<void (i32, i32)* @quick_sort> 0, Register:i32 $edi, Register:i32 $esi, RegisterMask:Untyped, t38, t38:1

SU(0): t42: ch = JMP_1 BasicBlock:ch<if.end35 0x77486d0>, t40:1


Total amount of phi nodes to update: 0
Creating constant: t1: i32 = TargetConstant<0>
Creating new node: t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>
Initial selection DAG: %bb.19 'quick_sort:if.end35'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>



Combining: t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>

Combining: t1: i32 = TargetConstant<0>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.19 'quick_sort:if.end35'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>


Legalizing node: t1: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t1: i32 = TargetConstant<0>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.19 'quick_sort:if.end35'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>



Legalizing: t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>
Legal node: nothing to do

Legalizing: t1: i32 = TargetConstant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.19 'quick_sort:if.end35'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>



Legalizing: t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>
Legal node: nothing to do

Combining: t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>

Legalizing: t1: i32 = TargetConstant<0>

Combining: t1: i32 = TargetConstant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.19 'quick_sort:if.end35'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>


===== Instruction selection begins: %bb.19 'if.end35'

ISEL: Starting selection on root node: t2: ch = X86ISD::RET_FLAG t0, TargetConstant:i32<0>
ISEL: Starting pattern match
  Initial Opcode index to 151416
  Morphed node: t2: ch = RET TargetConstant:i32<0>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.19 'quick_sort:if.end35'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = RET TargetConstant:i32<0>, t0


********** List Scheduling %bb.19 'if.end35' **********
SU(0): t2: ch = RET TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = RET TargetConstant:i32<0>, t0


*** Scheduling [0]: SU(0): t2: ch = RET TargetConstant:i32<0>, t0

*** Final schedule ***
SU(0): t2: ch = RET TargetConstant:i32<0>, t0


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>
Initial selection DAG: %bb.3 'quick_sort:while.body'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>



Combining: t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>

Combining: t1: ch = BasicBlock<while.cond2 0x773fcd8>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.3 'quick_sort:while.body'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>


Legalizing node: t1: ch = BasicBlock<while.cond2 0x773fcd8>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock<while.cond2 0x773fcd8>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock<while.cond2 0x773fcd8>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.3 'quick_sort:while.body'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>



Legalizing: t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock<while.cond2 0x773fcd8>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.3 'quick_sort:while.body'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>



Legalizing: t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>

Legalizing: t1: ch = BasicBlock<while.cond2 0x773fcd8>
Legal node: nothing to do

Combining: t1: ch = BasicBlock<while.cond2 0x773fcd8>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.3 'quick_sort:while.body'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>


===== Instruction selection begins: %bb.3 'while.body'

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch<while.cond2 0x773fcd8>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t2: ch = JMP_1 BasicBlock:ch<while.cond2 0x773fcd8>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock<while.cond2 0x773fcd8>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.3 'quick_sort:while.body'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = JMP_1 BasicBlock:ch<while.cond2 0x773fcd8>, t0


********** List Scheduling %bb.3 'while.body' **********
SU(0): t2: ch = JMP_1 BasicBlock:ch<while.cond2 0x773fcd8>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMP_1 BasicBlock:ch<while.cond2 0x773fcd8>, t0


*** Scheduling [0]: SU(0): t2: ch = JMP_1 BasicBlock:ch<while.cond2 0x773fcd8>, t0

*** Final schedule ***
SU(0): t2: ch = JMP_1 BasicBlock:ch<while.cond2 0x773fcd8>, t0


Total amount of phi nodes to update: 0
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Creating new node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Creating new node: t8: i1 = setcc t4, t6, setlt:ch
Creating constant: t9: i1 = Constant<0>
Creating constant: t10: i8 = Constant<0>
Creating new node: t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>
Creating constant: t13: i1 = Constant<-1>
Creating new node: t14: i1 = xor t8, Constant:i1<-1>
Creating new node: t16: ch = brcond t12, t14, BasicBlock:ch<land.end 0x773fe68>
Creating new node: t18: ch = br t16, BasicBlock:ch<land.rhs 0x773fda0>
Initial selection DAG: %bb.4 'quick_sort:while.cond2'
SelectionDAG has 19 nodes:
  t0: ch = EntryToken
  t2: i64 = Constant<0>
  t9: i1 = Constant<0>
      t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>
          t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
          t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
        t8: i1 = setcc t4, t6, setlt:ch
      t14: i1 = xor t8, Constant:i1<-1>
    t16: ch = brcond t12, t14, BasicBlock:ch<land.end 0x773fe68>
  t18: ch = br t16, BasicBlock:ch<land.rhs 0x773fda0>



Combining: t18: ch = br t16, BasicBlock:ch<land.rhs 0x773fda0>

Combining: t17: ch = BasicBlock<land.rhs 0x773fda0>

Combining: t16: ch = brcond t12, t14, BasicBlock:ch<land.end 0x773fe68>
Creating new node: t20: i1 = setcc t4, t6, setge:ch
Creating new node: t21: ch = brcond t12, t20, BasicBlock:ch<land.end 0x773fe68>
 ... into: t21: ch = brcond t12, t20, BasicBlock:ch<land.end 0x773fe68>

Combining: t18: ch = br t21, BasicBlock:ch<land.rhs 0x773fda0>

Combining: t21: ch = brcond t12, t20, BasicBlock:ch<land.end 0x773fe68>

Combining: t20: i1 = setcc t4, t6, setge:ch

Combining: t19: ch = setge

Combining: t15: ch = BasicBlock<land.end 0x773fe68>

Combining: t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>

Combining: t11: i8 = Register %24

Combining: t10: i8 = Constant<0>

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Combining: t5: i64 = FrameIndex<3>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.4 'quick_sort:while.cond2'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
      t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t20: i1 = setcc t4, t6, setge:ch
    t21: ch = brcond t12, t20, BasicBlock:ch<land.end 0x773fe68>
  t18: ch = br t21, BasicBlock:ch<land.rhs 0x773fda0>


Legalizing node: t19: ch = setge
Analyzing result type: ch
Legal result type
Legally typed node: t19: ch = setge

Legalizing node: t17: ch = BasicBlock<land.rhs 0x773fda0>
Analyzing result type: ch
Legal result type
Legally typed node: t17: ch = BasicBlock<land.rhs 0x773fda0>

Legalizing node: t15: ch = BasicBlock<land.end 0x773fe68>
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = BasicBlock<land.end 0x773fe68>

Legalizing node: t11: i8 = Register %24
Ignoring node results
Legally typed node: t11: i8 = Register %24

Legalizing node: t10: i8 = Constant<0>
Analyzing result type: i8
Legal result type
Legally typed node: t10: i8 = Constant<0>

Legalizing node: t5: i64 = FrameIndex<3>
Analyzing result type: i64
Legal result type
Legally typed node: t5: i64 = FrameIndex<3>

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<2>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Legalizing node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t5: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Legalizing node: t20: i1 = setcc t4, t6, setge:ch
Analyzing result type: i1
Promote integer result: t20: i1 = setcc t4, t6, setge:ch

Creating new node: t22: i8 = setcc t4, t6, setge:ch
Legalizing node: t22: i8 = setcc t4, t6, setge:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t19: ch = setge
Legal operand
Legally typed node: t22: i8 = setcc t4, t6, setge:ch

Legalizing node: t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t10: i8 = Constant<0>
Legal operand
Legally typed node: t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>

Legalizing node: t21: ch = brcond t12, t20, BasicBlock:ch<land.end 0x773fe68>
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>
Legal operand
Analyzing operand: t20: i1 = setcc t4, t6, setge:ch
Promote integer operand: t21: ch = brcond t12, t20, BasicBlock:ch<land.end 0x773fe68>

Creating new node: t23: i8 = zero_extend t20
Legalizing node: t23: i8 = zero_extend t20
Analyzing result type: i8
Legal result type
Analyzing operand: t20: i1 = setcc t4, t6, setge:ch
Promote integer operand: t23: i8 = zero_extend t20

Creating constant: t24: i8 = Constant<1>
Creating new node: t25: i8 = and t22, Constant:i8<1>
Legalizing node: t24: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t24: i8 = Constant<1>

Legalizing node: t25: i8 = and t22, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t22: i8 = setcc t4, t6, setge:ch
Legal operand
Analyzing operand: t24: i8 = Constant<1>
Legal operand
Legally typed node: t25: i8 = and t22, Constant:i8<1>

Legalizing node: t21: ch = brcond t12, t25, BasicBlock:ch<land.end 0x773fe68>
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>
Legal operand
Analyzing operand: t25: i8 = and t22, Constant:i8<1>
Legal operand
Analyzing operand: t15: ch = BasicBlock<land.end 0x773fe68>
Legal operand
Legally typed node: t21: ch = brcond t12, t25, BasicBlock:ch<land.end 0x773fe68>

Legalizing node: t18: ch = br t21, BasicBlock:ch<land.rhs 0x773fda0>
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = brcond t12, t25, BasicBlock:ch<land.end 0x773fe68>
Legal operand
Analyzing operand: t17: ch = BasicBlock<land.rhs 0x773fda0>
Legal operand
Legally typed node: t18: ch = br t21, BasicBlock:ch<land.rhs 0x773fda0>

Legalizing node: t65535: ch = handlenode t18
Analyzing result type: ch
Legal result type
Analyzing operand: t18: ch = br t21, BasicBlock:ch<land.rhs 0x773fda0>
Legal operand
Legally typed node: t65535: ch = handlenode t18

Type-legalized selection DAG: %bb.4 'quick_sort:while.cond2'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
      t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>
          t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
          t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
        t22: i8 = setcc t4, t6, setge:ch
      t25: i8 = and t22, Constant:i8<1>
    t21: ch = brcond t12, t25, BasicBlock:ch<land.end 0x773fe68>
  t18: ch = br t21, BasicBlock:ch<land.rhs 0x773fda0>



Combining: t25: i8 = and t22, Constant:i8<1>

Replacing.2 t25: i8 = and t22, Constant:i8<1>

With: t22: i8 = setcc t4, t6, setge:ch


Combining: t22: i8 = setcc t4, t6, setge:ch

Combining: t21: ch = brcond t12, t22, BasicBlock:ch<land.end 0x773fe68>

Combining: t19: ch = setge

Combining: t18: ch = br t21, BasicBlock:ch<land.rhs 0x773fda0>

Combining: t17: ch = BasicBlock<land.rhs 0x773fda0>

Combining: t15: ch = BasicBlock<land.end 0x773fe68>

Combining: t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>

Combining: t11: i8 = Register %24

Combining: t10: i8 = Constant<0>

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Combining: t5: i64 = FrameIndex<3>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.4 'quick_sort:while.cond2'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
      t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t22: i8 = setcc t4, t6, setge:ch
    t21: ch = brcond t12, t22, BasicBlock:ch<land.end 0x773fe68>
  t18: ch = br t21, BasicBlock:ch<land.rhs 0x773fda0>



Legalizing: t18: ch = br t21, BasicBlock:ch<land.rhs 0x773fda0>
Legal node: nothing to do

Legalizing: t21: ch = brcond t12, t22, BasicBlock:ch<land.end 0x773fe68>
Trying custom legalization
Creating new node: t26: i32,i32 = X86ISD::SUB t4, t6
Creating constant: t27: i8 = Constant<6>
Creating new node: t28: i8 = X86ISD::SETCC Constant:i8<6>, t26:1
Creating new node: t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end 0x773fe68>, Constant:i8<6>, t26:1
Successfully custom legalized node
 ... replacing: t21: ch = brcond t12, t22, BasicBlock:ch<land.end 0x773fe68>
     with:      t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end 0x773fe68>, Constant:i8<6>, t26:1

Legalizing: t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>
Legal node: nothing to do

Legalizing: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Legalizing: t17: ch = BasicBlock<land.rhs 0x773fda0>
Legal node: nothing to do

Legalizing: t15: ch = BasicBlock<land.end 0x773fe68>
Legal node: nothing to do

Legalizing: t11: i8 = Register %24

Legalizing: t10: i8 = Constant<0>
Legal node: nothing to do

Legalizing: t5: i64 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end 0x773fe68>, Constant:i8<6>, t26:1
Legal node: nothing to do

Legalizing: t27: i8 = Constant<6>
Legal node: nothing to do

Legalizing: t26: i32,i32 = X86ISD::SUB t4, t6
Legal node: nothing to do
Legalized selection DAG: %bb.4 'quick_sort:while.cond2'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
      t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t26: i32,i32 = X86ISD::SUB t4, t6
    t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end 0x773fe68>, Constant:i8<6>, t26:1
  t18: ch = br t29, BasicBlock:ch<land.rhs 0x773fda0>



Legalizing: t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end 0x773fe68>, Constant:i8<6>, t26:1
Legal node: nothing to do

Combining: t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end 0x773fe68>, Constant:i8<6>, t26:1

Legalizing: t27: i8 = Constant<6>
Legal node: nothing to do

Combining: t27: i8 = Constant<6>

Legalizing: t26: i32,i32 = X86ISD::SUB t4, t6
Legal node: nothing to do

Combining: t26: i32,i32 = X86ISD::SUB t4, t6

Legalizing: t18: ch = br t29, BasicBlock:ch<land.rhs 0x773fda0>
Legal node: nothing to do

Combining: t18: ch = br t29, BasicBlock:ch<land.rhs 0x773fda0>

Legalizing: t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>
Legal node: nothing to do

Combining: t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>

Legalizing: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Legalizing: t17: ch = BasicBlock<land.rhs 0x773fda0>
Legal node: nothing to do

Combining: t17: ch = BasicBlock<land.rhs 0x773fda0>

Legalizing: t15: ch = BasicBlock<land.end 0x773fe68>
Legal node: nothing to do

Combining: t15: ch = BasicBlock<land.end 0x773fe68>

Legalizing: t11: i8 = Register %24

Combining: t11: i8 = Register %24

Legalizing: t10: i8 = Constant<0>
Legal node: nothing to do

Combining: t10: i8 = Constant<0>

Legalizing: t5: i64 = FrameIndex<3>
Legal node: nothing to do

Combining: t5: i64 = FrameIndex<3>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<2>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.4 'quick_sort:while.cond2'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
      t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t26: i32,i32 = X86ISD::SUB t4, t6
    t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end 0x773fe68>, Constant:i8<6>, t26:1
  t18: ch = br t29, BasicBlock:ch<land.rhs 0x773fda0>


===== Instruction selection begins: %bb.4 'while.cond2'

ISEL: Starting selection on root node: t18: ch = br t29, BasicBlock:ch<land.rhs 0x773fda0>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t18: ch = JMP_1 BasicBlock:ch<land.rhs 0x773fda0>, t29
ISEL: Match complete!

ISEL: Starting selection on root node: t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end 0x773fe68>, Constant:i8<6>, t26:1
ISEL: Starting pattern match
  Initial Opcode index to 150935
  Skipped scope entry (due to false predicate) at index 150944, continuing at 150957
  Skipped scope entry (due to false predicate) at index 150958, continuing at 150971
  Skipped scope entry (due to false predicate) at index 150972, continuing at 150985
  Skipped scope entry (due to false predicate) at index 150986, continuing at 150999
  Skipped scope entry (due to false predicate) at index 151000, continuing at 151013
  Skipped scope entry (due to false predicate) at index 151014, continuing at 151027
  Skipped scope entry (due to false predicate) at index 151028, continuing at 151041
  Skipped scope entry (due to false predicate) at index 151042, continuing at 151055
  Skipped scope entry (due to false predicate) at index 151056, continuing at 151069
  Skipped scope entry (due to false predicate) at index 151070, continuing at 151083
  Skipped scope entry (due to false predicate) at index 151084, continuing at 151097
  Skipped scope entry (due to false predicate) at index 151098, continuing at 151111
  Skipped scope entry (due to false predicate) at index 151112, continuing at 151125
Creating new node: t31: ch,glue = CopyToReg t12, Register:i32 $eflags, t26:1
  Morphed node: t29: ch = JGE_1 BasicBlock:ch<land.end 0x773fe68>, t31, t31:1
ISEL: Match complete!

ISEL: Starting selection on root node: t26: i32,i32 = X86ISD::SUB t4, t6
ISEL: Starting pattern match
  Initial Opcode index to 119640
  Match failed at index 119649
  Continuing at 119747
  Match failed at index 119748
  Continuing at 119793
  Skipped scope entry (due to false predicate) at index 119803, continuing at 119884
  Match failed at index 119888
  Continuing at 119902
  Match failed at index 119906
  Continuing at 119920
  Match failed at index 119926
  Continuing at 119938
  Match failed at index 119939
  Continuing at 119958
  Match failed at index 119959
  Continuing at 119978
  Continuing at 119979
  Match failed at index 119980
  Continuing at 119991
  Match failed at index 119992
  Continuing at 120003
  Morphed node: t26: i32,i32 = SUB32rr t4, t6
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = CopyToReg t0, Register:i8 %24, Constant:i8<0>

ISEL: Starting selection on root node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t34: i8 = TargetConstant<1>
Creating constant: t35: i32 = TargetConstant<0>
  Morphed node: t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t17: ch = BasicBlock<land.rhs 0x773fda0>

ISEL: Starting selection on root node: t15: ch = BasicBlock<land.end 0x773fe68>

ISEL: Starting selection on root node: t11: i8 = Register %24

ISEL: Starting selection on root node: t10: i8 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 145636
  TypeSwitch[i8] from 145640 to 145652
  Created node: t38: i32,i32 = MOV32r0
Creating constant: t39: i32 = TargetConstant<1>
  Morphed node: t10: i8 = EXTRACT_SUBREG MOV32r0:i32,i32, TargetConstant:i32<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.4 'quick_sort:while.cond2'
SelectionDAG has 21 nodes:
  t0: ch = EntryToken
      t10: i8 = EXTRACT_SUBREG MOV32r0:i32,i32, TargetConstant:i32<1>
    t12: ch = CopyToReg t0, Register:i8 %24, t10
      t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
      t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
    t26: i32,i32 = SUB32rr t4, t6
  t31: ch,glue = CopyToReg t12, Register:i32 $eflags, t26:1
    t29: ch = JGE_1 BasicBlock:ch<land.end 0x773fe68>, t31, t31:1
  t18: ch = JMP_1 BasicBlock:ch<land.rhs 0x773fda0>, t29


********** List Scheduling %bb.4 'while.cond2' **********
SU(0): t18: ch = JMP_1 BasicBlock:ch<land.rhs 0x773fda0>, t29

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t29: ch = JGE_1 BasicBlock:ch<land.end 0x773fe68>, t31, t31:1

    t31: ch,glue = CopyToReg t12, Register:i32 $eflags, t26:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t26: i32,i32 = SUB32rr t4, t6

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1
SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1
SU(5): t12: ch = CopyToReg t0, Register:i8 %24, t10

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(6): t10: i8 = EXTRACT_SUBREG MOV32r0:i32,i32, TargetConstant:i32<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(7): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(7): t38: i32,i32 = MOV32r0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(6): Data Latency=1

Examining Available:
Height 0: SU(0): t18: ch = JMP_1 BasicBlock:ch<land.rhs 0x773fda0>, t29


*** Scheduling [0]: SU(0): t18: ch = JMP_1 BasicBlock:ch<land.rhs 0x773fda0>, t29


Examining Available:
Height 1: SU(1): t29: ch = JGE_1 BasicBlock:ch<land.end 0x773fe68>, t31, t31:1

    t31: ch,glue = CopyToReg t12, Register:i32 $eflags, t26:1


*** Scheduling [1]: SU(1): t29: ch = JGE_1 BasicBlock:ch<land.end 0x773fe68>, t31, t31:1

    t31: ch,glue = CopyToReg t12, Register:i32 $eflags, t26:1


Examining Available:
  SU (5)  has no physreg SU(2)  defines a physreg
Height 2: SU(2): t26: i32,i32 = SUB32rr t4, t6

Height 2: SU(5): t12: ch = CopyToReg t0, Register:i8 %24, t10

  SU (5)  has no physreg SU(2)  defines a physreg

*** Scheduling [2]: SU(2): t26: i32,i32 = SUB32rr t4, t6


Examining Available:
Height 2: SU(5): t12: ch = CopyToReg t0, Register:i8 %24, t10

Height 3: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [3]: SU(5): t12: ch = CopyToReg t0, Register:i8 %24, t10


Examining Available:
Height 4: SU(6): t10: i8 = EXTRACT_SUBREG MOV32r0:i32,i32, TargetConstant:i32<1>

Height 3: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [4]: SU(6): t10: i8 = EXTRACT_SUBREG MOV32r0:i32,i32, TargetConstant:i32<1>


Examining Available:
Height 5: SU(7): t38: i32,i32 = MOV32r0

Height 3: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [5]: SU(7): t38: i32,i32 = MOV32r0


Examining Available:
Height 3: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [6]: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


Examining Available:
Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [7]: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(7): t38: i32,i32 = MOV32r0

SU(6): t10: i8 = EXTRACT_SUBREG MOV32r0:i32,i32, TargetConstant:i32<1>

SU(5): t12: ch = CopyToReg t0, Register:i8 %24, t10

SU(2): t26: i32,i32 = SUB32rr t4, t6

SU(1): t29: ch = JGE_1 BasicBlock:ch<land.end 0x773fe68>, t31, t31:1

    t31: ch,glue = CopyToReg t12, Register:i32 $eflags, t26:1

SU(0): t18: ch = JMP_1 BasicBlock:ch<land.rhs 0x773fda0>, t29


Total amount of phi nodes to update: 1
Node 0 : (0x773ff30, 2147483672)
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Creating new node: t5: i64 = sign_extend t4
Creating constant: t7: i64 = Constant<2>
Creating new node: t8: i64 = shl t5, Constant:i64<2>
Creating new node: t9: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t8
Creating new node: t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t9, undef:i64
Creating new node: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Creating new node: t14: i1 = setcc t10, t12, setge:ch
Creating new node: t15: i8 = any_extend t14
Creating new node: t17: ch = CopyToReg t0, Register:i8 %0, t15
Creating new node: t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>
Initial selection DAG: %bb.5 'quick_sort:land.rhs'
SelectionDAG has 20 nodes:
  t0: ch = EntryToken
  t2: i64 = Constant<0>
                  t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
                t5: i64 = sign_extend t4
              t8: i64 = shl t5, Constant:i64<2>
            t9: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t8
          t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t9, undef:i64
          t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
        t14: i1 = setcc t10, t12, setge:ch
      t15: i8 = any_extend t14
    t17: ch = CopyToReg t0, Register:i8 %0, t15
  t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>



Combining: t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>

Combining: t18: ch = BasicBlock<land.end 0x773fe68>

Combining: t17: ch = CopyToReg t0, Register:i8 %0, t15

Combining: t16: i8 = Register %0

Combining: t15: i8 = any_extend t14
Creating constant: t20: i8 = Constant<0>
Creating constant: t21: i8 = Constant<1>

Combining: t14: i1 = setcc t10, t12, setge:ch

Combining: t13: ch = setge

Combining: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64

Combining: t11: i64 = FrameIndex<4>

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t9, undef:i64

Combining: t9: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t8
Creating new node: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
 ... into: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64

Combining: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t8: i64 = shl t5, Constant:i64<2>

Combining: t7: i64 = Constant<2>

Combining: t6: i64 = GlobalAddress<[100 x i32]* @s> 0

Combining: t5: i64 = sign_extend t4
Creating new node: t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Replacing.1 t5: i64 = sign_extend t4

With: t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
 and 0 other values

Combining: t8: i64 = shl t23, Constant:i64<2>

Combining: t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<3>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.5 'quick_sort:land.rhs'
SelectionDAG has 18 nodes:
  t0: ch = EntryToken
                t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
              t8: i64 = shl t23, Constant:i64<2>
            t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
          t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64
          t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
        t14: i1 = setcc t10, t12, setge:ch
      t15: i8 = any_extend t14
    t17: ch = CopyToReg t0, Register:i8 %0, t15
  t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>


Legalizing node: t18: ch = BasicBlock<land.end 0x773fe68>
Analyzing result type: ch
Legal result type
Legally typed node: t18: ch = BasicBlock<land.end 0x773fe68>

Legalizing node: t16: i8 = Register %0
Ignoring node results
Legally typed node: t16: i8 = Register %0

Legalizing node: t13: ch = setge
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = setge

Legalizing node: t11: i64 = FrameIndex<4>
Analyzing result type: i64
Legal result type
Legally typed node: t11: i64 = FrameIndex<4>

Legalizing node: t7: i64 = Constant<2>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<2>

Legalizing node: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = GlobalAddress<[100 x i32]* @s> 0

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<3>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<3>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t11: i64 = FrameIndex<4>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64

Legalizing node: t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Legalizing node: t8: i64 = shl t23, Constant:i64<2>
Analyzing result type: i64
Legal result type
Analyzing operand: t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t7: i64 = Constant<2>
Legal operand
Legally typed node: t8: i64 = shl t23, Constant:i64<2>

Legalizing node: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Analyzing operand: t8: i64 = shl t23, Constant:i64<2>
Legal operand
Analyzing operand: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Legal operand
Legally typed node: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Legalizing node: t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64

Legalizing node: t14: i1 = setcc t10, t12, setge:ch
Analyzing result type: i1
Promote integer result: t14: i1 = setcc t10, t12, setge:ch

Creating new node: t24: i8 = setcc t10, t12, setge:ch
Legalizing node: t15: i8 = any_extend t14
Analyzing result type: i8
Legal result type
Analyzing operand: t14: i1 = setcc t10, t12, setge:ch
Promote integer operand: t15: i8 = any_extend t14

Legalizing node: t24: i8 = setcc t10, t12, setge:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64
Legal operand
Analyzing operand: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Legal operand
Analyzing operand: t13: ch = setge
Legal operand
Legally typed node: t24: i8 = setcc t10, t12, setge:ch

Legalizing node: t17: ch = CopyToReg t0, Register:i8 %0, t24
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t24: i8 = setcc t10, t12, setge:ch
Legal operand
Legally typed node: t17: ch = CopyToReg t0, Register:i8 %0, t24

Legalizing node: t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>
Analyzing result type: ch
Legal result type
Analyzing operand: t17: ch = CopyToReg t0, Register:i8 %0, t24
Legal operand
Analyzing operand: t18: ch = BasicBlock<land.end 0x773fe68>
Legal operand
Legally typed node: t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>

Legalizing node: t65535: ch = handlenode t19
Analyzing result type: ch
Legal result type
Analyzing operand: t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>
Legal operand
Legally typed node: t65535: ch = handlenode t19

Type-legalized selection DAG: %bb.5 'quick_sort:land.rhs'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
              t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
            t8: i64 = shl t23, Constant:i64<2>
          t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
        t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64
        t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
      t24: i8 = setcc t10, t12, setge:ch
    t17: ch = CopyToReg t0, Register:i8 %0, t24
  t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>



Combining: t24: i8 = setcc t10, t12, setge:ch

Combining: t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Combining: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>

Combining: t18: ch = BasicBlock<land.end 0x773fe68>

Combining: t17: ch = CopyToReg t0, Register:i8 %0, t24

Combining: t16: i8 = Register %0

Combining: t13: ch = setge

Combining: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64

Combining: t11: i64 = FrameIndex<4>

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64

Combining: t8: i64 = shl t23, Constant:i64<2>

Combining: t7: i64 = Constant<2>

Combining: t6: i64 = GlobalAddress<[100 x i32]* @s> 0

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<3>

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.5 'quick_sort:land.rhs'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
              t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
            t8: i64 = shl t23, Constant:i64<2>
          t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
        t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64
        t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
      t24: i8 = setcc t10, t12, setge:ch
    t17: ch = CopyToReg t0, Register:i8 %0, t24
  t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>



Legalizing: t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>
Legal node: nothing to do

Legalizing: t17: ch = CopyToReg t0, Register:i8 %0, t24
Legal node: nothing to do

Legalizing: t24: i8 = setcc t10, t12, setge:ch
Trying custom legalization
Creating new node: t25: i32,i32 = X86ISD::SUB t10, t12
Creating constant: t26: i8 = Constant<6>
Creating new node: t27: i8 = X86ISD::SETCC Constant:i8<6>, t25:1
Successfully custom legalized node
 ... replacing: t24: i8 = setcc t10, t12, setge:ch
     with:      t27: i8 = X86ISD::SETCC Constant:i8<6>, t25:1

Legalizing: t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64
Legalizing non-extending load operation

Legalizing: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t8: i64 = shl t23, Constant:i64<2>
Creating constant: t28: i8 = Constant<2>
Legal node: nothing to do

Legalizing: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Legalizing non-extending load operation

Legalizing: t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Legalizing extending load operation

Legalizing: t18: ch = BasicBlock<land.end 0x773fe68>
Legal node: nothing to do

Legalizing: t16: i8 = Register %0

Legalizing: t11: i64 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Trying custom legalization
Creating new node: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Successfully custom legalized node
 ... replacing: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
     with:      t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t29: i64 = TargetGlobalAddress<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t28: i8 = Constant<2>
Legal node: nothing to do

Legalizing: t27: i8 = X86ISD::SETCC Constant:i8<6>, t25:1
Legal node: nothing to do

Legalizing: t26: i8 = Constant<6>
Legal node: nothing to do

Legalizing: t25: i32,i32 = X86ISD::SUB t10, t12
Legal node: nothing to do
Legalized selection DAG: %bb.5 'quick_sort:land.rhs'
SelectionDAG has 19 nodes:
  t0: ch = EntryToken
                t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
              t8: i64 = shl t23, Constant:i8<2>
              t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
            t22: i64 = add t8, t30
          t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64
          t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
        t25: i32,i32 = X86ISD::SUB t10, t12
      t27: i8 = X86ISD::SETCC Constant:i8<6>, t25:1
    t17: ch = CopyToReg t0, Register:i8 %0, t27
  t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>



Legalizing: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Combining: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0

Legalizing: t29: i64 = TargetGlobalAddress<[100 x i32]* @s> 0
Legal node: nothing to do

Combining: t29: i64 = TargetGlobalAddress<[100 x i32]* @s> 0

Legalizing: t28: i8 = Constant<2>
Legal node: nothing to do

Combining: t28: i8 = Constant<2>

Legalizing: t27: i8 = X86ISD::SETCC Constant:i8<6>, t25:1
Legal node: nothing to do

Combining: t27: i8 = X86ISD::SETCC Constant:i8<6>, t25:1

Legalizing: t26: i8 = Constant<6>
Legal node: nothing to do

Combining: t26: i8 = Constant<6>

Legalizing: t25: i32,i32 = X86ISD::SUB t10, t12
Legal node: nothing to do

Combining: t25: i32,i32 = X86ISD::SUB t10, t12

Legalizing: t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>
Legal node: nothing to do

Combining: t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>

Legalizing: t17: ch = CopyToReg t0, Register:i8 %0, t27
Legal node: nothing to do

Combining: t17: ch = CopyToReg t0, Register:i8 %0, t27

Legalizing: t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64
Legalizing non-extending load operation

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64

Legalizing: t22: i64 = add t8, t30
Legal node: nothing to do

Combining: t22: i64 = add t8, t30

Legalizing: t8: i64 = shl t23, Constant:i8<2>
Legal node: nothing to do

Combining: t8: i64 = shl t23, Constant:i8<2>

Legalizing: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Legalizing non-extending load operation

Combining: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64

Legalizing: t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Legalizing extending load operation

Combining: t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Legalizing: t18: ch = BasicBlock<land.end 0x773fe68>
Legal node: nothing to do

Combining: t18: ch = BasicBlock<land.end 0x773fe68>

Legalizing: t16: i8 = Register %0

Combining: t16: i8 = Register %0

Legalizing: t11: i64 = FrameIndex<4>
Legal node: nothing to do

Combining: t11: i64 = FrameIndex<4>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<3>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.5 'quick_sort:land.rhs'
SelectionDAG has 19 nodes:
  t0: ch = EntryToken
                t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
              t8: i64 = shl t23, Constant:i8<2>
              t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
            t22: i64 = add t8, t30
          t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64
          t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
        t25: i32,i32 = X86ISD::SUB t10, t12
      t27: i8 = X86ISD::SETCC Constant:i8<6>, t25:1
    t17: ch = CopyToReg t0, Register:i8 %0, t27
  t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>


===== Instruction selection begins: %bb.5 'land.rhs'

ISEL: Starting selection on root node: t19: ch = br t17, BasicBlock:ch<land.end 0x773fe68>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t19: ch = JMP_1 BasicBlock:ch<land.end 0x773fe68>, t17
ISEL: Match complete!

ISEL: Starting selection on root node: t17: ch = CopyToReg t0, Register:i8 %0, t27

ISEL: Starting selection on root node: t27: i8 = X86ISD::SETCC Constant:i8<6>, t25:1
ISEL: Starting pattern match
  Initial Opcode index to 150721
  Skipped scope entry (due to false predicate) at index 150723, continuing at 150735
  Skipped scope entry (due to false predicate) at index 150736, continuing at 150748
  Skipped scope entry (due to false predicate) at index 150749, continuing at 150761
  Skipped scope entry (due to false predicate) at index 150762, continuing at 150774
  Skipped scope entry (due to false predicate) at index 150775, continuing at 150787
  Skipped scope entry (due to false predicate) at index 150788, continuing at 150800
  Skipped scope entry (due to false predicate) at index 150801, continuing at 150813
  Skipped scope entry (due to false predicate) at index 150814, continuing at 150826
  Skipped scope entry (due to false predicate) at index 150827, continuing at 150839
  Skipped scope entry (due to false predicate) at index 150840, continuing at 150852
  Skipped scope entry (due to false predicate) at index 150853, continuing at 150865
  Skipped scope entry (due to false predicate) at index 150866, continuing at 150878
  Skipped scope entry (due to false predicate) at index 150879, continuing at 150891
Creating new node: t32: ch,glue = CopyToReg t0, Register:i32 $eflags, t25:1
  Morphed node: t27: i8 = SETGEr t32:1
ISEL: Match complete!

ISEL: Starting selection on root node: t25: i32,i32 = X86ISD::SUB t10, t12
ISEL: Starting pattern match
  Initial Opcode index to 119640
  Match failed at index 119649
  Continuing at 119747
  Match failed at index 119748
  Continuing at 119793
  Skipped scope entry (due to false predicate) at index 119803, continuing at 119884
  Match failed at index 119888
  Continuing at 119902
  Match failed at index 119906
  Continuing at 119920
  Match failed at index 119926
  Continuing at 119938
  Match failed at index 119939
  Continuing at 119958
  Match failed at index 119959
  Continuing at 119978
  Continuing at 119979
  Match failed at index 119980
  Continuing at 119991
  Match failed at index 119992
  Continuing at 120003
  Morphed node: t25: i32,i32 = SUB32rr t10, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t10: i32,ch = load<(load 4 from %ir.arrayidx5)> t0, t22, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 4
IndexReg t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t34: i8 = TargetConstant<4>
  Morphed node: t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx5)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t38: i8 = TargetConstant<1>
Creating constant: t39: i32 = TargetConstant<0>
  Morphed node: t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t23: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Skipped scope entry (due to false predicate) at index 137189, continuing at 137208
  Skipped scope entry (due to false predicate) at index 137209, continuing at 137228
  Skipped scope entry (due to false predicate) at index 137229, continuing at 137248
  Skipped scope entry (due to false predicate) at index 137249, continuing at 137268
  Match failed at index 137271
  Continuing at 137311
  Match failed at index 137312
  Continuing at 137354
  Skipped scope entry (due to false predicate) at index 137361, continuing at 137378
  Skipped scope entry (due to false predicate) at index 137379, continuing at 137396
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t23: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = BasicBlock<land.end 0x773fe68>

ISEL: Starting selection on root node: t16: i8 = Register %0

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.5 'quick_sort:land.rhs'
SelectionDAG has 20 nodes:
  t0: ch = EntryToken
              t23: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
            t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx5)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0
            t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
          t25: i32,i32 = SUB32rr t10, t12
        t32: ch,glue = CopyToReg t0, Register:i32 $eflags, t25:1
      t27: i8 = SETGEr t32:1
    t17: ch = CopyToReg t0, Register:i8 %0, t27
  t19: ch = JMP_1 BasicBlock:ch<land.end 0x773fe68>, t17


********** List Scheduling %bb.5 'land.rhs' **********
SU(0): t19: ch = JMP_1 BasicBlock:ch<land.end 0x773fe68>, t17

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t17: ch = CopyToReg t0, Register:i8 %0, t27

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t27: i8 = SETGEr t32:1

    t32: ch,glue = CopyToReg t0, Register:i32 $eflags, t25:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1 Reg=$eflags
  Successors:
    SU(1): Data Latency=1
SU(3): t25: i32,i32 = SUB32rr t10, t12

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1 Reg=$eflags
SU(4): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1
SU(5): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx5)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(6): t23: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(5): Data Latency=1

Examining Available:
Height 0: SU(0): t19: ch = JMP_1 BasicBlock:ch<land.end 0x773fe68>, t17


*** Scheduling [0]: SU(0): t19: ch = JMP_1 BasicBlock:ch<land.end 0x773fe68>, t17


Examining Available:
Height 1: SU(1): t17: ch = CopyToReg t0, Register:i8 %0, t27


*** Scheduling [1]: SU(1): t17: ch = CopyToReg t0, Register:i8 %0, t27


Examining Available:
Height 2: SU(2): t27: i8 = SETGEr t32:1

    t32: ch,glue = CopyToReg t0, Register:i32 $eflags, t25:1


*** Scheduling [2]: SU(2): t27: i8 = SETGEr t32:1

    t32: ch,glue = CopyToReg t0, Register:i32 $eflags, t25:1


Examining Available:
Height 3: SU(3): t25: i32,i32 = SUB32rr t10, t12


*** Scheduling [3]: SU(3): t25: i32,i32 = SUB32rr t10, t12


Examining Available:
Height 4: SU(4): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 4: SU(5): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx5)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


*** Scheduling [4]: SU(4): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


Examining Available:
Height 4: SU(5): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx5)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


*** Scheduling [5]: SU(5): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx5)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


Examining Available:
Height 6: SU(6): t23: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [6]: SU(6): t23: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(6): t23: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(5): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx5)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0

SU(4): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(3): t25: i32,i32 = SUB32rr t10, t12

SU(2): t27: i8 = SETGEr t32:1

    t32: ch,glue = CopyToReg t0, Register:i32 $eflags, t25:1

SU(1): t17: ch = CopyToReg t0, Register:i8 %0, t27

SU(0): t19: ch = JMP_1 BasicBlock:ch<land.end 0x773fe68>, t17


Total amount of phi nodes to update: 1
Node 0 : (0x773ff30, 2147483648)
Creating new node: t2: i8,ch = CopyFromReg t0, Register:i8 %1
Creating new node: t3: i1 = truncate t2
Creating constant: t4: i1 = Constant<-1>
Creating new node: t5: i1 = xor t3, Constant:i1<-1>
Creating new node: t7: ch = brcond t0, t5, BasicBlock:ch<while.end 0x7740060>
Creating new node: t9: ch = br t7, BasicBlock:ch<while.body7 0x773ff98>
Initial selection DAG: %bb.6 'quick_sort:land.end'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
          t2: i8,ch = CopyFromReg t0, Register:i8 %1
        t3: i1 = truncate t2
      t5: i1 = xor t3, Constant:i1<-1>
    t7: ch = brcond t0, t5, BasicBlock:ch<while.end 0x7740060>
  t9: ch = br t7, BasicBlock:ch<while.body7 0x773ff98>



Combining: t9: ch = br t7, BasicBlock:ch<while.body7 0x773ff98>

Combining: t8: ch = BasicBlock<while.body7 0x773ff98>

Combining: t7: ch = brcond t0, t5, BasicBlock:ch<while.end 0x7740060>
Creating new node: t11: i1 = setcc t3, Constant:i1<-1>, setne:ch
Creating new node: t12: ch = brcond t0, t11, BasicBlock:ch<while.end 0x7740060>
 ... into: t12: ch = brcond t0, t11, BasicBlock:ch<while.end 0x7740060>

Combining: t9: ch = br t12, BasicBlock:ch<while.body7 0x773ff98>

Combining: t12: ch = brcond t0, t11, BasicBlock:ch<while.end 0x7740060>

Combining: t11: i1 = setcc t3, Constant:i1<-1>, setne:ch

Combining: t10: ch = setne

Combining: t6: ch = BasicBlock<while.end 0x7740060>

Combining: t4: i1 = Constant<-1>

Combining: t3: i1 = truncate t2

Combining: t2: i8,ch = CopyFromReg t0, Register:i8 %1

Combining: t1: i8 = Register %1

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.6 'quick_sort:land.end'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
          t2: i8,ch = CopyFromReg t0, Register:i8 %1
        t3: i1 = truncate t2
      t11: i1 = setcc t3, Constant:i1<-1>, setne:ch
    t12: ch = brcond t0, t11, BasicBlock:ch<while.end 0x7740060>
  t9: ch = br t12, BasicBlock:ch<while.body7 0x773ff98>


Legalizing node: t10: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t10: ch = setne

Legalizing node: t8: ch = BasicBlock<while.body7 0x773ff98>
Analyzing result type: ch
Legal result type
Legally typed node: t8: ch = BasicBlock<while.body7 0x773ff98>

Legalizing node: t6: ch = BasicBlock<while.end 0x7740060>
Analyzing result type: ch
Legal result type
Legally typed node: t6: ch = BasicBlock<while.end 0x7740060>

Legalizing node: t4: i1 = Constant<-1>
Analyzing result type: i1
Promote integer result: t4: i1 = Constant<-1>

Creating constant: t13: i8 = Constant<1>
Legalizing node: t13: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t13: i8 = Constant<1>

Legalizing node: t1: i8 = Register %1
Ignoring node results
Legally typed node: t1: i8 = Register %1

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i8,ch = CopyFromReg t0, Register:i8 %1
Analyzing result type: i8
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i8,ch = CopyFromReg t0, Register:i8 %1

Legalizing node: t3: i1 = truncate t2
Analyzing result type: i1
Promote integer result: t3: i1 = truncate t2

Legalizing node: t11: i1 = setcc t3, Constant:i1<-1>, setne:ch
Analyzing result type: i1
Promote integer result: t11: i1 = setcc t3, Constant:i1<-1>, setne:ch

Creating new node: t14: i8 = setcc t3, Constant:i1<-1>, setne:ch
Legalizing node: t12: ch = brcond t0, t11, BasicBlock:ch<while.end 0x7740060>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t11: i1 = setcc t3, Constant:i1<-1>, setne:ch
Promote integer operand: t12: ch = brcond t0, t11, BasicBlock:ch<while.end 0x7740060>

Creating new node: t15: i8 = zero_extend t11
Legalizing node: t15: i8 = zero_extend t11
Analyzing result type: i8
Legal result type
Analyzing operand: t11: i1 = setcc t3, Constant:i1<-1>, setne:ch
Promote integer operand: t15: i8 = zero_extend t11

Creating new node: t16: i8 = and t14, Constant:i8<1>
Legalizing node: t14: i8 = setcc t3, Constant:i1<-1>, setne:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t3: i1 = truncate t2
Promote integer operand: t14: i8 = setcc t3, Constant:i1<-1>, setne:ch

Creating new node: t17: i8 = and t2, Constant:i8<1>
Legalizing node: t17: i8 = and t2, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t2: i8,ch = CopyFromReg t0, Register:i8 %1
Legal operand
Analyzing operand: t13: i8 = Constant<1>
Legal operand
Legally typed node: t17: i8 = and t2, Constant:i8<1>

Legalizing node: t14: i8 = setcc t17, Constant:i8<1>, setne:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t17: i8 = and t2, Constant:i8<1>
Legal operand
Analyzing operand: t13: i8 = Constant<1>
Legal operand
Analyzing operand: t10: ch = setne
Legal operand
Legally typed node: t14: i8 = setcc t17, Constant:i8<1>, setne:ch

Legalizing node: t16: i8 = and t14, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t14: i8 = setcc t17, Constant:i8<1>, setne:ch
Legal operand
Analyzing operand: t13: i8 = Constant<1>
Legal operand
Legally typed node: t16: i8 = and t14, Constant:i8<1>

Legalizing node: t12: ch = brcond t0, t16, BasicBlock:ch<while.end 0x7740060>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t16: i8 = and t14, Constant:i8<1>
Legal operand
Analyzing operand: t6: ch = BasicBlock<while.end 0x7740060>
Legal operand
Legally typed node: t12: ch = brcond t0, t16, BasicBlock:ch<while.end 0x7740060>

Legalizing node: t9: ch = br t12, BasicBlock:ch<while.body7 0x773ff98>
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = brcond t0, t16, BasicBlock:ch<while.end 0x7740060>
Legal operand
Analyzing operand: t8: ch = BasicBlock<while.body7 0x773ff98>
Legal operand
Legally typed node: t9: ch = br t12, BasicBlock:ch<while.body7 0x773ff98>

Legalizing node: t65535: ch = handlenode t9
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = br t12, BasicBlock:ch<while.body7 0x773ff98>
Legal operand
Legally typed node: t65535: ch = handlenode t9

Type-legalized selection DAG: %bb.6 'quick_sort:land.end'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
            t2: i8,ch = CopyFromReg t0, Register:i8 %1
          t17: i8 = and t2, Constant:i8<1>
        t14: i8 = setcc t17, Constant:i8<1>, setne:ch
      t16: i8 = and t14, Constant:i8<1>
    t12: ch = brcond t0, t16, BasicBlock:ch<while.end 0x7740060>
  t9: ch = br t12, BasicBlock:ch<while.body7 0x773ff98>



Combining: t17: i8 = and t2, Constant:i8<1>

Combining: t16: i8 = and t14, Constant:i8<1>

Replacing.2 t16: i8 = and t14, Constant:i8<1>

With: t14: i8 = setcc t17, Constant:i8<1>, setne:ch


Combining: t14: i8 = setcc t17, Constant:i8<1>, setne:ch
Creating constant: t18: i8 = Constant<0>
Creating new node: t20: i8 = setcc t17, Constant:i8<0>, seteq:ch
 ... into: t20: i8 = setcc t17, Constant:i8<0>, seteq:ch

Combining: t17: i8 = and t2, Constant:i8<1>

Combining: t20: i8 = setcc t17, Constant:i8<0>, seteq:ch

Combining: t19: ch = seteq

Combining: t18: i8 = Constant<0>

Combining: t13: i8 = Constant<1>

Combining: t12: ch = brcond t0, t20, BasicBlock:ch<while.end 0x7740060>

Combining: t9: ch = br t12, BasicBlock:ch<while.body7 0x773ff98>

Combining: t8: ch = BasicBlock<while.body7 0x773ff98>

Combining: t6: ch = BasicBlock<while.end 0x7740060>

Combining: t2: i8,ch = CopyFromReg t0, Register:i8 %1

Combining: t1: i8 = Register %1

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.6 'quick_sort:land.end'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
          t2: i8,ch = CopyFromReg t0, Register:i8 %1
        t17: i8 = and t2, Constant:i8<1>
      t20: i8 = setcc t17, Constant:i8<0>, seteq:ch
    t12: ch = brcond t0, t20, BasicBlock:ch<while.end 0x7740060>
  t9: ch = br t12, BasicBlock:ch<while.body7 0x773ff98>



Legalizing: t9: ch = br t12, BasicBlock:ch<while.body7 0x773ff98>
Legal node: nothing to do

Legalizing: t12: ch = brcond t0, t20, BasicBlock:ch<while.end 0x7740060>
Trying custom legalization
Creating new node: t21: i32 = X86ISD::CMP t17, Constant:i8<0>
Creating constant: t22: i8 = Constant<4>
Creating new node: t23: i8 = X86ISD::SETCC Constant:i8<4>, t21
Creating new node: t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end 0x7740060>, Constant:i8<4>, t21
Successfully custom legalized node
 ... replacing: t12: ch = brcond t0, t20, BasicBlock:ch<while.end 0x7740060>
     with:      t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end 0x7740060>, Constant:i8<4>, t21

Legalizing: t17: i8 = and t2, Constant:i8<1>
Legal node: nothing to do

Legalizing: t2: i8,ch = CopyFromReg t0, Register:i8 %1
Legal node: nothing to do

Legalizing: t18: i8 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i8 = Constant<1>
Legal node: nothing to do

Legalizing: t8: ch = BasicBlock<while.body7 0x773ff98>
Legal node: nothing to do

Legalizing: t6: ch = BasicBlock<while.end 0x7740060>
Legal node: nothing to do

Legalizing: t1: i8 = Register %1

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end 0x7740060>, Constant:i8<4>, t21
Legal node: nothing to do

Legalizing: t22: i8 = Constant<4>
Legal node: nothing to do

Legalizing: t21: i32 = X86ISD::CMP t17, Constant:i8<0>
Legal node: nothing to do
Legalized selection DAG: %bb.6 'quick_sort:land.end'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
          t2: i8,ch = CopyFromReg t0, Register:i8 %1
        t17: i8 = and t2, Constant:i8<1>
      t21: i32 = X86ISD::CMP t17, Constant:i8<0>
    t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end 0x7740060>, Constant:i8<4>, t21
  t9: ch = br t24, BasicBlock:ch<while.body7 0x773ff98>



Legalizing: t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end 0x7740060>, Constant:i8<4>, t21
Legal node: nothing to do

Combining: t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end 0x7740060>, Constant:i8<4>, t21

Legalizing: t22: i8 = Constant<4>
Legal node: nothing to do

Combining: t22: i8 = Constant<4>

Legalizing: t21: i32 = X86ISD::CMP t17, Constant:i8<0>
Legal node: nothing to do

Combining: t21: i32 = X86ISD::CMP t17, Constant:i8<0>

Legalizing: t9: ch = br t24, BasicBlock:ch<while.body7 0x773ff98>
Legal node: nothing to do

Combining: t9: ch = br t24, BasicBlock:ch<while.body7 0x773ff98>

Legalizing: t17: i8 = and t2, Constant:i8<1>
Legal node: nothing to do

Combining: t17: i8 = and t2, Constant:i8<1>

Legalizing: t2: i8,ch = CopyFromReg t0, Register:i8 %1
Legal node: nothing to do

Combining: t2: i8,ch = CopyFromReg t0, Register:i8 %1

Legalizing: t18: i8 = Constant<0>
Legal node: nothing to do

Combining: t18: i8 = Constant<0>

Legalizing: t13: i8 = Constant<1>
Legal node: nothing to do

Combining: t13: i8 = Constant<1>

Legalizing: t8: ch = BasicBlock<while.body7 0x773ff98>
Legal node: nothing to do

Combining: t8: ch = BasicBlock<while.body7 0x773ff98>

Legalizing: t6: ch = BasicBlock<while.end 0x7740060>
Legal node: nothing to do

Combining: t6: ch = BasicBlock<while.end 0x7740060>

Legalizing: t1: i8 = Register %1

Combining: t1: i8 = Register %1

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.6 'quick_sort:land.end'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
          t2: i8,ch = CopyFromReg t0, Register:i8 %1
        t17: i8 = and t2, Constant:i8<1>
      t21: i32 = X86ISD::CMP t17, Constant:i8<0>
    t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end 0x7740060>, Constant:i8<4>, t21
  t9: ch = br t24, BasicBlock:ch<while.body7 0x773ff98>


===== Instruction selection begins: %bb.6 'land.end'

ISEL: Starting selection on root node: t9: ch = br t24, BasicBlock:ch<while.body7 0x773ff98>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t9: ch = JMP_1 BasicBlock:ch<while.body7 0x773ff98>, t24
ISEL: Match complete!

ISEL: Starting selection on root node: t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end 0x7740060>, Constant:i8<4>, t21
ISEL: Starting pattern match
  Initial Opcode index to 150935
  Skipped scope entry (due to false predicate) at index 150944, continuing at 150957
  Skipped scope entry (due to false predicate) at index 150958, continuing at 150971
  Skipped scope entry (due to false predicate) at index 150972, continuing at 150985
  Skipped scope entry (due to false predicate) at index 150986, continuing at 150999
Creating new node: t26: ch,glue = CopyToReg t0, Register:i32 $eflags, t21
  Morphed node: t24: ch = JE_1 BasicBlock:ch<while.end 0x7740060>, t26, t26:1
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i32 = X86ISD::CMP t17, Constant:i8<0>
ISEL: Starting pattern match
  Initial Opcode index to 77651
  OpcodeSwitch from 77655 to 77660
  Match failed at index 77664
  Continuing at 77821
  Match failed at index 77831
  Continuing at 77869
  Match failed at index 77874
  Continuing at 77912
  Match failed at index 77917
  Continuing at 77955
  Continuing at 77956
  Match failed at index 77958
  Continuing at 78081
  Match failed at index 78084
  Continuing at 78203
  Continuing at 78428
  Match failed at index 78436
  Continuing at 78464
  Match failed at index 78465
  Continuing at 78496
  Match failed at index 78497
  Continuing at 78528
  Match failed at index 78529
  Continuing at 78560
  Continuing at 78561
  Match failed at index 78563
  Continuing at 78662
  Skipped scope entry (due to false predicate) at index 78667, continuing at 78741
  Skipped scope entry (due to false predicate) at index 78742, continuing at 78816
  Match failed at index 78665
  Continuing at 78817
  Match failed at index 78840
  Continuing at 78857
Creating constant: t27: i8 = TargetConstant<1>
  Morphed node: t21: i32 = TEST8ri t2, TargetConstant:i8<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i8,ch = CopyFromReg t0, Register:i8 %1

ISEL: Starting selection on root node: t8: ch = BasicBlock<while.body7 0x773ff98>

ISEL: Starting selection on root node: t6: ch = BasicBlock<while.end 0x7740060>

ISEL: Starting selection on root node: t1: i8 = Register %1

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.6 'quick_sort:land.end'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
      t2: i8,ch = CopyFromReg t0, Register:i8 %1
    t21: i32 = TEST8ri t2, TargetConstant:i8<1>
  t26: ch,glue = CopyToReg t0, Register:i32 $eflags, t21
    t24: ch = JE_1 BasicBlock:ch<while.end 0x7740060>, t26, t26:1
  t9: ch = JMP_1 BasicBlock:ch<while.body7 0x773ff98>, t24


********** List Scheduling %bb.6 'land.end' **********
SU(0): t9: ch = JMP_1 BasicBlock:ch<while.body7 0x773ff98>, t24

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t24: ch = JE_1 BasicBlock:ch<while.end 0x7740060>, t26, t26:1

    t26: ch,glue = CopyToReg t0, Register:i32 $eflags, t21

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t21: i32 = TEST8ri t2, TargetConstant:i8<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t2: i8,ch = CopyFromReg t0, Register:i8 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t9: ch = JMP_1 BasicBlock:ch<while.body7 0x773ff98>, t24


*** Scheduling [0]: SU(0): t9: ch = JMP_1 BasicBlock:ch<while.body7 0x773ff98>, t24


Examining Available:
Height 1: SU(1): t24: ch = JE_1 BasicBlock:ch<while.end 0x7740060>, t26, t26:1

    t26: ch,glue = CopyToReg t0, Register:i32 $eflags, t21


*** Scheduling [1]: SU(1): t24: ch = JE_1 BasicBlock:ch<while.end 0x7740060>, t26, t26:1

    t26: ch,glue = CopyToReg t0, Register:i32 $eflags, t21


Examining Available:
Height 2: SU(2): t21: i32 = TEST8ri t2, TargetConstant:i8<1>


*** Scheduling [2]: SU(2): t21: i32 = TEST8ri t2, TargetConstant:i8<1>


Examining Available:
Height 3: SU(3): t2: i8,ch = CopyFromReg t0, Register:i8 %1


*** Scheduling [3]: SU(3): t2: i8,ch = CopyFromReg t0, Register:i8 %1

*** Final schedule ***
SU(3): t2: i8,ch = CopyFromReg t0, Register:i8 %1

SU(2): t21: i32 = TEST8ri t2, TargetConstant:i8<1>

SU(1): t24: ch = JE_1 BasicBlock:ch<while.end 0x7740060>, t26, t26:1

    t26: ch,glue = CopyToReg t0, Register:i32 $eflags, t21

SU(0): t9: ch = JMP_1 BasicBlock:ch<while.body7 0x773ff98>, t24


Total amount of phi nodes to update: 0
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Creating new node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Creating new node: t8: i1 = setcc t4, t6, setlt:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch<if.end 0x77401f0>
Creating new node: t14: ch = br t12, BasicBlock:ch<if.then9 0x7740128>
Initial selection DAG: %bb.8 'quick_sort:while.end'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
  t2: i64 = Constant<0>
          t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
          t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
        t8: i1 = setcc t4, t6, setlt:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch<if.end 0x77401f0>
  t14: ch = br t12, BasicBlock:ch<if.then9 0x7740128>



Combining: t14: ch = br t12, BasicBlock:ch<if.then9 0x7740128>

Combining: t13: ch = BasicBlock<if.then9 0x7740128>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch<if.end 0x77401f0>
Creating new node: t16: i1 = setcc t4, t6, setge:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch<if.end 0x77401f0>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch<if.end 0x77401f0>

Combining: t14: ch = br t17, BasicBlock:ch<if.then9 0x7740128>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch<if.end 0x77401f0>

Combining: t16: i1 = setcc t4, t6, setge:ch

Combining: t15: ch = setge

Combining: t11: ch = BasicBlock<if.end 0x77401f0>

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Combining: t5: i64 = FrameIndex<3>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.8 'quick_sort:while.end'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t16: i1 = setcc t4, t6, setge:ch
    t17: ch = brcond t0, t16, BasicBlock:ch<if.end 0x77401f0>
  t14: ch = br t17, BasicBlock:ch<if.then9 0x7740128>


Legalizing node: t15: ch = setge
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = setge

Legalizing node: t13: ch = BasicBlock<if.then9 0x7740128>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock<if.then9 0x7740128>

Legalizing node: t11: ch = BasicBlock<if.end 0x77401f0>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock<if.end 0x77401f0>

Legalizing node: t5: i64 = FrameIndex<3>
Analyzing result type: i64
Legal result type
Legally typed node: t5: i64 = FrameIndex<3>

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<2>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Legalizing node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t5: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Legalizing node: t16: i1 = setcc t4, t6, setge:ch
Analyzing result type: i1
Promote integer result: t16: i1 = setcc t4, t6, setge:ch

Creating new node: t18: i8 = setcc t4, t6, setge:ch
Legalizing node: t17: ch = brcond t0, t16, BasicBlock:ch<if.end 0x77401f0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t16: i1 = setcc t4, t6, setge:ch
Promote integer operand: t17: ch = brcond t0, t16, BasicBlock:ch<if.end 0x77401f0>

Creating new node: t19: i8 = zero_extend t16
Legalizing node: t19: i8 = zero_extend t16
Analyzing result type: i8
Legal result type
Analyzing operand: t16: i1 = setcc t4, t6, setge:ch
Promote integer operand: t19: i8 = zero_extend t16

Creating constant: t20: i8 = Constant<1>
Creating new node: t21: i8 = and t18, Constant:i8<1>
Legalizing node: t20: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t20: i8 = Constant<1>

Legalizing node: t18: i8 = setcc t4, t6, setge:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t15: ch = setge
Legal operand
Legally typed node: t18: i8 = setcc t4, t6, setge:ch

Legalizing node: t21: i8 = and t18, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t18: i8 = setcc t4, t6, setge:ch
Legal operand
Analyzing operand: t20: i8 = Constant<1>
Legal operand
Legally typed node: t21: i8 = and t18, Constant:i8<1>

Legalizing node: t17: ch = brcond t0, t21, BasicBlock:ch<if.end 0x77401f0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t21: i8 = and t18, Constant:i8<1>
Legal operand
Analyzing operand: t11: ch = BasicBlock<if.end 0x77401f0>
Legal operand
Legally typed node: t17: ch = brcond t0, t21, BasicBlock:ch<if.end 0x77401f0>

Legalizing node: t14: ch = br t17, BasicBlock:ch<if.then9 0x7740128>
Analyzing result type: ch
Legal result type
Analyzing operand: t17: ch = brcond t0, t21, BasicBlock:ch<if.end 0x77401f0>
Legal operand
Analyzing operand: t13: ch = BasicBlock<if.then9 0x7740128>
Legal operand
Legally typed node: t14: ch = br t17, BasicBlock:ch<if.then9 0x7740128>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t17, BasicBlock:ch<if.then9 0x7740128>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.8 'quick_sort:while.end'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
          t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
          t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
        t18: i8 = setcc t4, t6, setge:ch
      t21: i8 = and t18, Constant:i8<1>
    t17: ch = brcond t0, t21, BasicBlock:ch<if.end 0x77401f0>
  t14: ch = br t17, BasicBlock:ch<if.then9 0x7740128>



Combining: t21: i8 = and t18, Constant:i8<1>

Replacing.2 t21: i8 = and t18, Constant:i8<1>

With: t18: i8 = setcc t4, t6, setge:ch


Combining: t18: i8 = setcc t4, t6, setge:ch

Combining: t17: ch = brcond t0, t18, BasicBlock:ch<if.end 0x77401f0>

Combining: t15: ch = setge

Combining: t14: ch = br t17, BasicBlock:ch<if.then9 0x7740128>

Combining: t13: ch = BasicBlock<if.then9 0x7740128>

Combining: t11: ch = BasicBlock<if.end 0x77401f0>

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Combining: t5: i64 = FrameIndex<3>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.8 'quick_sort:while.end'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t18: i8 = setcc t4, t6, setge:ch
    t17: ch = brcond t0, t18, BasicBlock:ch<if.end 0x77401f0>
  t14: ch = br t17, BasicBlock:ch<if.then9 0x7740128>



Legalizing: t14: ch = br t17, BasicBlock:ch<if.then9 0x7740128>
Legal node: nothing to do

Legalizing: t17: ch = brcond t0, t18, BasicBlock:ch<if.end 0x77401f0>
Trying custom legalization
Creating new node: t22: i32,i32 = X86ISD::SUB t4, t6
Creating constant: t23: i8 = Constant<6>
Creating new node: t24: i8 = X86ISD::SETCC Constant:i8<6>, t22:1
Creating new node: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end 0x77401f0>, Constant:i8<6>, t22:1
Successfully custom legalized node
 ... replacing: t17: ch = brcond t0, t18, BasicBlock:ch<if.end 0x77401f0>
     with:      t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end 0x77401f0>, Constant:i8<6>, t22:1

Legalizing: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Legalizing: t13: ch = BasicBlock<if.then9 0x7740128>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock<if.end 0x77401f0>
Legal node: nothing to do

Legalizing: t5: i64 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end 0x77401f0>, Constant:i8<6>, t22:1
Legal node: nothing to do

Legalizing: t23: i8 = Constant<6>
Legal node: nothing to do

Legalizing: t22: i32,i32 = X86ISD::SUB t4, t6
Legal node: nothing to do
Legalized selection DAG: %bb.8 'quick_sort:while.end'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t22: i32,i32 = X86ISD::SUB t4, t6
    t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end 0x77401f0>, Constant:i8<6>, t22:1
  t14: ch = br t25, BasicBlock:ch<if.then9 0x7740128>



Legalizing: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end 0x77401f0>, Constant:i8<6>, t22:1
Legal node: nothing to do

Combining: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end 0x77401f0>, Constant:i8<6>, t22:1

Legalizing: t23: i8 = Constant<6>
Legal node: nothing to do

Combining: t23: i8 = Constant<6>

Legalizing: t22: i32,i32 = X86ISD::SUB t4, t6
Legal node: nothing to do

Combining: t22: i32,i32 = X86ISD::SUB t4, t6

Legalizing: t14: ch = br t25, BasicBlock:ch<if.then9 0x7740128>
Legal node: nothing to do

Combining: t14: ch = br t25, BasicBlock:ch<if.then9 0x7740128>

Legalizing: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Legalizing: t13: ch = BasicBlock<if.then9 0x7740128>
Legal node: nothing to do

Combining: t13: ch = BasicBlock<if.then9 0x7740128>

Legalizing: t11: ch = BasicBlock<if.end 0x77401f0>
Legal node: nothing to do

Combining: t11: ch = BasicBlock<if.end 0x77401f0>

Legalizing: t5: i64 = FrameIndex<3>
Legal node: nothing to do

Combining: t5: i64 = FrameIndex<3>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<2>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.8 'quick_sort:while.end'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t22: i32,i32 = X86ISD::SUB t4, t6
    t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end 0x77401f0>, Constant:i8<6>, t22:1
  t14: ch = br t25, BasicBlock:ch<if.then9 0x7740128>


===== Instruction selection begins: %bb.8 'while.end'

ISEL: Starting selection on root node: t14: ch = br t25, BasicBlock:ch<if.then9 0x7740128>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t14: ch = JMP_1 BasicBlock:ch<if.then9 0x7740128>, t25
ISEL: Match complete!

ISEL: Starting selection on root node: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end 0x77401f0>, Constant:i8<6>, t22:1
ISEL: Starting pattern match
  Initial Opcode index to 150935
  Skipped scope entry (due to false predicate) at index 150944, continuing at 150957
  Skipped scope entry (due to false predicate) at index 150958, continuing at 150971
  Skipped scope entry (due to false predicate) at index 150972, continuing at 150985
  Skipped scope entry (due to false predicate) at index 150986, continuing at 150999
  Skipped scope entry (due to false predicate) at index 151000, continuing at 151013
  Skipped scope entry (due to false predicate) at index 151014, continuing at 151027
  Skipped scope entry (due to false predicate) at index 151028, continuing at 151041
  Skipped scope entry (due to false predicate) at index 151042, continuing at 151055
  Skipped scope entry (due to false predicate) at index 151056, continuing at 151069
  Skipped scope entry (due to false predicate) at index 151070, continuing at 151083
  Skipped scope entry (due to false predicate) at index 151084, continuing at 151097
  Skipped scope entry (due to false predicate) at index 151098, continuing at 151111
  Skipped scope entry (due to false predicate) at index 151112, continuing at 151125
Creating new node: t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1
  Morphed node: t25: ch = JGE_1 BasicBlock:ch<if.end 0x77401f0>, t27, t27:1
ISEL: Match complete!

ISEL: Starting selection on root node: t22: i32,i32 = X86ISD::SUB t4, t6
ISEL: Starting pattern match
  Initial Opcode index to 119640
  Match failed at index 119649
  Continuing at 119747
  Match failed at index 119748
  Continuing at 119793
  Skipped scope entry (due to false predicate) at index 119803, continuing at 119884
  Match failed at index 119888
  Continuing at 119902
  Match failed at index 119906
  Continuing at 119920
  Match failed at index 119926
  Continuing at 119938
  Match failed at index 119939
  Continuing at 119958
  Match failed at index 119959
  Continuing at 119978
  Continuing at 119979
  Match failed at index 119980
  Continuing at 119991
  Match failed at index 119992
  Continuing at 120003
  Morphed node: t22: i32,i32 = SUB32rr t4, t6
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t30: i8 = TargetConstant<1>
Creating constant: t31: i32 = TargetConstant<0>
  Morphed node: t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = BasicBlock<if.then9 0x7740128>

ISEL: Starting selection on root node: t11: ch = BasicBlock<if.end 0x77401f0>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.8 'quick_sort:while.end'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
      t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
      t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
    t22: i32,i32 = SUB32rr t4, t6
  t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1
    t25: ch = JGE_1 BasicBlock:ch<if.end 0x77401f0>, t27, t27:1
  t14: ch = JMP_1 BasicBlock:ch<if.then9 0x7740128>, t25


********** List Scheduling %bb.8 'while.end' **********
SU(0): t14: ch = JMP_1 BasicBlock:ch<if.then9 0x7740128>, t25

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t25: ch = JGE_1 BasicBlock:ch<if.end 0x77401f0>, t27, t27:1

    t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t22: i32,i32 = SUB32rr t4, t6

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1
SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMP_1 BasicBlock:ch<if.then9 0x7740128>, t25


*** Scheduling [0]: SU(0): t14: ch = JMP_1 BasicBlock:ch<if.then9 0x7740128>, t25


Examining Available:
Height 1: SU(1): t25: ch = JGE_1 BasicBlock:ch<if.end 0x77401f0>, t27, t27:1

    t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1


*** Scheduling [1]: SU(1): t25: ch = JGE_1 BasicBlock:ch<if.end 0x77401f0>, t27, t27:1

    t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1


Examining Available:
Height 2: SU(2): t22: i32,i32 = SUB32rr t4, t6


*** Scheduling [2]: SU(2): t22: i32,i32 = SUB32rr t4, t6


Examining Available:
Height 3: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [3]: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


Examining Available:
Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [4]: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(2): t22: i32,i32 = SUB32rr t4, t6

SU(1): t25: ch = JGE_1 BasicBlock:ch<if.end 0x77401f0>, t27, t27:1

    t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1

SU(0): t14: ch = JMP_1 BasicBlock:ch<if.then9 0x7740128>, t25


Total amount of phi nodes to update: 0
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Creating new node: t5: i64 = sign_extend t4
Creating constant: t7: i64 = Constant<2>
Creating new node: t8: i64 = shl t5, Constant:i64<2>
Creating new node: t9: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t8
Creating new node: t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t9, undef:i64
Creating new node: t12: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Creating constant: t13: i32 = Constant<1>
Creating new node: t14: i32 = add nsw t12, Constant:i32<1>
Creating new node: t15: ch = TokenFactor t4:1, t10:1, t12:1
Creating new node: t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64
Creating new node: t17: i64 = sign_extend t12
Creating new node: t18: i64 = shl t17, Constant:i64<2>
Creating new node: t19: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t18
Creating new node: t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t19, undef:i64
Creating new node: t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>
Initial selection DAG: %bb.9 'quick_sort:if.then9'
SelectionDAG has 23 nodes:
  t0: ch = EntryToken
  t2: i64 = Constant<0>
  t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
        t5: i64 = sign_extend t4
      t8: i64 = shl t5, Constant:i64<2>
    t9: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t8
  t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t9, undef:i64
  t12: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t15: ch = TokenFactor t4:1, t10:1, t12:1
        t14: i32 = add nsw t12, Constant:i32<1>
      t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64
          t17: i64 = sign_extend t12
        t18: i64 = shl t17, Constant:i64<2>
      t19: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t18
    t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t19, undef:i64
  t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>



Combining: t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>

Combining: t21: ch = BasicBlock<if.end 0x77401f0>

Combining: t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t19, undef:i64

Combining: t19: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t18
Creating new node: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0
 ... into: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t23, undef:i64

Combining: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t18: i64 = shl t17, Constant:i64<2>

Combining: t17: i64 = sign_extend t12
Creating new node: t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Replacing.1 t17: i64 = sign_extend t12

With: t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
 and 0 other values
Creating new node: t25: i32 = truncate t24

Replacing.1 t12: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

With: t25: i32 = truncate t24
 and 1 other values

Combining: t25: i32 = truncate t24

Combining: t18: i64 = shl t24, Constant:i64<2>

Combining: t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Combining: t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64

Combining: t15: ch = TokenFactor t4:1, t10:1, t24:1

Combining: t14: i32 = add nsw t25, Constant:i32<1>

Combining: t13: i32 = Constant<1>

Combining: t11: i64 = FrameIndex<2>

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t9, undef:i64

Combining: t9: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t8
Creating new node: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
 ... into: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64

Combining: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t8: i64 = shl t5, Constant:i64<2>

Combining: t7: i64 = Constant<2>

Combining: t6: i64 = GlobalAddress<[100 x i32]* @s> 0

Combining: t5: i64 = sign_extend t4
Creating new node: t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Replacing.1 t5: i64 = sign_extend t4

With: t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
 and 0 other values

Combining: t8: i64 = shl t27, Constant:i64<2>

Combining: t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<3>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.9 'quick_sort:if.then9'
SelectionDAG has 21 nodes:
  t0: ch = EntryToken
      t8: i64 = shl t27, Constant:i64<2>
    t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
  t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64
  t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
  t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
        t15: ch = TokenFactor t27:1, t10:1, t24:1
          t25: i32 = truncate t24
        t14: i32 = add nsw t25, Constant:i32<1>
      t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64
        t18: i64 = shl t24, Constant:i64<2>
      t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0
    t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t23, undef:i64
  t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>


Legalizing node: t21: ch = BasicBlock<if.end 0x77401f0>
Analyzing result type: ch
Legal result type
Legally typed node: t21: ch = BasicBlock<if.end 0x77401f0>

Legalizing node: t13: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t13: i32 = Constant<1>

Legalizing node: t11: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t11: i64 = FrameIndex<2>

Legalizing node: t7: i64 = Constant<2>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<2>

Legalizing node: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = GlobalAddress<[100 x i32]* @s> 0

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<3>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<3>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t11: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Legalizing node: t18: i64 = shl t24, Constant:i64<2>
Analyzing result type: i64
Legal result type
Analyzing operand: t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t7: i64 = Constant<2>
Legal operand
Legally typed node: t18: i64 = shl t24, Constant:i64<2>

Legalizing node: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Analyzing operand: t18: i64 = shl t24, Constant:i64<2>
Legal operand
Analyzing operand: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Legal operand
Legally typed node: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0

Legalizing node: t25: i32 = truncate t24
Analyzing result type: i32
Legal result type
Analyzing operand: t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Legally typed node: t25: i32 = truncate t24

Legalizing node: t14: i32 = add nsw t25, Constant:i32<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t25: i32 = truncate t24
Legal operand
Analyzing operand: t13: i32 = Constant<1>
Legal operand
Legally typed node: t14: i32 = add nsw t25, Constant:i32<1>

Legalizing node: t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Legalizing node: t8: i64 = shl t27, Constant:i64<2>
Analyzing result type: i64
Legal result type
Analyzing operand: t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t7: i64 = Constant<2>
Legal operand
Legally typed node: t8: i64 = shl t27, Constant:i64<2>

Legalizing node: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Analyzing operand: t8: i64 = shl t27, Constant:i64<2>
Legal operand
Analyzing operand: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Legal operand
Legally typed node: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Legalizing node: t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64

Legalizing node: t15: ch = TokenFactor t27:1, t10:1, t24:1
Analyzing result type: ch
Legal result type
Analyzing operand: t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64
Legal operand
Analyzing operand: t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Legally typed node: t15: ch = TokenFactor t27:1, t10:1, t24:1

Legalizing node: t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = TokenFactor t27:1, t10:1, t24:1
Legal operand
Analyzing operand: t14: i32 = add nsw t25, Constant:i32<1>
Legal operand
Analyzing operand: t11: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64

Legalizing node: t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t23, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64
Legal operand
Analyzing operand: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t23, undef:i64

Legalizing node: t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t23, undef:i64
Legal operand
Analyzing operand: t21: ch = BasicBlock<if.end 0x77401f0>
Legal operand
Legally typed node: t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>

Legalizing node: t65535: ch = handlenode t22
Analyzing result type: ch
Legal result type
Analyzing operand: t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>
Legal operand
Legally typed node: t65535: ch = handlenode t22

Type-legalized selection DAG: %bb.9 'quick_sort:if.then9'
SelectionDAG has 21 nodes:
  t0: ch = EntryToken
      t8: i64 = shl t27, Constant:i64<2>
    t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
  t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64
  t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
  t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
        t15: ch = TokenFactor t27:1, t10:1, t24:1
          t25: i32 = truncate t24
        t14: i32 = add nsw t25, Constant:i32<1>
      t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64
        t18: i64 = shl t24, Constant:i64<2>
      t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0
    t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t23, undef:i64
  t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>



Legalizing: t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>
Legal node: nothing to do

Legalizing: t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t15: ch = TokenFactor t27:1, t10:1, t24:1
Legal node: nothing to do

Legalizing: t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64
Legalizing non-extending load operation

Legalizing: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t14: i32 = add nsw t25, Constant:i32<1>
Legal node: nothing to do

Legalizing: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t18: i64 = shl t24, Constant:i64<2>
Creating constant: t28: i8 = Constant<2>
Legal node: nothing to do

Legalizing: t25: i32 = truncate t24
Legal node: nothing to do

Legalizing: t8: i64 = shl t27, Constant:i64<2>
Legal node: nothing to do

Legalizing: t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legalizing extending load operation

Legalizing: t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Legalizing extending load operation

Legalizing: t21: ch = BasicBlock<if.end 0x77401f0>
Legal node: nothing to do

Legalizing: t13: i32 = Constant<1>
Legal node: nothing to do

Legalizing: t11: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Trying custom legalization
Creating new node: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Successfully custom legalized node
 ... replacing: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
     with:      t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t29: i64 = TargetGlobalAddress<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t28: i8 = Constant<2>
Legal node: nothing to do
Legalized selection DAG: %bb.9 'quick_sort:if.then9'
SelectionDAG has 22 nodes:
  t0: ch = EntryToken
  t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
  t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
      t8: i64 = shl t27, Constant:i8<2>
    t26: i64 = add t8, t30
  t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64
  t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
        t15: ch = TokenFactor t27:1, t10:1, t24:1
          t25: i32 = truncate t24
        t14: i32 = add nsw t25, Constant:i32<1>
      t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64
        t18: i64 = shl t24, Constant:i8<2>
      t23: i64 = add t18, t30
    t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t23, undef:i64
  t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>



Legalizing: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Combining: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0

Legalizing: t29: i64 = TargetGlobalAddress<[100 x i32]* @s> 0
Legal node: nothing to do

Combining: t29: i64 = TargetGlobalAddress<[100 x i32]* @s> 0

Legalizing: t28: i8 = Constant<2>
Legal node: nothing to do

Combining: t28: i8 = Constant<2>

Legalizing: t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>
Legal node: nothing to do

Combining: t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>

Legalizing: t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t23, undef:i64

Legalizing: t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64

Legalizing: t15: ch = TokenFactor t27:1, t10:1, t24:1
Legal node: nothing to do

Combining: t15: ch = TokenFactor t27:1, t10:1, t24:1

Legalizing: t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64
Legalizing non-extending load operation

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64

Legalizing: t23: i64 = add t18, t30
Legal node: nothing to do

Combining: t23: i64 = add t18, t30

Legalizing: t14: i32 = add nsw t25, Constant:i32<1>
Legal node: nothing to do

Combining: t14: i32 = add nsw t25, Constant:i32<1>

Legalizing: t26: i64 = add t8, t30
Legal node: nothing to do

Combining: t26: i64 = add t8, t30

Legalizing: t18: i64 = shl t24, Constant:i8<2>
Legal node: nothing to do

Combining: t18: i64 = shl t24, Constant:i8<2>

Legalizing: t25: i32 = truncate t24
Legal node: nothing to do

Combining: t25: i32 = truncate t24

Legalizing: t8: i64 = shl t27, Constant:i8<2>
Legal node: nothing to do

Combining: t8: i64 = shl t27, Constant:i8<2>

Legalizing: t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legalizing extending load operation

Combining: t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Legalizing: t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Legalizing extending load operation

Combining: t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Legalizing: t21: ch = BasicBlock<if.end 0x77401f0>
Legal node: nothing to do

Combining: t21: ch = BasicBlock<if.end 0x77401f0>

Legalizing: t13: i32 = Constant<1>
Legal node: nothing to do

Combining: t13: i32 = Constant<1>

Legalizing: t11: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t11: i64 = FrameIndex<2>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<3>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.9 'quick_sort:if.then9'
SelectionDAG has 22 nodes:
  t0: ch = EntryToken
  t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
  t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
      t8: i64 = shl t27, Constant:i8<2>
    t26: i64 = add t8, t30
  t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64
  t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
        t15: ch = TokenFactor t27:1, t10:1, t24:1
          t25: i32 = truncate t24
        t14: i32 = add nsw t25, Constant:i32<1>
      t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64
        t18: i64 = shl t24, Constant:i8<2>
      t23: i64 = add t18, t30
    t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t23, undef:i64
  t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>


===== Instruction selection begins: %bb.9 'if.then9'

ISEL: Starting selection on root node: t22: ch = br t20, BasicBlock:ch<if.end 0x77401f0>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t22: ch = JMP_1 BasicBlock:ch<if.end 0x77401f0>, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: ch = store<(store 4 into %ir.arrayidx13)> t16, t10, t23, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  Match failed at index 1029
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 4
IndexReg t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t32: i8 = TargetConstant<4>
  Morphed node: t20: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx13)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10, t16
ISEL: Match complete!

ISEL: Starting selection on root node: t16: ch = store<(store 4 into %ir.i)> t15, t14, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  OpcodeSwitch from 1029 to 5817
  Match failed at index 5821
  Continuing at 6606
  Match failed at index 6616
  Continuing at 6659
  Match failed at index 6664
  Continuing at 6707
  Match failed at index 6712
  Continuing at 6755
  Continuing at 6756
  Match failed at index 6759
  Continuing at 6886
  Match failed at index 6890
  Continuing at 7016
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t36: i8 = TargetConstant<1>
Creating constant: t37: i32 = TargetConstant<0>
  Morphed node: t16: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t14, t15
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch = TokenFactor t27:1, t10:1, t24:1

ISEL: Starting selection on root node: t10: i32,ch = load<(load 4 from %ir.arrayidx11)> t0, t26, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 4
IndexReg t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx11)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t14: i32 = add nsw t25, Constant:i32<1>
ISEL: Starting pattern match
  Initial Opcode index to 17918
  Skipped scope entry (due to false predicate) at index 17924, continuing at 17944
  Match failed at index 17946
  Continuing at 18049
  Continuing at 18050
  Match failed at index 18053
  Continuing at 18230
  Match failed at index 18233
  Continuing at 18300
  TypeSwitch[i32] from 18302 to 18305
  Skipped scope entry (due to false predicate) at index 18307, continuing at 18323
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg t25: i32 = truncate t24
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Match failed at index 18326
  Continuing at 18340
  Continuing at 18358
  Match failed at index 18361
  Continuing at 18382
  Match failed at index 18384
  Continuing at 18406
  TypeSwitch[i32] from 18413 to 18440
  Match failed at index 18440
  Continuing at 18463
  Match failed at index 18464
  Continuing at 18525
  Match failed at index 18526
  Continuing at 18600
  Match failed at index 18601
  Continuing at 18630
  Match failed at index 18644
  Continuing at 18657
Creating constant: t38: i32 = TargetConstant<1>
  Morphed node: t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t25: i32 = truncate t24
ISEL: Starting pattern match
  Initial Opcode index to 145104
  Match failed at index 145108
  Continuing at 145249
  TypeSwitch[i32] from 145252 to 145287
Creating constant: t39: i32 = TargetConstant<6>
  Morphed node: t25: i32 = EXTRACT_SUBREG t24, TargetConstant:i32<6>
ISEL: Match complete!

ISEL: Starting selection on root node: t24: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Skipped scope entry (due to false predicate) at index 137189, continuing at 137208
  Skipped scope entry (due to false predicate) at index 137209, continuing at 137228
  Skipped scope entry (due to false predicate) at index 137229, continuing at 137248
  Skipped scope entry (due to false predicate) at index 137249, continuing at 137268
  Match failed at index 137271
  Continuing at 137311
  Match failed at index 137312
  Continuing at 137354
  Skipped scope entry (due to false predicate) at index 137361, continuing at 137378
  Skipped scope entry (due to false predicate) at index 137379, continuing at 137396
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t27: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Skipped scope entry (due to false predicate) at index 137189, continuing at 137208
  Skipped scope entry (due to false predicate) at index 137209, continuing at 137228
  Skipped scope entry (due to false predicate) at index 137229, continuing at 137248
  Skipped scope entry (due to false predicate) at index 137249, continuing at 137268
  Match failed at index 137271
  Continuing at 137311
  Match failed at index 137312
  Continuing at 137354
  Skipped scope entry (due to false predicate) at index 137361, continuing at 137378
  Skipped scope entry (due to false predicate) at index 137379, continuing at 137396
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t27: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = BasicBlock<if.end 0x77401f0>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.9 'quick_sort:if.then9'
SelectionDAG has 21 nodes:
  t0: ch = EntryToken
  t27: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
  t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
  t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx11)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0
          t25: i32 = EXTRACT_SUBREG t24, TargetConstant:i32<6>
        t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<1>
        t15: ch = TokenFactor t27:1, t10:1, t24:1
      t16: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t14, t15
    t20: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx13)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10, t16
  t22: ch = JMP_1 BasicBlock:ch<if.end 0x77401f0>, t20


********** List Scheduling %bb.9 'if.then9' **********
SU(0): t22: ch = JMP_1 BasicBlock:ch<if.end 0x77401f0>, t20

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t20: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx13)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10, t16

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(8): Data Latency=1
    SU(7): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t16: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t14, t15

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Ord  Latency=0 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(3): t15: ch = TokenFactor t27:1, t10:1, t24:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(4): Ord  Latency=1 Barrier
    SU(7): Ord  Latency=1 Barrier
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(2): Ord  Latency=0 Barrier
SU(4): t27: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
SU(5): t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(6): t25: i32 = EXTRACT_SUBREG t24, TargetConstant:i32<6>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(8): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx11)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
SU(8): t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
    SU(6): Data Latency=1

Examining Available:
Height 0: SU(0): t22: ch = JMP_1 BasicBlock:ch<if.end 0x77401f0>, t20


*** Scheduling [0]: SU(0): t22: ch = JMP_1 BasicBlock:ch<if.end 0x77401f0>, t20


Examining Available:
Height 1: SU(1): t20: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx13)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10, t16


*** Scheduling [1]: SU(1): t20: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx13)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10, t16


Examining Available:
Height 2: SU(2): t16: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t14, t15


*** Scheduling [2]: SU(2): t16: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t14, t15


Examining Available:
Height 2: SU(3): t15: ch = TokenFactor t27:1, t10:1, t24:1

Height 3: SU(5): t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<1>


*** Scheduling [3]: SU(3): t15: ch = TokenFactor t27:1, t10:1, t24:1


Examining Available:
Height 3: SU(5): t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<1>

Height 4: SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx11)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


*** Scheduling [4]: SU(5): t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<1>


Examining Available:
Height 5: SU(6): t25: i32 = EXTRACT_SUBREG t24, TargetConstant:i32<6>

Height 4: SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx11)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


*** Scheduling [5]: SU(6): t25: i32 = EXTRACT_SUBREG t24, TargetConstant:i32<6>


Examining Available:
Height 6: SU(8): t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 4: SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx11)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


*** Scheduling [6]: SU(8): t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


Examining Available:
Height 4: SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx11)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


*** Scheduling [7]: SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx11)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


Examining Available:
Height 8: SU(4): t27: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [8]: SU(4): t27: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(4): t27: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx11)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0

SU(8): t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(6): t25: i32 = EXTRACT_SUBREG t24, TargetConstant:i32<6>

SU(5): t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<1>

SU(3): t15: ch = TokenFactor t27:1, t10:1, t24:1

SU(2): t16: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t14, t15

SU(1): t20: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx13)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10, t16

SU(0): t22: ch = JMP_1 BasicBlock:ch<if.end 0x77401f0>, t20


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>
Initial selection DAG: %bb.10 'quick_sort:if.end'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>



Combining: t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>

Combining: t1: ch = BasicBlock<while.cond14 0x77402b8>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.10 'quick_sort:if.end'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>


Legalizing node: t1: ch = BasicBlock<while.cond14 0x77402b8>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock<while.cond14 0x77402b8>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock<while.cond14 0x77402b8>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.10 'quick_sort:if.end'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>



Legalizing: t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock<while.cond14 0x77402b8>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.10 'quick_sort:if.end'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>



Legalizing: t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>

Legalizing: t1: ch = BasicBlock<while.cond14 0x77402b8>
Legal node: nothing to do

Combining: t1: ch = BasicBlock<while.cond14 0x77402b8>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.10 'quick_sort:if.end'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>


===== Instruction selection begins: %bb.10 'if.end'

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch<while.cond14 0x77402b8>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t2: ch = JMP_1 BasicBlock:ch<while.cond14 0x77402b8>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock<while.cond14 0x77402b8>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.10 'quick_sort:if.end'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = JMP_1 BasicBlock:ch<while.cond14 0x77402b8>, t0


********** List Scheduling %bb.10 'if.end' **********
SU(0): t2: ch = JMP_1 BasicBlock:ch<while.cond14 0x77402b8>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMP_1 BasicBlock:ch<while.cond14 0x77402b8>, t0


*** Scheduling [0]: SU(0): t2: ch = JMP_1 BasicBlock:ch<while.cond14 0x77402b8>, t0

*** Final schedule ***
SU(0): t2: ch = JMP_1 BasicBlock:ch<while.cond14 0x77402b8>, t0


Total amount of phi nodes to update: 0
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Creating new node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Creating new node: t8: i1 = setcc t4, t6, setlt:ch
Creating constant: t9: i1 = Constant<0>
Creating constant: t10: i8 = Constant<0>
Creating new node: t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>
Creating constant: t13: i1 = Constant<-1>
Creating new node: t14: i1 = xor t8, Constant:i1<-1>
Creating new node: t16: ch = brcond t12, t14, BasicBlock:ch<land.end20 0x7740448>
Creating new node: t18: ch = br t16, BasicBlock:ch<land.rhs16 0x7740380>
Initial selection DAG: %bb.11 'quick_sort:while.cond14'
SelectionDAG has 19 nodes:
  t0: ch = EntryToken
  t2: i64 = Constant<0>
  t9: i1 = Constant<0>
      t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>
          t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
          t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
        t8: i1 = setcc t4, t6, setlt:ch
      t14: i1 = xor t8, Constant:i1<-1>
    t16: ch = brcond t12, t14, BasicBlock:ch<land.end20 0x7740448>
  t18: ch = br t16, BasicBlock:ch<land.rhs16 0x7740380>



Combining: t18: ch = br t16, BasicBlock:ch<land.rhs16 0x7740380>

Combining: t17: ch = BasicBlock<land.rhs16 0x7740380>

Combining: t16: ch = brcond t12, t14, BasicBlock:ch<land.end20 0x7740448>
Creating new node: t20: i1 = setcc t4, t6, setge:ch
Creating new node: t21: ch = brcond t12, t20, BasicBlock:ch<land.end20 0x7740448>
 ... into: t21: ch = brcond t12, t20, BasicBlock:ch<land.end20 0x7740448>

Combining: t18: ch = br t21, BasicBlock:ch<land.rhs16 0x7740380>

Combining: t21: ch = brcond t12, t20, BasicBlock:ch<land.end20 0x7740448>

Combining: t20: i1 = setcc t4, t6, setge:ch

Combining: t19: ch = setge

Combining: t15: ch = BasicBlock<land.end20 0x7740448>

Combining: t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>

Combining: t11: i8 = Register %41

Combining: t10: i8 = Constant<0>

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Combining: t5: i64 = FrameIndex<3>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.11 'quick_sort:while.cond14'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
      t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t20: i1 = setcc t4, t6, setge:ch
    t21: ch = brcond t12, t20, BasicBlock:ch<land.end20 0x7740448>
  t18: ch = br t21, BasicBlock:ch<land.rhs16 0x7740380>


Legalizing node: t19: ch = setge
Analyzing result type: ch
Legal result type
Legally typed node: t19: ch = setge

Legalizing node: t17: ch = BasicBlock<land.rhs16 0x7740380>
Analyzing result type: ch
Legal result type
Legally typed node: t17: ch = BasicBlock<land.rhs16 0x7740380>

Legalizing node: t15: ch = BasicBlock<land.end20 0x7740448>
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = BasicBlock<land.end20 0x7740448>

Legalizing node: t11: i8 = Register %41
Ignoring node results
Legally typed node: t11: i8 = Register %41

Legalizing node: t10: i8 = Constant<0>
Analyzing result type: i8
Legal result type
Legally typed node: t10: i8 = Constant<0>

Legalizing node: t5: i64 = FrameIndex<3>
Analyzing result type: i64
Legal result type
Legally typed node: t5: i64 = FrameIndex<3>

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<2>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Legalizing node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t5: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Legalizing node: t20: i1 = setcc t4, t6, setge:ch
Analyzing result type: i1
Promote integer result: t20: i1 = setcc t4, t6, setge:ch

Creating new node: t22: i8 = setcc t4, t6, setge:ch
Legalizing node: t22: i8 = setcc t4, t6, setge:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t19: ch = setge
Legal operand
Legally typed node: t22: i8 = setcc t4, t6, setge:ch

Legalizing node: t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t10: i8 = Constant<0>
Legal operand
Legally typed node: t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>

Legalizing node: t21: ch = brcond t12, t20, BasicBlock:ch<land.end20 0x7740448>
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>
Legal operand
Analyzing operand: t20: i1 = setcc t4, t6, setge:ch
Promote integer operand: t21: ch = brcond t12, t20, BasicBlock:ch<land.end20 0x7740448>

Creating new node: t23: i8 = zero_extend t20
Legalizing node: t23: i8 = zero_extend t20
Analyzing result type: i8
Legal result type
Analyzing operand: t20: i1 = setcc t4, t6, setge:ch
Promote integer operand: t23: i8 = zero_extend t20

Creating constant: t24: i8 = Constant<1>
Creating new node: t25: i8 = and t22, Constant:i8<1>
Legalizing node: t24: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t24: i8 = Constant<1>

Legalizing node: t25: i8 = and t22, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t22: i8 = setcc t4, t6, setge:ch
Legal operand
Analyzing operand: t24: i8 = Constant<1>
Legal operand
Legally typed node: t25: i8 = and t22, Constant:i8<1>

Legalizing node: t21: ch = brcond t12, t25, BasicBlock:ch<land.end20 0x7740448>
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>
Legal operand
Analyzing operand: t25: i8 = and t22, Constant:i8<1>
Legal operand
Analyzing operand: t15: ch = BasicBlock<land.end20 0x7740448>
Legal operand
Legally typed node: t21: ch = brcond t12, t25, BasicBlock:ch<land.end20 0x7740448>

Legalizing node: t18: ch = br t21, BasicBlock:ch<land.rhs16 0x7740380>
Analyzing result type: ch
Legal result type
Analyzing operand: t21: ch = brcond t12, t25, BasicBlock:ch<land.end20 0x7740448>
Legal operand
Analyzing operand: t17: ch = BasicBlock<land.rhs16 0x7740380>
Legal operand
Legally typed node: t18: ch = br t21, BasicBlock:ch<land.rhs16 0x7740380>

Legalizing node: t65535: ch = handlenode t18
Analyzing result type: ch
Legal result type
Analyzing operand: t18: ch = br t21, BasicBlock:ch<land.rhs16 0x7740380>
Legal operand
Legally typed node: t65535: ch = handlenode t18

Type-legalized selection DAG: %bb.11 'quick_sort:while.cond14'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
      t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>
          t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
          t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
        t22: i8 = setcc t4, t6, setge:ch
      t25: i8 = and t22, Constant:i8<1>
    t21: ch = brcond t12, t25, BasicBlock:ch<land.end20 0x7740448>
  t18: ch = br t21, BasicBlock:ch<land.rhs16 0x7740380>



Combining: t25: i8 = and t22, Constant:i8<1>

Replacing.2 t25: i8 = and t22, Constant:i8<1>

With: t22: i8 = setcc t4, t6, setge:ch


Combining: t22: i8 = setcc t4, t6, setge:ch

Combining: t21: ch = brcond t12, t22, BasicBlock:ch<land.end20 0x7740448>

Combining: t19: ch = setge

Combining: t18: ch = br t21, BasicBlock:ch<land.rhs16 0x7740380>

Combining: t17: ch = BasicBlock<land.rhs16 0x7740380>

Combining: t15: ch = BasicBlock<land.end20 0x7740448>

Combining: t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>

Combining: t11: i8 = Register %41

Combining: t10: i8 = Constant<0>

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Combining: t5: i64 = FrameIndex<3>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.11 'quick_sort:while.cond14'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
      t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t22: i8 = setcc t4, t6, setge:ch
    t21: ch = brcond t12, t22, BasicBlock:ch<land.end20 0x7740448>
  t18: ch = br t21, BasicBlock:ch<land.rhs16 0x7740380>



Legalizing: t18: ch = br t21, BasicBlock:ch<land.rhs16 0x7740380>
Legal node: nothing to do

Legalizing: t21: ch = brcond t12, t22, BasicBlock:ch<land.end20 0x7740448>
Trying custom legalization
Creating new node: t26: i32,i32 = X86ISD::SUB t4, t6
Creating constant: t27: i8 = Constant<6>
Creating new node: t28: i8 = X86ISD::SETCC Constant:i8<6>, t26:1
Creating new node: t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end20 0x7740448>, Constant:i8<6>, t26:1
Successfully custom legalized node
 ... replacing: t21: ch = brcond t12, t22, BasicBlock:ch<land.end20 0x7740448>
     with:      t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end20 0x7740448>, Constant:i8<6>, t26:1

Legalizing: t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>
Legal node: nothing to do

Legalizing: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Legalizing: t17: ch = BasicBlock<land.rhs16 0x7740380>
Legal node: nothing to do

Legalizing: t15: ch = BasicBlock<land.end20 0x7740448>
Legal node: nothing to do

Legalizing: t11: i8 = Register %41

Legalizing: t10: i8 = Constant<0>
Legal node: nothing to do

Legalizing: t5: i64 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end20 0x7740448>, Constant:i8<6>, t26:1
Legal node: nothing to do

Legalizing: t27: i8 = Constant<6>
Legal node: nothing to do

Legalizing: t26: i32,i32 = X86ISD::SUB t4, t6
Legal node: nothing to do
Legalized selection DAG: %bb.11 'quick_sort:while.cond14'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
      t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t26: i32,i32 = X86ISD::SUB t4, t6
    t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end20 0x7740448>, Constant:i8<6>, t26:1
  t18: ch = br t29, BasicBlock:ch<land.rhs16 0x7740380>



Legalizing: t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end20 0x7740448>, Constant:i8<6>, t26:1
Legal node: nothing to do

Combining: t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end20 0x7740448>, Constant:i8<6>, t26:1

Legalizing: t27: i8 = Constant<6>
Legal node: nothing to do

Combining: t27: i8 = Constant<6>

Legalizing: t26: i32,i32 = X86ISD::SUB t4, t6
Legal node: nothing to do

Combining: t26: i32,i32 = X86ISD::SUB t4, t6

Legalizing: t18: ch = br t29, BasicBlock:ch<land.rhs16 0x7740380>
Legal node: nothing to do

Combining: t18: ch = br t29, BasicBlock:ch<land.rhs16 0x7740380>

Legalizing: t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>
Legal node: nothing to do

Combining: t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>

Legalizing: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Legalizing: t17: ch = BasicBlock<land.rhs16 0x7740380>
Legal node: nothing to do

Combining: t17: ch = BasicBlock<land.rhs16 0x7740380>

Legalizing: t15: ch = BasicBlock<land.end20 0x7740448>
Legal node: nothing to do

Combining: t15: ch = BasicBlock<land.end20 0x7740448>

Legalizing: t11: i8 = Register %41

Combining: t11: i8 = Register %41

Legalizing: t10: i8 = Constant<0>
Legal node: nothing to do

Combining: t10: i8 = Constant<0>

Legalizing: t5: i64 = FrameIndex<3>
Legal node: nothing to do

Combining: t5: i64 = FrameIndex<3>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<2>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.11 'quick_sort:while.cond14'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
      t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t26: i32,i32 = X86ISD::SUB t4, t6
    t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end20 0x7740448>, Constant:i8<6>, t26:1
  t18: ch = br t29, BasicBlock:ch<land.rhs16 0x7740380>


===== Instruction selection begins: %bb.11 'while.cond14'

ISEL: Starting selection on root node: t18: ch = br t29, BasicBlock:ch<land.rhs16 0x7740380>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t18: ch = JMP_1 BasicBlock:ch<land.rhs16 0x7740380>, t29
ISEL: Match complete!

ISEL: Starting selection on root node: t29: ch = X86ISD::BRCOND t12, BasicBlock:ch<land.end20 0x7740448>, Constant:i8<6>, t26:1
ISEL: Starting pattern match
  Initial Opcode index to 150935
  Skipped scope entry (due to false predicate) at index 150944, continuing at 150957
  Skipped scope entry (due to false predicate) at index 150958, continuing at 150971
  Skipped scope entry (due to false predicate) at index 150972, continuing at 150985
  Skipped scope entry (due to false predicate) at index 150986, continuing at 150999
  Skipped scope entry (due to false predicate) at index 151000, continuing at 151013
  Skipped scope entry (due to false predicate) at index 151014, continuing at 151027
  Skipped scope entry (due to false predicate) at index 151028, continuing at 151041
  Skipped scope entry (due to false predicate) at index 151042, continuing at 151055
  Skipped scope entry (due to false predicate) at index 151056, continuing at 151069
  Skipped scope entry (due to false predicate) at index 151070, continuing at 151083
  Skipped scope entry (due to false predicate) at index 151084, continuing at 151097
  Skipped scope entry (due to false predicate) at index 151098, continuing at 151111
  Skipped scope entry (due to false predicate) at index 151112, continuing at 151125
Creating new node: t31: ch,glue = CopyToReg t12, Register:i32 $eflags, t26:1
  Morphed node: t29: ch = JGE_1 BasicBlock:ch<land.end20 0x7740448>, t31, t31:1
ISEL: Match complete!

ISEL: Starting selection on root node: t26: i32,i32 = X86ISD::SUB t4, t6
ISEL: Starting pattern match
  Initial Opcode index to 119640
  Match failed at index 119649
  Continuing at 119747
  Match failed at index 119748
  Continuing at 119793
  Skipped scope entry (due to false predicate) at index 119803, continuing at 119884
  Match failed at index 119888
  Continuing at 119902
  Match failed at index 119906
  Continuing at 119920
  Match failed at index 119926
  Continuing at 119938
  Match failed at index 119939
  Continuing at 119958
  Match failed at index 119959
  Continuing at 119978
  Continuing at 119979
  Match failed at index 119980
  Continuing at 119991
  Match failed at index 119992
  Continuing at 120003
  Morphed node: t26: i32,i32 = SUB32rr t4, t6
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = CopyToReg t0, Register:i8 %41, Constant:i8<0>

ISEL: Starting selection on root node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t34: i8 = TargetConstant<1>
Creating constant: t35: i32 = TargetConstant<0>
  Morphed node: t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t17: ch = BasicBlock<land.rhs16 0x7740380>

ISEL: Starting selection on root node: t15: ch = BasicBlock<land.end20 0x7740448>

ISEL: Starting selection on root node: t11: i8 = Register %41

ISEL: Starting selection on root node: t10: i8 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 145636
  TypeSwitch[i8] from 145640 to 145652
  Created node: t38: i32,i32 = MOV32r0
Creating constant: t39: i32 = TargetConstant<1>
  Morphed node: t10: i8 = EXTRACT_SUBREG MOV32r0:i32,i32, TargetConstant:i32<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.11 'quick_sort:while.cond14'
SelectionDAG has 21 nodes:
  t0: ch = EntryToken
      t10: i8 = EXTRACT_SUBREG MOV32r0:i32,i32, TargetConstant:i32<1>
    t12: ch = CopyToReg t0, Register:i8 %41, t10
      t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
      t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
    t26: i32,i32 = SUB32rr t4, t6
  t31: ch,glue = CopyToReg t12, Register:i32 $eflags, t26:1
    t29: ch = JGE_1 BasicBlock:ch<land.end20 0x7740448>, t31, t31:1
  t18: ch = JMP_1 BasicBlock:ch<land.rhs16 0x7740380>, t29


********** List Scheduling %bb.11 'while.cond14' **********
SU(0): t18: ch = JMP_1 BasicBlock:ch<land.rhs16 0x7740380>, t29

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t29: ch = JGE_1 BasicBlock:ch<land.end20 0x7740448>, t31, t31:1

    t31: ch,glue = CopyToReg t12, Register:i32 $eflags, t26:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t26: i32,i32 = SUB32rr t4, t6

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1
SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1
SU(5): t12: ch = CopyToReg t0, Register:i8 %41, t10

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(6): t10: i8 = EXTRACT_SUBREG MOV32r0:i32,i32, TargetConstant:i32<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(7): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(7): t38: i32,i32 = MOV32r0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(6): Data Latency=1

Examining Available:
Height 0: SU(0): t18: ch = JMP_1 BasicBlock:ch<land.rhs16 0x7740380>, t29


*** Scheduling [0]: SU(0): t18: ch = JMP_1 BasicBlock:ch<land.rhs16 0x7740380>, t29


Examining Available:
Height 1: SU(1): t29: ch = JGE_1 BasicBlock:ch<land.end20 0x7740448>, t31, t31:1

    t31: ch,glue = CopyToReg t12, Register:i32 $eflags, t26:1


*** Scheduling [1]: SU(1): t29: ch = JGE_1 BasicBlock:ch<land.end20 0x7740448>, t31, t31:1

    t31: ch,glue = CopyToReg t12, Register:i32 $eflags, t26:1


Examining Available:
  SU (5)  has no physreg SU(2)  defines a physreg
Height 2: SU(2): t26: i32,i32 = SUB32rr t4, t6

Height 2: SU(5): t12: ch = CopyToReg t0, Register:i8 %41, t10

  SU (5)  has no physreg SU(2)  defines a physreg

*** Scheduling [2]: SU(2): t26: i32,i32 = SUB32rr t4, t6


Examining Available:
Height 2: SU(5): t12: ch = CopyToReg t0, Register:i8 %41, t10

Height 3: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [3]: SU(5): t12: ch = CopyToReg t0, Register:i8 %41, t10


Examining Available:
Height 4: SU(6): t10: i8 = EXTRACT_SUBREG MOV32r0:i32,i32, TargetConstant:i32<1>

Height 3: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [4]: SU(6): t10: i8 = EXTRACT_SUBREG MOV32r0:i32,i32, TargetConstant:i32<1>


Examining Available:
Height 5: SU(7): t38: i32,i32 = MOV32r0

Height 3: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [5]: SU(7): t38: i32,i32 = MOV32r0


Examining Available:
Height 3: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [6]: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


Examining Available:
Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [7]: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(7): t38: i32,i32 = MOV32r0

SU(6): t10: i8 = EXTRACT_SUBREG MOV32r0:i32,i32, TargetConstant:i32<1>

SU(5): t12: ch = CopyToReg t0, Register:i8 %41, t10

SU(2): t26: i32,i32 = SUB32rr t4, t6

SU(1): t29: ch = JGE_1 BasicBlock:ch<land.end20 0x7740448>, t31, t31:1

    t31: ch,glue = CopyToReg t12, Register:i32 $eflags, t26:1

SU(0): t18: ch = JMP_1 BasicBlock:ch<land.rhs16 0x7740380>, t29


Total amount of phi nodes to update: 1
Node 0 : (0x7748280, 2147483689)
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Creating new node: t5: i64 = sign_extend t4
Creating constant: t7: i64 = Constant<2>
Creating new node: t8: i64 = shl t5, Constant:i64<2>
Creating new node: t9: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t8
Creating new node: t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t9, undef:i64
Creating new node: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Creating new node: t14: i1 = setcc t10, t12, setlt:ch
Creating new node: t15: i8 = any_extend t14
Creating new node: t17: ch = CopyToReg t0, Register:i8 %2, t15
Creating new node: t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>
Initial selection DAG: %bb.12 'quick_sort:land.rhs16'
SelectionDAG has 20 nodes:
  t0: ch = EntryToken
  t2: i64 = Constant<0>
                  t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
                t5: i64 = sign_extend t4
              t8: i64 = shl t5, Constant:i64<2>
            t9: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t8
          t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t9, undef:i64
          t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
        t14: i1 = setcc t10, t12, setlt:ch
      t15: i8 = any_extend t14
    t17: ch = CopyToReg t0, Register:i8 %2, t15
  t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>



Combining: t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>

Combining: t18: ch = BasicBlock<land.end20 0x7740448>

Combining: t17: ch = CopyToReg t0, Register:i8 %2, t15

Combining: t16: i8 = Register %2

Combining: t15: i8 = any_extend t14
Creating constant: t20: i8 = Constant<0>
Creating constant: t21: i8 = Constant<1>

Combining: t14: i1 = setcc t10, t12, setlt:ch

Combining: t13: ch = setlt

Combining: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64

Combining: t11: i64 = FrameIndex<4>

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t9, undef:i64

Combining: t9: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t8
Creating new node: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
 ... into: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64

Combining: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t8: i64 = shl t5, Constant:i64<2>

Combining: t7: i64 = Constant<2>

Combining: t6: i64 = GlobalAddress<[100 x i32]* @s> 0

Combining: t5: i64 = sign_extend t4
Creating new node: t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Replacing.1 t5: i64 = sign_extend t4

With: t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
 and 0 other values

Combining: t8: i64 = shl t23, Constant:i64<2>

Combining: t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.12 'quick_sort:land.rhs16'
SelectionDAG has 18 nodes:
  t0: ch = EntryToken
                t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
              t8: i64 = shl t23, Constant:i64<2>
            t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
          t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64
          t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
        t14: i1 = setcc t10, t12, setlt:ch
      t15: i8 = any_extend t14
    t17: ch = CopyToReg t0, Register:i8 %2, t15
  t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>


Legalizing node: t18: ch = BasicBlock<land.end20 0x7740448>
Analyzing result type: ch
Legal result type
Legally typed node: t18: ch = BasicBlock<land.end20 0x7740448>

Legalizing node: t16: i8 = Register %2
Ignoring node results
Legally typed node: t16: i8 = Register %2

Legalizing node: t13: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = setlt

Legalizing node: t11: i64 = FrameIndex<4>
Analyzing result type: i64
Legal result type
Legally typed node: t11: i64 = FrameIndex<4>

Legalizing node: t7: i64 = Constant<2>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<2>

Legalizing node: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = GlobalAddress<[100 x i32]* @s> 0

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<2>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t11: i64 = FrameIndex<4>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64

Legalizing node: t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Legalizing node: t8: i64 = shl t23, Constant:i64<2>
Analyzing result type: i64
Legal result type
Analyzing operand: t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t7: i64 = Constant<2>
Legal operand
Legally typed node: t8: i64 = shl t23, Constant:i64<2>

Legalizing node: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Analyzing operand: t8: i64 = shl t23, Constant:i64<2>
Legal operand
Analyzing operand: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Legal operand
Legally typed node: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Legalizing node: t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64

Legalizing node: t14: i1 = setcc t10, t12, setlt:ch
Analyzing result type: i1
Promote integer result: t14: i1 = setcc t10, t12, setlt:ch

Creating new node: t24: i8 = setcc t10, t12, setlt:ch
Legalizing node: t15: i8 = any_extend t14
Analyzing result type: i8
Legal result type
Analyzing operand: t14: i1 = setcc t10, t12, setlt:ch
Promote integer operand: t15: i8 = any_extend t14

Legalizing node: t24: i8 = setcc t10, t12, setlt:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64
Legal operand
Analyzing operand: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Legal operand
Analyzing operand: t13: ch = setlt
Legal operand
Legally typed node: t24: i8 = setcc t10, t12, setlt:ch

Legalizing node: t17: ch = CopyToReg t0, Register:i8 %2, t24
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t24: i8 = setcc t10, t12, setlt:ch
Legal operand
Legally typed node: t17: ch = CopyToReg t0, Register:i8 %2, t24

Legalizing node: t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>
Analyzing result type: ch
Legal result type
Analyzing operand: t17: ch = CopyToReg t0, Register:i8 %2, t24
Legal operand
Analyzing operand: t18: ch = BasicBlock<land.end20 0x7740448>
Legal operand
Legally typed node: t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>

Legalizing node: t65535: ch = handlenode t19
Analyzing result type: ch
Legal result type
Analyzing operand: t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>
Legal operand
Legally typed node: t65535: ch = handlenode t19

Type-legalized selection DAG: %bb.12 'quick_sort:land.rhs16'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
              t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
            t8: i64 = shl t23, Constant:i64<2>
          t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
        t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64
        t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
      t24: i8 = setcc t10, t12, setlt:ch
    t17: ch = CopyToReg t0, Register:i8 %2, t24
  t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>



Combining: t24: i8 = setcc t10, t12, setlt:ch

Combining: t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Combining: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>

Combining: t18: ch = BasicBlock<land.end20 0x7740448>

Combining: t17: ch = CopyToReg t0, Register:i8 %2, t24

Combining: t16: i8 = Register %2

Combining: t13: ch = setlt

Combining: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64

Combining: t11: i64 = FrameIndex<4>

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64

Combining: t8: i64 = shl t23, Constant:i64<2>

Combining: t7: i64 = Constant<2>

Combining: t6: i64 = GlobalAddress<[100 x i32]* @s> 0

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.12 'quick_sort:land.rhs16'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
              t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
            t8: i64 = shl t23, Constant:i64<2>
          t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
        t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64
        t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
      t24: i8 = setcc t10, t12, setlt:ch
    t17: ch = CopyToReg t0, Register:i8 %2, t24
  t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>



Legalizing: t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>
Legal node: nothing to do

Legalizing: t17: ch = CopyToReg t0, Register:i8 %2, t24
Legal node: nothing to do

Legalizing: t24: i8 = setcc t10, t12, setlt:ch
Trying custom legalization
Creating new node: t25: i32,i32 = X86ISD::SUB t10, t12
Creating constant: t26: i8 = Constant<7>
Creating new node: t27: i8 = X86ISD::SETCC Constant:i8<7>, t25:1
Successfully custom legalized node
 ... replacing: t24: i8 = setcc t10, t12, setlt:ch
     with:      t27: i8 = X86ISD::SETCC Constant:i8<7>, t25:1

Legalizing: t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64
Legalizing non-extending load operation

Legalizing: t22: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t8: i64 = shl t23, Constant:i64<2>
Creating constant: t28: i8 = Constant<2>
Legal node: nothing to do

Legalizing: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Legalizing non-extending load operation

Legalizing: t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legalizing extending load operation

Legalizing: t18: ch = BasicBlock<land.end20 0x7740448>
Legal node: nothing to do

Legalizing: t16: i8 = Register %2

Legalizing: t11: i64 = FrameIndex<4>
Legal node: nothing to do

Legalizing: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Trying custom legalization
Creating new node: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Successfully custom legalized node
 ... replacing: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
     with:      t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t29: i64 = TargetGlobalAddress<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t28: i8 = Constant<2>
Legal node: nothing to do

Legalizing: t27: i8 = X86ISD::SETCC Constant:i8<7>, t25:1
Legal node: nothing to do

Legalizing: t26: i8 = Constant<7>
Legal node: nothing to do

Legalizing: t25: i32,i32 = X86ISD::SUB t10, t12
Legal node: nothing to do
Legalized selection DAG: %bb.12 'quick_sort:land.rhs16'
SelectionDAG has 19 nodes:
  t0: ch = EntryToken
                t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
              t8: i64 = shl t23, Constant:i8<2>
              t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
            t22: i64 = add t8, t30
          t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64
          t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
        t25: i32,i32 = X86ISD::SUB t10, t12
      t27: i8 = X86ISD::SETCC Constant:i8<7>, t25:1
    t17: ch = CopyToReg t0, Register:i8 %2, t27
  t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>



Legalizing: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Combining: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0

Legalizing: t29: i64 = TargetGlobalAddress<[100 x i32]* @s> 0
Legal node: nothing to do

Combining: t29: i64 = TargetGlobalAddress<[100 x i32]* @s> 0

Legalizing: t28: i8 = Constant<2>
Legal node: nothing to do

Combining: t28: i8 = Constant<2>

Legalizing: t27: i8 = X86ISD::SETCC Constant:i8<7>, t25:1
Legal node: nothing to do

Combining: t27: i8 = X86ISD::SETCC Constant:i8<7>, t25:1

Legalizing: t26: i8 = Constant<7>
Legal node: nothing to do

Combining: t26: i8 = Constant<7>

Legalizing: t25: i32,i32 = X86ISD::SUB t10, t12
Legal node: nothing to do

Combining: t25: i32,i32 = X86ISD::SUB t10, t12

Legalizing: t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>
Legal node: nothing to do

Combining: t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>

Legalizing: t17: ch = CopyToReg t0, Register:i8 %2, t27
Legal node: nothing to do

Combining: t17: ch = CopyToReg t0, Register:i8 %2, t27

Legalizing: t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64
Legalizing non-extending load operation

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64

Legalizing: t22: i64 = add t8, t30
Legal node: nothing to do

Combining: t22: i64 = add t8, t30

Legalizing: t8: i64 = shl t23, Constant:i8<2>
Legal node: nothing to do

Combining: t8: i64 = shl t23, Constant:i8<2>

Legalizing: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
Legalizing non-extending load operation

Combining: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64

Legalizing: t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legalizing extending load operation

Combining: t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Legalizing: t18: ch = BasicBlock<land.end20 0x7740448>
Legal node: nothing to do

Combining: t18: ch = BasicBlock<land.end20 0x7740448>

Legalizing: t16: i8 = Register %2

Combining: t16: i8 = Register %2

Legalizing: t11: i64 = FrameIndex<4>
Legal node: nothing to do

Combining: t11: i64 = FrameIndex<4>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<2>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.12 'quick_sort:land.rhs16'
SelectionDAG has 19 nodes:
  t0: ch = EntryToken
                t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
              t8: i64 = shl t23, Constant:i8<2>
              t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
            t22: i64 = add t8, t30
          t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64
          t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
        t25: i32,i32 = X86ISD::SUB t10, t12
      t27: i8 = X86ISD::SETCC Constant:i8<7>, t25:1
    t17: ch = CopyToReg t0, Register:i8 %2, t27
  t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>


===== Instruction selection begins: %bb.12 'land.rhs16'

ISEL: Starting selection on root node: t19: ch = br t17, BasicBlock:ch<land.end20 0x7740448>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t19: ch = JMP_1 BasicBlock:ch<land.end20 0x7740448>, t17
ISEL: Match complete!

ISEL: Starting selection on root node: t17: ch = CopyToReg t0, Register:i8 %2, t27

ISEL: Starting selection on root node: t27: i8 = X86ISD::SETCC Constant:i8<7>, t25:1
ISEL: Starting pattern match
  Initial Opcode index to 150721
  Skipped scope entry (due to false predicate) at index 150723, continuing at 150735
  Skipped scope entry (due to false predicate) at index 150736, continuing at 150748
  Skipped scope entry (due to false predicate) at index 150749, continuing at 150761
  Skipped scope entry (due to false predicate) at index 150762, continuing at 150774
  Skipped scope entry (due to false predicate) at index 150775, continuing at 150787
  Skipped scope entry (due to false predicate) at index 150788, continuing at 150800
  Skipped scope entry (due to false predicate) at index 150801, continuing at 150813
  Skipped scope entry (due to false predicate) at index 150814, continuing at 150826
  Skipped scope entry (due to false predicate) at index 150827, continuing at 150839
  Skipped scope entry (due to false predicate) at index 150840, continuing at 150852
  Skipped scope entry (due to false predicate) at index 150853, continuing at 150865
  Skipped scope entry (due to false predicate) at index 150866, continuing at 150878
Creating new node: t32: ch,glue = CopyToReg t0, Register:i32 $eflags, t25:1
  Morphed node: t27: i8 = SETLr t32:1
ISEL: Match complete!

ISEL: Starting selection on root node: t25: i32,i32 = X86ISD::SUB t10, t12
ISEL: Starting pattern match
  Initial Opcode index to 119640
  Match failed at index 119649
  Continuing at 119747
  Match failed at index 119748
  Continuing at 119793
  Skipped scope entry (due to false predicate) at index 119803, continuing at 119884
  Match failed at index 119888
  Continuing at 119902
  Match failed at index 119906
  Continuing at 119920
  Match failed at index 119926
  Continuing at 119938
  Match failed at index 119939
  Continuing at 119958
  Match failed at index 119959
  Continuing at 119978
  Continuing at 119979
  Match failed at index 119980
  Continuing at 119991
  Match failed at index 119992
  Continuing at 120003
  Morphed node: t25: i32,i32 = SUB32rr t10, t12
ISEL: Match complete!

ISEL: Starting selection on root node: t10: i32,ch = load<(load 4 from %ir.arrayidx18)> t0, t22, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 4
IndexReg t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t34: i8 = TargetConstant<4>
  Morphed node: t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx18)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t12: i32,ch = load<(dereferenceable load 4 from %ir.x)> t0, FrameIndex:i64<4>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t38: i8 = TargetConstant<1>
Creating constant: t39: i32 = TargetConstant<0>
  Morphed node: t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t23: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Skipped scope entry (due to false predicate) at index 137189, continuing at 137208
  Skipped scope entry (due to false predicate) at index 137209, continuing at 137228
  Skipped scope entry (due to false predicate) at index 137229, continuing at 137248
  Skipped scope entry (due to false predicate) at index 137249, continuing at 137268
  Match failed at index 137271
  Continuing at 137311
  Match failed at index 137312
  Continuing at 137354
  Skipped scope entry (due to false predicate) at index 137361, continuing at 137378
  Skipped scope entry (due to false predicate) at index 137379, continuing at 137396
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t23: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = BasicBlock<land.end20 0x7740448>

ISEL: Starting selection on root node: t16: i8 = Register %2

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.12 'quick_sort:land.rhs16'
SelectionDAG has 20 nodes:
  t0: ch = EntryToken
              t23: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
            t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx18)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0
            t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
          t25: i32,i32 = SUB32rr t10, t12
        t32: ch,glue = CopyToReg t0, Register:i32 $eflags, t25:1
      t27: i8 = SETLr t32:1
    t17: ch = CopyToReg t0, Register:i8 %2, t27
  t19: ch = JMP_1 BasicBlock:ch<land.end20 0x7740448>, t17


********** List Scheduling %bb.12 'land.rhs16' **********
SU(0): t19: ch = JMP_1 BasicBlock:ch<land.end20 0x7740448>, t17

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t17: ch = CopyToReg t0, Register:i8 %2, t27

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t27: i8 = SETLr t32:1

    t32: ch,glue = CopyToReg t0, Register:i32 $eflags, t25:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1 Reg=$eflags
  Successors:
    SU(1): Data Latency=1
SU(3): t25: i32,i32 = SUB32rr t10, t12

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1 Reg=$eflags
SU(4): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1
SU(5): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx18)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(6): t23: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(5): Data Latency=1

Examining Available:
Height 0: SU(0): t19: ch = JMP_1 BasicBlock:ch<land.end20 0x7740448>, t17


*** Scheduling [0]: SU(0): t19: ch = JMP_1 BasicBlock:ch<land.end20 0x7740448>, t17


Examining Available:
Height 1: SU(1): t17: ch = CopyToReg t0, Register:i8 %2, t27


*** Scheduling [1]: SU(1): t17: ch = CopyToReg t0, Register:i8 %2, t27


Examining Available:
Height 2: SU(2): t27: i8 = SETLr t32:1

    t32: ch,glue = CopyToReg t0, Register:i32 $eflags, t25:1


*** Scheduling [2]: SU(2): t27: i8 = SETLr t32:1

    t32: ch,glue = CopyToReg t0, Register:i32 $eflags, t25:1


Examining Available:
Height 3: SU(3): t25: i32,i32 = SUB32rr t10, t12


*** Scheduling [3]: SU(3): t25: i32,i32 = SUB32rr t10, t12


Examining Available:
Height 4: SU(4): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 4: SU(5): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx18)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


*** Scheduling [4]: SU(4): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


Examining Available:
Height 4: SU(5): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx18)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


*** Scheduling [5]: SU(5): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx18)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


Examining Available:
Height 6: SU(6): t23: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [6]: SU(6): t23: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(6): t23: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(5): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx18)> Register:i64 $noreg, TargetConstant:i8<4>, t23, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0

SU(4): t12: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.x)> TargetFrameIndex:i64<4>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(3): t25: i32,i32 = SUB32rr t10, t12

SU(2): t27: i8 = SETLr t32:1

    t32: ch,glue = CopyToReg t0, Register:i32 $eflags, t25:1

SU(1): t17: ch = CopyToReg t0, Register:i8 %2, t27

SU(0): t19: ch = JMP_1 BasicBlock:ch<land.end20 0x7740448>, t17


Total amount of phi nodes to update: 1
Node 0 : (0x7748280, 2147483650)
Creating new node: t2: i8,ch = CopyFromReg t0, Register:i8 %3
Creating new node: t3: i1 = truncate t2
Creating constant: t4: i1 = Constant<-1>
Creating new node: t5: i1 = xor t3, Constant:i1<-1>
Creating new node: t7: ch = brcond t0, t5, BasicBlock:ch<while.end23 0x77483b0>
Creating new node: t9: ch = br t7, BasicBlock:ch<while.body21 0x77482e8>
Initial selection DAG: %bb.13 'quick_sort:land.end20'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
          t2: i8,ch = CopyFromReg t0, Register:i8 %3
        t3: i1 = truncate t2
      t5: i1 = xor t3, Constant:i1<-1>
    t7: ch = brcond t0, t5, BasicBlock:ch<while.end23 0x77483b0>
  t9: ch = br t7, BasicBlock:ch<while.body21 0x77482e8>



Combining: t9: ch = br t7, BasicBlock:ch<while.body21 0x77482e8>

Combining: t8: ch = BasicBlock<while.body21 0x77482e8>

Combining: t7: ch = brcond t0, t5, BasicBlock:ch<while.end23 0x77483b0>
Creating new node: t11: i1 = setcc t3, Constant:i1<-1>, setne:ch
Creating new node: t12: ch = brcond t0, t11, BasicBlock:ch<while.end23 0x77483b0>
 ... into: t12: ch = brcond t0, t11, BasicBlock:ch<while.end23 0x77483b0>

Combining: t9: ch = br t12, BasicBlock:ch<while.body21 0x77482e8>

Combining: t12: ch = brcond t0, t11, BasicBlock:ch<while.end23 0x77483b0>

Combining: t11: i1 = setcc t3, Constant:i1<-1>, setne:ch

Combining: t10: ch = setne

Combining: t6: ch = BasicBlock<while.end23 0x77483b0>

Combining: t4: i1 = Constant<-1>

Combining: t3: i1 = truncate t2

Combining: t2: i8,ch = CopyFromReg t0, Register:i8 %3

Combining: t1: i8 = Register %3

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.13 'quick_sort:land.end20'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
          t2: i8,ch = CopyFromReg t0, Register:i8 %3
        t3: i1 = truncate t2
      t11: i1 = setcc t3, Constant:i1<-1>, setne:ch
    t12: ch = brcond t0, t11, BasicBlock:ch<while.end23 0x77483b0>
  t9: ch = br t12, BasicBlock:ch<while.body21 0x77482e8>


Legalizing node: t10: ch = setne
Analyzing result type: ch
Legal result type
Legally typed node: t10: ch = setne

Legalizing node: t8: ch = BasicBlock<while.body21 0x77482e8>
Analyzing result type: ch
Legal result type
Legally typed node: t8: ch = BasicBlock<while.body21 0x77482e8>

Legalizing node: t6: ch = BasicBlock<while.end23 0x77483b0>
Analyzing result type: ch
Legal result type
Legally typed node: t6: ch = BasicBlock<while.end23 0x77483b0>

Legalizing node: t4: i1 = Constant<-1>
Analyzing result type: i1
Promote integer result: t4: i1 = Constant<-1>

Creating constant: t13: i8 = Constant<1>
Legalizing node: t13: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t13: i8 = Constant<1>

Legalizing node: t1: i8 = Register %3
Ignoring node results
Legally typed node: t1: i8 = Register %3

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i8,ch = CopyFromReg t0, Register:i8 %3
Analyzing result type: i8
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i8,ch = CopyFromReg t0, Register:i8 %3

Legalizing node: t3: i1 = truncate t2
Analyzing result type: i1
Promote integer result: t3: i1 = truncate t2

Legalizing node: t11: i1 = setcc t3, Constant:i1<-1>, setne:ch
Analyzing result type: i1
Promote integer result: t11: i1 = setcc t3, Constant:i1<-1>, setne:ch

Creating new node: t14: i8 = setcc t3, Constant:i1<-1>, setne:ch
Legalizing node: t12: ch = brcond t0, t11, BasicBlock:ch<while.end23 0x77483b0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t11: i1 = setcc t3, Constant:i1<-1>, setne:ch
Promote integer operand: t12: ch = brcond t0, t11, BasicBlock:ch<while.end23 0x77483b0>

Creating new node: t15: i8 = zero_extend t11
Legalizing node: t15: i8 = zero_extend t11
Analyzing result type: i8
Legal result type
Analyzing operand: t11: i1 = setcc t3, Constant:i1<-1>, setne:ch
Promote integer operand: t15: i8 = zero_extend t11

Creating new node: t16: i8 = and t14, Constant:i8<1>
Legalizing node: t14: i8 = setcc t3, Constant:i1<-1>, setne:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t3: i1 = truncate t2
Promote integer operand: t14: i8 = setcc t3, Constant:i1<-1>, setne:ch

Creating new node: t17: i8 = and t2, Constant:i8<1>
Legalizing node: t17: i8 = and t2, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t2: i8,ch = CopyFromReg t0, Register:i8 %3
Legal operand
Analyzing operand: t13: i8 = Constant<1>
Legal operand
Legally typed node: t17: i8 = and t2, Constant:i8<1>

Legalizing node: t14: i8 = setcc t17, Constant:i8<1>, setne:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t17: i8 = and t2, Constant:i8<1>
Legal operand
Analyzing operand: t13: i8 = Constant<1>
Legal operand
Analyzing operand: t10: ch = setne
Legal operand
Legally typed node: t14: i8 = setcc t17, Constant:i8<1>, setne:ch

Legalizing node: t16: i8 = and t14, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t14: i8 = setcc t17, Constant:i8<1>, setne:ch
Legal operand
Analyzing operand: t13: i8 = Constant<1>
Legal operand
Legally typed node: t16: i8 = and t14, Constant:i8<1>

Legalizing node: t12: ch = brcond t0, t16, BasicBlock:ch<while.end23 0x77483b0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t16: i8 = and t14, Constant:i8<1>
Legal operand
Analyzing operand: t6: ch = BasicBlock<while.end23 0x77483b0>
Legal operand
Legally typed node: t12: ch = brcond t0, t16, BasicBlock:ch<while.end23 0x77483b0>

Legalizing node: t9: ch = br t12, BasicBlock:ch<while.body21 0x77482e8>
Analyzing result type: ch
Legal result type
Analyzing operand: t12: ch = brcond t0, t16, BasicBlock:ch<while.end23 0x77483b0>
Legal operand
Analyzing operand: t8: ch = BasicBlock<while.body21 0x77482e8>
Legal operand
Legally typed node: t9: ch = br t12, BasicBlock:ch<while.body21 0x77482e8>

Legalizing node: t65535: ch = handlenode t9
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = br t12, BasicBlock:ch<while.body21 0x77482e8>
Legal operand
Legally typed node: t65535: ch = handlenode t9

Type-legalized selection DAG: %bb.13 'quick_sort:land.end20'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
            t2: i8,ch = CopyFromReg t0, Register:i8 %3
          t17: i8 = and t2, Constant:i8<1>
        t14: i8 = setcc t17, Constant:i8<1>, setne:ch
      t16: i8 = and t14, Constant:i8<1>
    t12: ch = brcond t0, t16, BasicBlock:ch<while.end23 0x77483b0>
  t9: ch = br t12, BasicBlock:ch<while.body21 0x77482e8>



Combining: t17: i8 = and t2, Constant:i8<1>

Combining: t16: i8 = and t14, Constant:i8<1>

Replacing.2 t16: i8 = and t14, Constant:i8<1>

With: t14: i8 = setcc t17, Constant:i8<1>, setne:ch


Combining: t14: i8 = setcc t17, Constant:i8<1>, setne:ch
Creating constant: t18: i8 = Constant<0>
Creating new node: t20: i8 = setcc t17, Constant:i8<0>, seteq:ch
 ... into: t20: i8 = setcc t17, Constant:i8<0>, seteq:ch

Combining: t17: i8 = and t2, Constant:i8<1>

Combining: t20: i8 = setcc t17, Constant:i8<0>, seteq:ch

Combining: t19: ch = seteq

Combining: t18: i8 = Constant<0>

Combining: t13: i8 = Constant<1>

Combining: t12: ch = brcond t0, t20, BasicBlock:ch<while.end23 0x77483b0>

Combining: t9: ch = br t12, BasicBlock:ch<while.body21 0x77482e8>

Combining: t8: ch = BasicBlock<while.body21 0x77482e8>

Combining: t6: ch = BasicBlock<while.end23 0x77483b0>

Combining: t2: i8,ch = CopyFromReg t0, Register:i8 %3

Combining: t1: i8 = Register %3

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.13 'quick_sort:land.end20'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
          t2: i8,ch = CopyFromReg t0, Register:i8 %3
        t17: i8 = and t2, Constant:i8<1>
      t20: i8 = setcc t17, Constant:i8<0>, seteq:ch
    t12: ch = brcond t0, t20, BasicBlock:ch<while.end23 0x77483b0>
  t9: ch = br t12, BasicBlock:ch<while.body21 0x77482e8>



Legalizing: t9: ch = br t12, BasicBlock:ch<while.body21 0x77482e8>
Legal node: nothing to do

Legalizing: t12: ch = brcond t0, t20, BasicBlock:ch<while.end23 0x77483b0>
Trying custom legalization
Creating new node: t21: i32 = X86ISD::CMP t17, Constant:i8<0>
Creating constant: t22: i8 = Constant<4>
Creating new node: t23: i8 = X86ISD::SETCC Constant:i8<4>, t21
Creating new node: t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end23 0x77483b0>, Constant:i8<4>, t21
Successfully custom legalized node
 ... replacing: t12: ch = brcond t0, t20, BasicBlock:ch<while.end23 0x77483b0>
     with:      t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end23 0x77483b0>, Constant:i8<4>, t21

Legalizing: t17: i8 = and t2, Constant:i8<1>
Legal node: nothing to do

Legalizing: t2: i8,ch = CopyFromReg t0, Register:i8 %3
Legal node: nothing to do

Legalizing: t18: i8 = Constant<0>
Legal node: nothing to do

Legalizing: t13: i8 = Constant<1>
Legal node: nothing to do

Legalizing: t8: ch = BasicBlock<while.body21 0x77482e8>
Legal node: nothing to do

Legalizing: t6: ch = BasicBlock<while.end23 0x77483b0>
Legal node: nothing to do

Legalizing: t1: i8 = Register %3

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end23 0x77483b0>, Constant:i8<4>, t21
Legal node: nothing to do

Legalizing: t22: i8 = Constant<4>
Legal node: nothing to do

Legalizing: t21: i32 = X86ISD::CMP t17, Constant:i8<0>
Legal node: nothing to do
Legalized selection DAG: %bb.13 'quick_sort:land.end20'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
          t2: i8,ch = CopyFromReg t0, Register:i8 %3
        t17: i8 = and t2, Constant:i8<1>
      t21: i32 = X86ISD::CMP t17, Constant:i8<0>
    t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end23 0x77483b0>, Constant:i8<4>, t21
  t9: ch = br t24, BasicBlock:ch<while.body21 0x77482e8>



Legalizing: t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end23 0x77483b0>, Constant:i8<4>, t21
Legal node: nothing to do

Combining: t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end23 0x77483b0>, Constant:i8<4>, t21

Legalizing: t22: i8 = Constant<4>
Legal node: nothing to do

Combining: t22: i8 = Constant<4>

Legalizing: t21: i32 = X86ISD::CMP t17, Constant:i8<0>
Legal node: nothing to do

Combining: t21: i32 = X86ISD::CMP t17, Constant:i8<0>

Legalizing: t9: ch = br t24, BasicBlock:ch<while.body21 0x77482e8>
Legal node: nothing to do

Combining: t9: ch = br t24, BasicBlock:ch<while.body21 0x77482e8>

Legalizing: t17: i8 = and t2, Constant:i8<1>
Legal node: nothing to do

Combining: t17: i8 = and t2, Constant:i8<1>

Legalizing: t2: i8,ch = CopyFromReg t0, Register:i8 %3
Legal node: nothing to do

Combining: t2: i8,ch = CopyFromReg t0, Register:i8 %3

Legalizing: t18: i8 = Constant<0>
Legal node: nothing to do

Combining: t18: i8 = Constant<0>

Legalizing: t13: i8 = Constant<1>
Legal node: nothing to do

Combining: t13: i8 = Constant<1>

Legalizing: t8: ch = BasicBlock<while.body21 0x77482e8>
Legal node: nothing to do

Combining: t8: ch = BasicBlock<while.body21 0x77482e8>

Legalizing: t6: ch = BasicBlock<while.end23 0x77483b0>
Legal node: nothing to do

Combining: t6: ch = BasicBlock<while.end23 0x77483b0>

Legalizing: t1: i8 = Register %3

Combining: t1: i8 = Register %3

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.13 'quick_sort:land.end20'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
          t2: i8,ch = CopyFromReg t0, Register:i8 %3
        t17: i8 = and t2, Constant:i8<1>
      t21: i32 = X86ISD::CMP t17, Constant:i8<0>
    t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end23 0x77483b0>, Constant:i8<4>, t21
  t9: ch = br t24, BasicBlock:ch<while.body21 0x77482e8>


===== Instruction selection begins: %bb.13 'land.end20'

ISEL: Starting selection on root node: t9: ch = br t24, BasicBlock:ch<while.body21 0x77482e8>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t9: ch = JMP_1 BasicBlock:ch<while.body21 0x77482e8>, t24
ISEL: Match complete!

ISEL: Starting selection on root node: t24: ch = X86ISD::BRCOND t0, BasicBlock:ch<while.end23 0x77483b0>, Constant:i8<4>, t21
ISEL: Starting pattern match
  Initial Opcode index to 150935
  Skipped scope entry (due to false predicate) at index 150944, continuing at 150957
  Skipped scope entry (due to false predicate) at index 150958, continuing at 150971
  Skipped scope entry (due to false predicate) at index 150972, continuing at 150985
  Skipped scope entry (due to false predicate) at index 150986, continuing at 150999
Creating new node: t26: ch,glue = CopyToReg t0, Register:i32 $eflags, t21
  Morphed node: t24: ch = JE_1 BasicBlock:ch<while.end23 0x77483b0>, t26, t26:1
ISEL: Match complete!

ISEL: Starting selection on root node: t21: i32 = X86ISD::CMP t17, Constant:i8<0>
ISEL: Starting pattern match
  Initial Opcode index to 77651
  OpcodeSwitch from 77655 to 77660
  Match failed at index 77664
  Continuing at 77821
  Match failed at index 77831
  Continuing at 77869
  Match failed at index 77874
  Continuing at 77912
  Match failed at index 77917
  Continuing at 77955
  Continuing at 77956
  Match failed at index 77958
  Continuing at 78081
  Match failed at index 78084
  Continuing at 78203
  Continuing at 78428
  Match failed at index 78436
  Continuing at 78464
  Match failed at index 78465
  Continuing at 78496
  Match failed at index 78497
  Continuing at 78528
  Match failed at index 78529
  Continuing at 78560
  Continuing at 78561
  Match failed at index 78563
  Continuing at 78662
  Skipped scope entry (due to false predicate) at index 78667, continuing at 78741
  Skipped scope entry (due to false predicate) at index 78742, continuing at 78816
  Match failed at index 78665
  Continuing at 78817
  Match failed at index 78840
  Continuing at 78857
Creating constant: t27: i8 = TargetConstant<1>
  Morphed node: t21: i32 = TEST8ri t2, TargetConstant:i8<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i8,ch = CopyFromReg t0, Register:i8 %3

ISEL: Starting selection on root node: t8: ch = BasicBlock<while.body21 0x77482e8>

ISEL: Starting selection on root node: t6: ch = BasicBlock<while.end23 0x77483b0>

ISEL: Starting selection on root node: t1: i8 = Register %3

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.13 'quick_sort:land.end20'
SelectionDAG has 11 nodes:
  t0: ch = EntryToken
      t2: i8,ch = CopyFromReg t0, Register:i8 %3
    t21: i32 = TEST8ri t2, TargetConstant:i8<1>
  t26: ch,glue = CopyToReg t0, Register:i32 $eflags, t21
    t24: ch = JE_1 BasicBlock:ch<while.end23 0x77483b0>, t26, t26:1
  t9: ch = JMP_1 BasicBlock:ch<while.body21 0x77482e8>, t24


********** List Scheduling %bb.13 'land.end20' **********
SU(0): t9: ch = JMP_1 BasicBlock:ch<while.body21 0x77482e8>, t24

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t24: ch = JE_1 BasicBlock:ch<while.end23 0x77483b0>, t26, t26:1

    t26: ch,glue = CopyToReg t0, Register:i32 $eflags, t21

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t21: i32 = TEST8ri t2, TargetConstant:i8<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t2: i8,ch = CopyFromReg t0, Register:i8 %3

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t9: ch = JMP_1 BasicBlock:ch<while.body21 0x77482e8>, t24


*** Scheduling [0]: SU(0): t9: ch = JMP_1 BasicBlock:ch<while.body21 0x77482e8>, t24


Examining Available:
Height 1: SU(1): t24: ch = JE_1 BasicBlock:ch<while.end23 0x77483b0>, t26, t26:1

    t26: ch,glue = CopyToReg t0, Register:i32 $eflags, t21


*** Scheduling [1]: SU(1): t24: ch = JE_1 BasicBlock:ch<while.end23 0x77483b0>, t26, t26:1

    t26: ch,glue = CopyToReg t0, Register:i32 $eflags, t21


Examining Available:
Height 2: SU(2): t21: i32 = TEST8ri t2, TargetConstant:i8<1>


*** Scheduling [2]: SU(2): t21: i32 = TEST8ri t2, TargetConstant:i8<1>


Examining Available:
Height 3: SU(3): t2: i8,ch = CopyFromReg t0, Register:i8 %3


*** Scheduling [3]: SU(3): t2: i8,ch = CopyFromReg t0, Register:i8 %3

*** Final schedule ***
SU(3): t2: i8,ch = CopyFromReg t0, Register:i8 %3

SU(2): t21: i32 = TEST8ri t2, TargetConstant:i8<1>

SU(1): t24: ch = JE_1 BasicBlock:ch<while.end23 0x77483b0>, t26, t26:1

    t26: ch,glue = CopyToReg t0, Register:i32 $eflags, t21

SU(0): t9: ch = JMP_1 BasicBlock:ch<while.body21 0x77482e8>, t24


Total amount of phi nodes to update: 0
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Creating new node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Creating new node: t8: i1 = setcc t4, t6, setlt:ch
Creating constant: t9: i1 = Constant<-1>
Creating new node: t10: i1 = xor t8, Constant:i1<-1>
Creating new node: t12: ch = brcond t0, t10, BasicBlock:ch<if.end31 0x7748540>
Creating new node: t14: ch = br t12, BasicBlock:ch<if.then25 0x7748478>
Initial selection DAG: %bb.15 'quick_sort:while.end23'
SelectionDAG has 15 nodes:
  t0: ch = EntryToken
  t2: i64 = Constant<0>
          t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
          t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
        t8: i1 = setcc t4, t6, setlt:ch
      t10: i1 = xor t8, Constant:i1<-1>
    t12: ch = brcond t0, t10, BasicBlock:ch<if.end31 0x7748540>
  t14: ch = br t12, BasicBlock:ch<if.then25 0x7748478>



Combining: t14: ch = br t12, BasicBlock:ch<if.then25 0x7748478>

Combining: t13: ch = BasicBlock<if.then25 0x7748478>

Combining: t12: ch = brcond t0, t10, BasicBlock:ch<if.end31 0x7748540>
Creating new node: t16: i1 = setcc t4, t6, setge:ch
Creating new node: t17: ch = brcond t0, t16, BasicBlock:ch<if.end31 0x7748540>
 ... into: t17: ch = brcond t0, t16, BasicBlock:ch<if.end31 0x7748540>

Combining: t14: ch = br t17, BasicBlock:ch<if.then25 0x7748478>

Combining: t17: ch = brcond t0, t16, BasicBlock:ch<if.end31 0x7748540>

Combining: t16: i1 = setcc t4, t6, setge:ch

Combining: t15: ch = setge

Combining: t11: ch = BasicBlock<if.end31 0x7748540>

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Combining: t5: i64 = FrameIndex<3>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.15 'quick_sort:while.end23'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t16: i1 = setcc t4, t6, setge:ch
    t17: ch = brcond t0, t16, BasicBlock:ch<if.end31 0x7748540>
  t14: ch = br t17, BasicBlock:ch<if.then25 0x7748478>


Legalizing node: t15: ch = setge
Analyzing result type: ch
Legal result type
Legally typed node: t15: ch = setge

Legalizing node: t13: ch = BasicBlock<if.then25 0x7748478>
Analyzing result type: ch
Legal result type
Legally typed node: t13: ch = BasicBlock<if.then25 0x7748478>

Legalizing node: t11: ch = BasicBlock<if.end31 0x7748540>
Analyzing result type: ch
Legal result type
Legally typed node: t11: ch = BasicBlock<if.end31 0x7748540>

Legalizing node: t5: i64 = FrameIndex<3>
Analyzing result type: i64
Legal result type
Legally typed node: t5: i64 = FrameIndex<3>

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<2>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Legalizing node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t5: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Legalizing node: t16: i1 = setcc t4, t6, setge:ch
Analyzing result type: i1
Promote integer result: t16: i1 = setcc t4, t6, setge:ch

Creating new node: t18: i8 = setcc t4, t6, setge:ch
Legalizing node: t17: ch = brcond t0, t16, BasicBlock:ch<if.end31 0x7748540>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t16: i1 = setcc t4, t6, setge:ch
Promote integer operand: t17: ch = brcond t0, t16, BasicBlock:ch<if.end31 0x7748540>

Creating new node: t19: i8 = zero_extend t16
Legalizing node: t19: i8 = zero_extend t16
Analyzing result type: i8
Legal result type
Analyzing operand: t16: i1 = setcc t4, t6, setge:ch
Promote integer operand: t19: i8 = zero_extend t16

Creating constant: t20: i8 = Constant<1>
Creating new node: t21: i8 = and t18, Constant:i8<1>
Legalizing node: t20: i8 = Constant<1>
Analyzing result type: i8
Legal result type
Legally typed node: t20: i8 = Constant<1>

Legalizing node: t18: i8 = setcc t4, t6, setge:ch
Analyzing result type: i8
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t15: ch = setge
Legal operand
Legally typed node: t18: i8 = setcc t4, t6, setge:ch

Legalizing node: t21: i8 = and t18, Constant:i8<1>
Analyzing result type: i8
Legal result type
Analyzing operand: t18: i8 = setcc t4, t6, setge:ch
Legal operand
Analyzing operand: t20: i8 = Constant<1>
Legal operand
Legally typed node: t21: i8 = and t18, Constant:i8<1>

Legalizing node: t17: ch = brcond t0, t21, BasicBlock:ch<if.end31 0x7748540>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t21: i8 = and t18, Constant:i8<1>
Legal operand
Analyzing operand: t11: ch = BasicBlock<if.end31 0x7748540>
Legal operand
Legally typed node: t17: ch = brcond t0, t21, BasicBlock:ch<if.end31 0x7748540>

Legalizing node: t14: ch = br t17, BasicBlock:ch<if.then25 0x7748478>
Analyzing result type: ch
Legal result type
Analyzing operand: t17: ch = brcond t0, t21, BasicBlock:ch<if.end31 0x7748540>
Legal operand
Analyzing operand: t13: ch = BasicBlock<if.then25 0x7748478>
Legal operand
Legally typed node: t14: ch = br t17, BasicBlock:ch<if.then25 0x7748478>

Legalizing node: t65535: ch = handlenode t14
Analyzing result type: ch
Legal result type
Analyzing operand: t14: ch = br t17, BasicBlock:ch<if.then25 0x7748478>
Legal operand
Legally typed node: t65535: ch = handlenode t14

Type-legalized selection DAG: %bb.15 'quick_sort:while.end23'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
          t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
          t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
        t18: i8 = setcc t4, t6, setge:ch
      t21: i8 = and t18, Constant:i8<1>
    t17: ch = brcond t0, t21, BasicBlock:ch<if.end31 0x7748540>
  t14: ch = br t17, BasicBlock:ch<if.then25 0x7748478>



Combining: t21: i8 = and t18, Constant:i8<1>

Replacing.2 t21: i8 = and t18, Constant:i8<1>

With: t18: i8 = setcc t4, t6, setge:ch


Combining: t18: i8 = setcc t4, t6, setge:ch

Combining: t17: ch = brcond t0, t18, BasicBlock:ch<if.end31 0x7748540>

Combining: t15: ch = setge

Combining: t14: ch = br t17, BasicBlock:ch<if.then25 0x7748478>

Combining: t13: ch = BasicBlock<if.then25 0x7748478>

Combining: t11: ch = BasicBlock<if.end31 0x7748540>

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Combining: t5: i64 = FrameIndex<3>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.15 'quick_sort:while.end23'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t18: i8 = setcc t4, t6, setge:ch
    t17: ch = brcond t0, t18, BasicBlock:ch<if.end31 0x7748540>
  t14: ch = br t17, BasicBlock:ch<if.then25 0x7748478>



Legalizing: t14: ch = br t17, BasicBlock:ch<if.then25 0x7748478>
Legal node: nothing to do

Legalizing: t17: ch = brcond t0, t18, BasicBlock:ch<if.end31 0x7748540>
Trying custom legalization
Creating new node: t22: i32,i32 = X86ISD::SUB t4, t6
Creating constant: t23: i8 = Constant<6>
Creating new node: t24: i8 = X86ISD::SETCC Constant:i8<6>, t22:1
Creating new node: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end31 0x7748540>, Constant:i8<6>, t22:1
Successfully custom legalized node
 ... replacing: t17: ch = brcond t0, t18, BasicBlock:ch<if.end31 0x7748540>
     with:      t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end31 0x7748540>, Constant:i8<6>, t22:1

Legalizing: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Legalizing: t13: ch = BasicBlock<if.then25 0x7748478>
Legal node: nothing to do

Legalizing: t11: ch = BasicBlock<if.end31 0x7748540>
Legal node: nothing to do

Legalizing: t5: i64 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end31 0x7748540>, Constant:i8<6>, t22:1
Legal node: nothing to do

Legalizing: t23: i8 = Constant<6>
Legal node: nothing to do

Legalizing: t22: i32,i32 = X86ISD::SUB t4, t6
Legal node: nothing to do
Legalized selection DAG: %bb.15 'quick_sort:while.end23'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t22: i32,i32 = X86ISD::SUB t4, t6
    t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end31 0x7748540>, Constant:i8<6>, t22:1
  t14: ch = br t25, BasicBlock:ch<if.then25 0x7748478>



Legalizing: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end31 0x7748540>, Constant:i8<6>, t22:1
Legal node: nothing to do

Combining: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end31 0x7748540>, Constant:i8<6>, t22:1

Legalizing: t23: i8 = Constant<6>
Legal node: nothing to do

Combining: t23: i8 = Constant<6>

Legalizing: t22: i32,i32 = X86ISD::SUB t4, t6
Legal node: nothing to do

Combining: t22: i32,i32 = X86ISD::SUB t4, t6

Legalizing: t14: ch = br t25, BasicBlock:ch<if.then25 0x7748478>
Legal node: nothing to do

Combining: t14: ch = br t25, BasicBlock:ch<if.then25 0x7748478>

Legalizing: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Combining: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Legalizing: t13: ch = BasicBlock<if.then25 0x7748478>
Legal node: nothing to do

Combining: t13: ch = BasicBlock<if.then25 0x7748478>

Legalizing: t11: ch = BasicBlock<if.end31 0x7748540>
Legal node: nothing to do

Combining: t11: ch = BasicBlock<if.end31 0x7748540>

Legalizing: t5: i64 = FrameIndex<3>
Legal node: nothing to do

Combining: t5: i64 = FrameIndex<3>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<2>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.15 'quick_sort:while.end23'
SelectionDAG has 12 nodes:
  t0: ch = EntryToken
        t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t22: i32,i32 = X86ISD::SUB t4, t6
    t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end31 0x7748540>, Constant:i8<6>, t22:1
  t14: ch = br t25, BasicBlock:ch<if.then25 0x7748478>


===== Instruction selection begins: %bb.15 'while.end23'

ISEL: Starting selection on root node: t14: ch = br t25, BasicBlock:ch<if.then25 0x7748478>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t14: ch = JMP_1 BasicBlock:ch<if.then25 0x7748478>, t25
ISEL: Match complete!

ISEL: Starting selection on root node: t25: ch = X86ISD::BRCOND t0, BasicBlock:ch<if.end31 0x7748540>, Constant:i8<6>, t22:1
ISEL: Starting pattern match
  Initial Opcode index to 150935
  Skipped scope entry (due to false predicate) at index 150944, continuing at 150957
  Skipped scope entry (due to false predicate) at index 150958, continuing at 150971
  Skipped scope entry (due to false predicate) at index 150972, continuing at 150985
  Skipped scope entry (due to false predicate) at index 150986, continuing at 150999
  Skipped scope entry (due to false predicate) at index 151000, continuing at 151013
  Skipped scope entry (due to false predicate) at index 151014, continuing at 151027
  Skipped scope entry (due to false predicate) at index 151028, continuing at 151041
  Skipped scope entry (due to false predicate) at index 151042, continuing at 151055
  Skipped scope entry (due to false predicate) at index 151056, continuing at 151069
  Skipped scope entry (due to false predicate) at index 151070, continuing at 151083
  Skipped scope entry (due to false predicate) at index 151084, continuing at 151097
  Skipped scope entry (due to false predicate) at index 151098, continuing at 151111
  Skipped scope entry (due to false predicate) at index 151112, continuing at 151125
Creating new node: t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1
  Morphed node: t25: ch = JGE_1 BasicBlock:ch<if.end31 0x7748540>, t27, t27:1
ISEL: Match complete!

ISEL: Starting selection on root node: t22: i32,i32 = X86ISD::SUB t4, t6
ISEL: Starting pattern match
  Initial Opcode index to 119640
  Match failed at index 119649
  Continuing at 119747
  Match failed at index 119748
  Continuing at 119793
  Skipped scope entry (due to false predicate) at index 119803, continuing at 119884
  Match failed at index 119888
  Continuing at 119902
  Match failed at index 119906
  Continuing at 119920
  Match failed at index 119926
  Continuing at 119938
  Match failed at index 119939
  Continuing at 119958
  Match failed at index 119959
  Continuing at 119978
  Continuing at 119979
  Match failed at index 119980
  Continuing at 119991
  Match failed at index 119992
  Continuing at 120003
  Morphed node: t22: i32,i32 = SUB32rr t4, t6
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t30: i8 = TargetConstant<1>
Creating constant: t31: i32 = TargetConstant<0>
  Morphed node: t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = BasicBlock<if.then25 0x7748478>

ISEL: Starting selection on root node: t11: ch = BasicBlock<if.end31 0x7748540>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.15 'quick_sort:while.end23'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
      t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
      t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
    t22: i32,i32 = SUB32rr t4, t6
  t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1
    t25: ch = JGE_1 BasicBlock:ch<if.end31 0x7748540>, t27, t27:1
  t14: ch = JMP_1 BasicBlock:ch<if.then25 0x7748478>, t25


********** List Scheduling %bb.15 'while.end23' **********
SU(0): t14: ch = JMP_1 BasicBlock:ch<if.then25 0x7748478>, t25

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t25: ch = JGE_1 BasicBlock:ch<if.end31 0x7748540>, t27, t27:1

    t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1 Reg=$eflags
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t22: i32,i32 = SUB32rr t4, t6

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1 Reg=$eflags
SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1
SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Data Latency=1

Examining Available:
Height 0: SU(0): t14: ch = JMP_1 BasicBlock:ch<if.then25 0x7748478>, t25


*** Scheduling [0]: SU(0): t14: ch = JMP_1 BasicBlock:ch<if.then25 0x7748478>, t25


Examining Available:
Height 1: SU(1): t25: ch = JGE_1 BasicBlock:ch<if.end31 0x7748540>, t27, t27:1

    t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1


*** Scheduling [1]: SU(1): t25: ch = JGE_1 BasicBlock:ch<if.end31 0x7748540>, t27, t27:1

    t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1


Examining Available:
Height 2: SU(2): t22: i32,i32 = SUB32rr t4, t6


*** Scheduling [2]: SU(2): t22: i32,i32 = SUB32rr t4, t6


Examining Available:
Height 3: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [3]: SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


Examining Available:
Height 3: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [4]: SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(4): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(3): t6: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(2): t22: i32,i32 = SUB32rr t4, t6

SU(1): t25: ch = JGE_1 BasicBlock:ch<if.end31 0x7748540>, t27, t27:1

    t27: ch,glue = CopyToReg t0, Register:i32 $eflags, t22:1

SU(0): t14: ch = JMP_1 BasicBlock:ch<if.then25 0x7748478>, t25


Total amount of phi nodes to update: 0
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Creating new node: t5: i64 = sign_extend t4
Creating constant: t7: i64 = Constant<2>
Creating new node: t8: i64 = shl t5, Constant:i64<2>
Creating new node: t9: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t8
Creating new node: t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t9, undef:i64
Creating new node: t12: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Creating constant: t13: i32 = Constant<-1>
Creating new node: t14: i32 = add nsw t12, Constant:i32<-1>
Creating new node: t15: ch = TokenFactor t4:1, t10:1, t12:1
Creating new node: t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64
Creating new node: t17: i64 = sign_extend t12
Creating new node: t18: i64 = shl t17, Constant:i64<2>
Creating new node: t19: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t18
Creating new node: t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t19, undef:i64
Creating new node: t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>
Initial selection DAG: %bb.16 'quick_sort:if.then25'
SelectionDAG has 23 nodes:
  t0: ch = EntryToken
  t2: i64 = Constant<0>
  t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
        t5: i64 = sign_extend t4
      t8: i64 = shl t5, Constant:i64<2>
    t9: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t8
  t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t9, undef:i64
  t12: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
        t15: ch = TokenFactor t4:1, t10:1, t12:1
        t14: i32 = add nsw t12, Constant:i32<-1>
      t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64
          t17: i64 = sign_extend t12
        t18: i64 = shl t17, Constant:i64<2>
      t19: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t18
    t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t19, undef:i64
  t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>



Combining: t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>

Combining: t21: ch = BasicBlock<if.end31 0x7748540>

Combining: t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t19, undef:i64

Combining: t19: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t18
Creating new node: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0
 ... into: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t23, undef:i64

Combining: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t18: i64 = shl t17, Constant:i64<2>

Combining: t17: i64 = sign_extend t12
Creating new node: t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Replacing.1 t17: i64 = sign_extend t12

With: t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
 and 0 other values
Creating new node: t25: i32 = truncate t24

Replacing.1 t12: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

With: t25: i32 = truncate t24
 and 1 other values

Combining: t25: i32 = truncate t24

Combining: t18: i64 = shl t24, Constant:i64<2>

Combining: t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Combining: t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64

Combining: t15: ch = TokenFactor t4:1, t10:1, t24:1

Combining: t14: i32 = add nsw t25, Constant:i32<-1>

Combining: t13: i32 = Constant<-1>

Combining: t11: i64 = FrameIndex<3>

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t9, undef:i64

Combining: t9: i64 = add GlobalAddress:i64<[100 x i32]* @s> 0, t8
Creating new node: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
 ... into: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64

Combining: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Combining: t8: i64 = shl t5, Constant:i64<2>

Combining: t7: i64 = Constant<2>

Combining: t6: i64 = GlobalAddress<[100 x i32]* @s> 0

Combining: t5: i64 = sign_extend t4
Creating new node: t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Replacing.1 t5: i64 = sign_extend t4

With: t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
 and 0 other values

Combining: t8: i64 = shl t27, Constant:i64<2>

Combining: t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.16 'quick_sort:if.then25'
SelectionDAG has 21 nodes:
  t0: ch = EntryToken
      t8: i64 = shl t27, Constant:i64<2>
    t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
  t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64
  t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
  t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
        t15: ch = TokenFactor t27:1, t10:1, t24:1
          t25: i32 = truncate t24
        t14: i32 = add nsw t25, Constant:i32<-1>
      t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64
        t18: i64 = shl t24, Constant:i64<2>
      t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0
    t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t23, undef:i64
  t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>


Legalizing node: t21: ch = BasicBlock<if.end31 0x7748540>
Analyzing result type: ch
Legal result type
Legally typed node: t21: ch = BasicBlock<if.end31 0x7748540>

Legalizing node: t13: i32 = Constant<-1>
Analyzing result type: i32
Legal result type
Legally typed node: t13: i32 = Constant<-1>

Legalizing node: t11: i64 = FrameIndex<3>
Analyzing result type: i64
Legal result type
Legally typed node: t11: i64 = FrameIndex<3>

Legalizing node: t7: i64 = Constant<2>
Analyzing result type: i64
Legal result type
Legally typed node: t7: i64 = Constant<2>

Legalizing node: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Legally typed node: t6: i64 = GlobalAddress<[100 x i32]* @s> 0

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<2>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t11: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Legalizing node: t18: i64 = shl t24, Constant:i64<2>
Analyzing result type: i64
Legal result type
Analyzing operand: t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t7: i64 = Constant<2>
Legal operand
Legally typed node: t18: i64 = shl t24, Constant:i64<2>

Legalizing node: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Analyzing operand: t18: i64 = shl t24, Constant:i64<2>
Legal operand
Analyzing operand: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Legal operand
Legally typed node: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0

Legalizing node: t25: i32 = truncate t24
Analyzing result type: i32
Legal result type
Analyzing operand: t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Legally typed node: t25: i32 = truncate t24

Legalizing node: t14: i32 = add nsw t25, Constant:i32<-1>
Analyzing result type: i32
Legal result type
Analyzing operand: t25: i32 = truncate t24
Legal operand
Analyzing operand: t13: i32 = Constant<-1>
Legal operand
Legally typed node: t14: i32 = add nsw t25, Constant:i32<-1>

Legalizing node: t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Analyzing result type: i64
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Legalizing node: t8: i64 = shl t27, Constant:i64<2>
Analyzing result type: i64
Legal result type
Analyzing operand: t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t7: i64 = Constant<2>
Legal operand
Legally typed node: t8: i64 = shl t27, Constant:i64<2>

Legalizing node: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
Analyzing result type: i64
Legal result type
Analyzing operand: t8: i64 = shl t27, Constant:i64<2>
Legal operand
Analyzing operand: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Legal operand
Legally typed node: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0

Legalizing node: t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64

Legalizing node: t15: ch = TokenFactor t27:1, t10:1, t24:1
Analyzing result type: ch
Legal result type
Analyzing operand: t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64
Legal operand
Analyzing operand: t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Legally typed node: t15: ch = TokenFactor t27:1, t10:1, t24:1

Legalizing node: t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = TokenFactor t27:1, t10:1, t24:1
Legal operand
Analyzing operand: t14: i32 = add nsw t25, Constant:i32<-1>
Legal operand
Analyzing operand: t11: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64

Legalizing node: t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t23, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64
Legal operand
Analyzing operand: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t23, undef:i64

Legalizing node: t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>
Analyzing result type: ch
Legal result type
Analyzing operand: t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t23, undef:i64
Legal operand
Analyzing operand: t21: ch = BasicBlock<if.end31 0x7748540>
Legal operand
Legally typed node: t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>

Legalizing node: t65535: ch = handlenode t22
Analyzing result type: ch
Legal result type
Analyzing operand: t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>
Legal operand
Legally typed node: t65535: ch = handlenode t22

Type-legalized selection DAG: %bb.16 'quick_sort:if.then25'
SelectionDAG has 21 nodes:
  t0: ch = EntryToken
      t8: i64 = shl t27, Constant:i64<2>
    t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
  t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64
  t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
  t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
        t15: ch = TokenFactor t27:1, t10:1, t24:1
          t25: i32 = truncate t24
        t14: i32 = add nsw t25, Constant:i32<-1>
      t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64
        t18: i64 = shl t24, Constant:i64<2>
      t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0
    t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t23, undef:i64
  t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>



Legalizing: t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>
Legal node: nothing to do

Legalizing: t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t15: ch = TokenFactor t27:1, t10:1, t24:1
Legal node: nothing to do

Legalizing: t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64
Legalizing non-extending load operation

Legalizing: t23: i64 = add t18, GlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t14: i32 = add nsw t25, Constant:i32<-1>
Legal node: nothing to do

Legalizing: t26: i64 = add t8, GlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t18: i64 = shl t24, Constant:i64<2>
Creating constant: t28: i8 = Constant<2>
Legal node: nothing to do

Legalizing: t25: i32 = truncate t24
Legal node: nothing to do

Legalizing: t8: i64 = shl t27, Constant:i64<2>
Legal node: nothing to do

Legalizing: t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Legalizing extending load operation

Legalizing: t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legalizing extending load operation

Legalizing: t21: ch = BasicBlock<if.end31 0x7748540>
Legal node: nothing to do

Legalizing: t13: i32 = Constant<-1>
Legal node: nothing to do

Legalizing: t11: i64 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
Trying custom legalization
Creating new node: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Successfully custom legalized node
 ... replacing: t6: i64 = GlobalAddress<[100 x i32]* @s> 0
     with:      t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t29: i64 = TargetGlobalAddress<[100 x i32]* @s> 0
Legal node: nothing to do

Legalizing: t28: i8 = Constant<2>
Legal node: nothing to do
Legalized selection DAG: %bb.16 'quick_sort:if.then25'
SelectionDAG has 22 nodes:
  t0: ch = EntryToken
  t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
  t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
      t8: i64 = shl t27, Constant:i8<2>
    t26: i64 = add t8, t30
  t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64
  t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
        t15: ch = TokenFactor t27:1, t10:1, t24:1
          t25: i32 = truncate t24
        t14: i32 = add nsw t25, Constant:i32<-1>
      t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64
        t18: i64 = shl t24, Constant:i8<2>
      t23: i64 = add t18, t30
    t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t23, undef:i64
  t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>



Legalizing: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
Legal node: nothing to do

Combining: t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0

Legalizing: t29: i64 = TargetGlobalAddress<[100 x i32]* @s> 0
Legal node: nothing to do

Combining: t29: i64 = TargetGlobalAddress<[100 x i32]* @s> 0

Legalizing: t28: i8 = Constant<2>
Legal node: nothing to do

Combining: t28: i8 = Constant<2>

Legalizing: t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>
Legal node: nothing to do

Combining: t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>

Legalizing: t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t23, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t23, undef:i64

Legalizing: t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64

Legalizing: t15: ch = TokenFactor t27:1, t10:1, t24:1
Legal node: nothing to do

Combining: t15: ch = TokenFactor t27:1, t10:1, t24:1

Legalizing: t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64
Legalizing non-extending load operation

Combining: t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64

Legalizing: t23: i64 = add t18, t30
Legal node: nothing to do

Combining: t23: i64 = add t18, t30

Legalizing: t14: i32 = add nsw t25, Constant:i32<-1>
Legal node: nothing to do

Combining: t14: i32 = add nsw t25, Constant:i32<-1>

Legalizing: t26: i64 = add t8, t30
Legal node: nothing to do

Combining: t26: i64 = add t8, t30

Legalizing: t18: i64 = shl t24, Constant:i8<2>
Legal node: nothing to do

Combining: t18: i64 = shl t24, Constant:i8<2>

Legalizing: t25: i32 = truncate t24
Legal node: nothing to do

Combining: t25: i32 = truncate t24

Legalizing: t8: i64 = shl t27, Constant:i8<2>
Legal node: nothing to do

Combining: t8: i64 = shl t27, Constant:i8<2>

Legalizing: t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
Legalizing extending load operation

Combining: t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64

Legalizing: t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
Legalizing extending load operation

Combining: t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64

Legalizing: t21: ch = BasicBlock<if.end31 0x7748540>
Legal node: nothing to do

Combining: t21: ch = BasicBlock<if.end31 0x7748540>

Legalizing: t13: i32 = Constant<-1>
Legal node: nothing to do

Combining: t13: i32 = Constant<-1>

Legalizing: t11: i64 = FrameIndex<3>
Legal node: nothing to do

Combining: t11: i64 = FrameIndex<3>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<2>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.16 'quick_sort:if.then25'
SelectionDAG has 22 nodes:
  t0: ch = EntryToken
  t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
  t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
      t8: i64 = shl t27, Constant:i8<2>
    t26: i64 = add t8, t30
  t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64
  t30: i64 = X86ISD::Wrapper TargetGlobalAddress:i64<[100 x i32]* @s> 0
        t15: ch = TokenFactor t27:1, t10:1, t24:1
          t25: i32 = truncate t24
        t14: i32 = add nsw t25, Constant:i32<-1>
      t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64
        t18: i64 = shl t24, Constant:i8<2>
      t23: i64 = add t18, t30
    t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t23, undef:i64
  t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>


===== Instruction selection begins: %bb.16 'if.then25'

ISEL: Starting selection on root node: t22: ch = br t20, BasicBlock:ch<if.end31 0x7748540>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t22: ch = JMP_1 BasicBlock:ch<if.end31 0x7748540>, t20
ISEL: Match complete!

ISEL: Starting selection on root node: t20: ch = store<(store 4 into %ir.arrayidx30)> t16, t10, t23, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  Match failed at index 1029
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 4
IndexReg t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t32: i8 = TargetConstant<4>
  Morphed node: t20: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx30)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10, t16
ISEL: Match complete!

ISEL: Starting selection on root node: t16: ch = store<(store 4 into %ir.j)> t15, t14, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  OpcodeSwitch from 1029 to 5817
  Match failed at index 5821
  Continuing at 6606
  Match failed at index 6616
  Continuing at 6659
  Match failed at index 6664
  Continuing at 6707
  Match failed at index 6712
  Continuing at 6755
  Continuing at 6756
  Match failed at index 6759
  Continuing at 6886
  Match failed at index 6890
  Continuing at 7016
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t36: i8 = TargetConstant<1>
Creating constant: t37: i32 = TargetConstant<0>
  Morphed node: t16: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t14, t15
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch = TokenFactor t27:1, t10:1, t24:1

ISEL: Starting selection on root node: t10: i32,ch = load<(load 4 from %ir.arrayidx27)> t0, t26, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 4
IndexReg t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx27)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t14: i32 = add nsw t25, Constant:i32<-1>
ISEL: Starting pattern match
  Initial Opcode index to 17918
  Skipped scope entry (due to false predicate) at index 17924, continuing at 17944
  Match failed at index 17946
  Continuing at 18049
  Continuing at 18050
  Match failed at index 18053
  Continuing at 18230
  Match failed at index 18233
  Continuing at 18300
  TypeSwitch[i32] from 18302 to 18305
  Skipped scope entry (due to false predicate) at index 18307, continuing at 18323
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg t25: i32 = truncate t24
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Match failed at index 18326
  Continuing at 18340
  Continuing at 18358
  Match failed at index 18361
  Continuing at 18382
  Match failed at index 18384
  Continuing at 18406
  Skipped scope entry (due to false predicate) at index 18411, continuing at 18463
  TypeSwitch[i32] from 18475 to 18502
  Match failed at index 18502
  Continuing at 18525
  Match failed at index 18526
  Continuing at 18600
  Match failed at index 18601
  Continuing at 18630
  Match failed at index 18644
  Continuing at 18657
Creating constant: t38: i32 = TargetConstant<-1>
  Morphed node: t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<-1>
ISEL: Match complete!

ISEL: Starting selection on root node: t25: i32 = truncate t24
ISEL: Starting pattern match
  Initial Opcode index to 145104
  Match failed at index 145108
  Continuing at 145249
  TypeSwitch[i32] from 145252 to 145287
Creating constant: t39: i32 = TargetConstant<6>
  Morphed node: t25: i32 = EXTRACT_SUBREG t24, TargetConstant:i32<6>
ISEL: Match complete!

ISEL: Starting selection on root node: t24: i64,ch = load<(dereferenceable load 4 from %ir.j), sext from i32> t0, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Skipped scope entry (due to false predicate) at index 137189, continuing at 137208
  Skipped scope entry (due to false predicate) at index 137209, continuing at 137228
  Skipped scope entry (due to false predicate) at index 137229, continuing at 137248
  Skipped scope entry (due to false predicate) at index 137249, continuing at 137268
  Match failed at index 137271
  Continuing at 137311
  Match failed at index 137312
  Continuing at 137354
  Skipped scope entry (due to false predicate) at index 137361, continuing at 137378
  Skipped scope entry (due to false predicate) at index 137379, continuing at 137396
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t27: i64,ch = load<(dereferenceable load 4 from %ir.i), sext from i32> t0, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Skipped scope entry (due to false predicate) at index 137189, continuing at 137208
  Skipped scope entry (due to false predicate) at index 137209, continuing at 137228
  Skipped scope entry (due to false predicate) at index 137229, continuing at 137248
  Skipped scope entry (due to false predicate) at index 137249, continuing at 137268
  Match failed at index 137271
  Continuing at 137311
  Match failed at index 137312
  Continuing at 137354
  Skipped scope entry (due to false predicate) at index 137361, continuing at 137378
  Skipped scope entry (due to false predicate) at index 137379, continuing at 137396
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t27: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t21: ch = BasicBlock<if.end31 0x7748540>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.16 'quick_sort:if.then25'
SelectionDAG has 21 nodes:
  t0: ch = EntryToken
  t27: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
  t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
  t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx27)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0
          t25: i32 = EXTRACT_SUBREG t24, TargetConstant:i32<6>
        t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<-1>
        t15: ch = TokenFactor t27:1, t10:1, t24:1
      t16: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t14, t15
    t20: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx30)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10, t16
  t22: ch = JMP_1 BasicBlock:ch<if.end31 0x7748540>, t20


********** List Scheduling %bb.16 'if.then25' **********
SU(0): t22: ch = JMP_1 BasicBlock:ch<if.end31 0x7748540>, t20

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t20: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx30)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10, t16

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 1
  Predecessors:
    SU(8): Data Latency=1
    SU(7): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t16: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t14, t15

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
    SU(3): Ord  Latency=0 Barrier
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(3): t15: ch = TokenFactor t27:1, t10:1, t24:1

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(4): Ord  Latency=1 Barrier
    SU(7): Ord  Latency=1 Barrier
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(2): Ord  Latency=0 Barrier
SU(4): t27: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Ord  Latency=1 Barrier
    SU(7): Data Latency=1
SU(5): t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<-1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 3
  Predecessors:
    SU(6): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(6): t25: i32 = EXTRACT_SUBREG t24, TargetConstant:i32<6>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 4
  Predecessors:
    SU(8): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx27)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
SU(8): t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(1): Data Latency=1
    SU(3): Ord  Latency=1 Barrier
    SU(6): Data Latency=1

Examining Available:
Height 0: SU(0): t22: ch = JMP_1 BasicBlock:ch<if.end31 0x7748540>, t20


*** Scheduling [0]: SU(0): t22: ch = JMP_1 BasicBlock:ch<if.end31 0x7748540>, t20


Examining Available:
Height 1: SU(1): t20: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx30)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10, t16


*** Scheduling [1]: SU(1): t20: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx30)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10, t16


Examining Available:
Height 2: SU(2): t16: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t14, t15


*** Scheduling [2]: SU(2): t16: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t14, t15


Examining Available:
Height 2: SU(3): t15: ch = TokenFactor t27:1, t10:1, t24:1

Height 3: SU(5): t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<-1>


*** Scheduling [3]: SU(3): t15: ch = TokenFactor t27:1, t10:1, t24:1


Examining Available:
Height 3: SU(5): t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<-1>

Height 4: SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx27)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


*** Scheduling [4]: SU(5): t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<-1>


Examining Available:
Height 5: SU(6): t25: i32 = EXTRACT_SUBREG t24, TargetConstant:i32<6>

Height 4: SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx27)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


*** Scheduling [5]: SU(6): t25: i32 = EXTRACT_SUBREG t24, TargetConstant:i32<6>


Examining Available:
Height 6: SU(8): t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

Height 4: SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx27)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


*** Scheduling [6]: SU(8): t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


Examining Available:
Height 4: SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx27)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


*** Scheduling [7]: SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx27)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0


Examining Available:
Height 8: SU(4): t27: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [8]: SU(4): t27: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(4): t27: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(7): t10: i32,ch = MOV32rm<Mem:(load 4 from %ir.arrayidx27)> Register:i64 $noreg, TargetConstant:i8<4>, t27, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t0

SU(8): t24: i64,ch = MOVSX64rm32<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(6): t25: i32 = EXTRACT_SUBREG t24, TargetConstant:i32<6>

SU(5): t14: i32,i32 = ADD32ri8 nsw t25, TargetConstant:i32<-1>

SU(3): t15: ch = TokenFactor t27:1, t10:1, t24:1

SU(2): t16: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t14, t15

SU(1): t20: ch = MOV32mr<Mem:(store 4 into %ir.arrayidx30)> Register:i64 $noreg, TargetConstant:i8<4>, t24, TargetGlobalAddress:i32<[100 x i32]* @s> 0, Register:i32 $noreg, t10, t16

SU(0): t22: ch = JMP_1 BasicBlock:ch<if.end31 0x7748540>, t20


Total amount of phi nodes to update: 0
Creating new node: t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>
Initial selection DAG: %bb.17 'quick_sort:if.end31'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>



Combining: t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>

Combining: t1: ch = BasicBlock<while.cond 0x773fb48>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.17 'quick_sort:if.end31'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>


Legalizing node: t1: ch = BasicBlock<while.cond 0x773fb48>
Analyzing result type: ch
Legal result type
Legally typed node: t1: ch = BasicBlock<while.cond 0x773fb48>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: ch = BasicBlock<while.cond 0x773fb48>
Legal operand
Legally typed node: t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>

Legalizing node: t65535: ch = handlenode t2
Analyzing result type: ch
Legal result type
Analyzing operand: t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>
Legal operand
Legally typed node: t65535: ch = handlenode t2

Type-legalized selection DAG: %bb.17 'quick_sort:if.end31'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>



Legalizing: t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>
Legal node: nothing to do

Legalizing: t1: ch = BasicBlock<while.cond 0x773fb48>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.17 'quick_sort:if.end31'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>



Legalizing: t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>
Legal node: nothing to do

Combining: t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>

Legalizing: t1: ch = BasicBlock<while.cond 0x773fb48>
Legal node: nothing to do

Combining: t1: ch = BasicBlock<while.cond 0x773fb48>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.17 'quick_sort:if.end31'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>


===== Instruction selection begins: %bb.17 'if.end31'

ISEL: Starting selection on root node: t2: ch = br t0, BasicBlock:ch<while.cond 0x773fb48>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t2: ch = JMP_1 BasicBlock:ch<while.cond 0x773fb48>, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t1: ch = BasicBlock<while.cond 0x773fb48>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.17 'quick_sort:if.end31'
SelectionDAG has 3 nodes:
    t0: ch = EntryToken
  t2: ch = JMP_1 BasicBlock:ch<while.cond 0x773fb48>, t0


********** List Scheduling %bb.17 'if.end31' **********
SU(0): t2: ch = JMP_1 BasicBlock:ch<while.cond 0x773fb48>, t0

  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 0

Examining Available:
Height 0: SU(0): t2: ch = JMP_1 BasicBlock:ch<while.cond 0x773fb48>, t0


*** Scheduling [0]: SU(0): t2: ch = JMP_1 BasicBlock:ch<while.cond 0x773fb48>, t0

*** Final schedule ***
SU(0): t2: ch = JMP_1 BasicBlock:ch<while.cond 0x773fb48>, t0


Total amount of phi nodes to update: 0
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Creating constant: t5: i32 = Constant<1>
Creating new node: t6: i32 = add nsw t4, Constant:i32<1>
Creating new node: t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64
Creating new node: t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>
Initial selection DAG: %bb.14 'quick_sort:while.body21'
SelectionDAG has 10 nodes:
  t2: i64 = Constant<0>
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
      t6: i32 = add nsw t4, Constant:i32<1>
    t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64
  t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>



Combining: t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>

Combining: t8: ch = BasicBlock<while.cond14 0x77402b8>

Combining: t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64

Combining: t6: i32 = add nsw t4, Constant:i32<1>

Combining: t5: i32 = Constant<1>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<2>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.14 'quick_sort:while.body21'
SelectionDAG has 9 nodes:
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
      t6: i32 = add nsw t4, Constant:i32<1>
    t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64
  t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>


Legalizing node: t8: ch = BasicBlock<while.cond14 0x77402b8>
Analyzing result type: ch
Legal result type
Legally typed node: t8: ch = BasicBlock<while.cond14 0x77402b8>

Legalizing node: t5: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t5: i32 = Constant<1>

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<2>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<2>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Legalizing node: t6: i32 = add nsw t4, Constant:i32<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t5: i32 = Constant<1>
Legal operand
Legally typed node: t6: i32 = add nsw t4, Constant:i32<1>

Legalizing node: t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t6: i32 = add nsw t4, Constant:i32<1>
Legal operand
Analyzing operand: t1: i64 = FrameIndex<2>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64

Legalizing node: t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64
Legal operand
Analyzing operand: t8: ch = BasicBlock<while.cond14 0x77402b8>
Legal operand
Legally typed node: t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>

Legalizing node: t65535: ch = handlenode t9
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>
Legal operand
Legally typed node: t65535: ch = handlenode t9

Type-legalized selection DAG: %bb.14 'quick_sort:while.body21'
SelectionDAG has 9 nodes:
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
      t6: i32 = add nsw t4, Constant:i32<1>
    t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64
  t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>



Legalizing: t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>
Legal node: nothing to do

Legalizing: t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t6: i32 = add nsw t4, Constant:i32<1>
Legal node: nothing to do

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Legalizing: t8: ch = BasicBlock<while.cond14 0x77402b8>
Legal node: nothing to do

Legalizing: t5: i32 = Constant<1>
Legal node: nothing to do

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.14 'quick_sort:while.body21'
SelectionDAG has 9 nodes:
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
      t6: i32 = add nsw t4, Constant:i32<1>
    t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64
  t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>



Legalizing: t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>
Legal node: nothing to do

Combining: t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>

Legalizing: t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64

Legalizing: t6: i32 = add nsw t4, Constant:i32<1>
Legal node: nothing to do

Combining: t6: i32 = add nsw t4, Constant:i32<1>

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64

Legalizing: t8: ch = BasicBlock<while.cond14 0x77402b8>
Legal node: nothing to do

Combining: t8: ch = BasicBlock<while.cond14 0x77402b8>

Legalizing: t5: i32 = Constant<1>
Legal node: nothing to do

Combining: t5: i32 = Constant<1>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<2>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<2>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.14 'quick_sort:while.body21'
SelectionDAG has 9 nodes:
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
      t6: i32 = add nsw t4, Constant:i32<1>
    t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64
  t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>


===== Instruction selection begins: %bb.14 'while.body21'

ISEL: Starting selection on root node: t9: ch = br t7, BasicBlock:ch<while.cond14 0x77402b8>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t9: ch = JMP_1 BasicBlock:ch<while.cond14 0x77402b8>, t7
ISEL: Match complete!

ISEL: Starting selection on root node: t7: ch = store<(store 4 into %ir.i)> t4:1, t6, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  OpcodeSwitch from 1029 to 5817
  Match failed at index 5826
  Continuing at 6606
  Match failed at index 6616
  Continuing at 6659
  Match failed at index 6664
  Continuing at 6707
  Match failed at index 6712
  Continuing at 6755
  Continuing at 6756
  Match failed at index 6764
  Continuing at 6886
  Match failed at index 6890
  Continuing at 7016
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t12: i8 = TargetConstant<1>
Creating constant: t13: i32 = TargetConstant<0>
  Morphed node: t7: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6, t4:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i32 = add nsw t4, Constant:i32<1>
ISEL: Starting pattern match
  Initial Opcode index to 17918
  Skipped scope entry (due to false predicate) at index 17924, continuing at 17944
  Match failed at index 17946
  Continuing at 18049
  Continuing at 18050
  OpcodeSwitch from 18053 to 18057
  Match failed at index 18059
  Continuing at 18230
  Match failed at index 18233
  Continuing at 18300
  TypeSwitch[i32] from 18302 to 18305
  Skipped scope entry (due to false predicate) at index 18307, continuing at 18323
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Match failed at index 18326
  Continuing at 18340
  Continuing at 18358
  Match failed at index 18361
  Continuing at 18382
  Match failed at index 18384
  Continuing at 18406
  TypeSwitch[i32] from 18413 to 18440
  Match failed at index 18440
  Continuing at 18463
  Match failed at index 18464
  Continuing at 18525
  Match failed at index 18526
  Continuing at 18600
  Match failed at index 18601
  Continuing at 18630
  Match failed at index 18644
  Continuing at 18657
Creating constant: t15: i32 = TargetConstant<1>
  Morphed node: t6: i32,i32 = ADD32ri8 nsw t4, TargetConstant:i32<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load 4 from %ir.i)> t0, FrameIndex:i64<2>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch = BasicBlock<while.cond14 0x77402b8>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.14 'quick_sort:while.body21'
SelectionDAG has 12 nodes:
    t0: ch = EntryToken
  t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
      t6: i32,i32 = ADD32ri8 nsw t4, TargetConstant:i32<1>
    t7: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6, t4:1
  t9: ch = JMP_1 BasicBlock:ch<while.cond14 0x77402b8>, t7


********** List Scheduling %bb.14 'while.body21' **********
SU(0): t9: ch = JMP_1 BasicBlock:ch<while.cond14 0x77402b8>, t7

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t7: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6, t4:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(1): Ord  Latency=1 Barrier
    SU(3): Data Latency=1
SU(3): t6: i32,i32 = ADD32ri8 nsw t4, TargetConstant:i32<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t9: ch = JMP_1 BasicBlock:ch<while.cond14 0x77402b8>, t7


*** Scheduling [0]: SU(0): t9: ch = JMP_1 BasicBlock:ch<while.cond14 0x77402b8>, t7


Examining Available:
Height 1: SU(1): t7: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6, t4:1


*** Scheduling [1]: SU(1): t7: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6, t4:1


Examining Available:
Height 2: SU(3): t6: i32,i32 = ADD32ri8 nsw t4, TargetConstant:i32<1>


*** Scheduling [2]: SU(3): t6: i32,i32 = ADD32ri8 nsw t4, TargetConstant:i32<1>


Examining Available:
Height 3: SU(2): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [3]: SU(2): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(2): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(3): t6: i32,i32 = ADD32ri8 nsw t4, TargetConstant:i32<1>

SU(1): t7: ch = MOV32mr<Mem:(store 4 into %ir.i)> TargetFrameIndex:i64<2>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6, t4:1

SU(0): t9: ch = JMP_1 BasicBlock:ch<while.cond14 0x77402b8>, t7


Total amount of phi nodes to update: 0
Creating constant: t2: i64 = Constant<0>
Creating new node: t3: i64 = undef
Creating new node: t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Creating constant: t5: i32 = Constant<-1>
Creating new node: t6: i32 = add nsw t4, Constant:i32<-1>
Creating new node: t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64
Creating new node: t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>
Initial selection DAG: %bb.7 'quick_sort:while.body7'
SelectionDAG has 10 nodes:
  t2: i64 = Constant<0>
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t6: i32 = add nsw t4, Constant:i32<-1>
    t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64
  t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>



Combining: t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>

Combining: t8: ch = BasicBlock<while.cond2 0x773fcd8>

Combining: t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64

Combining: t6: i32 = add nsw t4, Constant:i32<-1>

Combining: t5: i32 = Constant<-1>

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Combining: t3: i64 = undef

Combining: t1: i64 = FrameIndex<3>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.7 'quick_sort:while.body7'
SelectionDAG has 9 nodes:
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t6: i32 = add nsw t4, Constant:i32<-1>
    t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64
  t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>


Legalizing node: t8: ch = BasicBlock<while.cond2 0x773fcd8>
Analyzing result type: ch
Legal result type
Legally typed node: t8: ch = BasicBlock<while.cond2 0x773fcd8>

Legalizing node: t5: i32 = Constant<-1>
Analyzing result type: i32
Legal result type
Legally typed node: t5: i32 = Constant<-1>

Legalizing node: t3: i64 = undef
Analyzing result type: i64
Legal result type
Legally typed node: t3: i64 = undef

Legalizing node: t1: i64 = FrameIndex<3>
Analyzing result type: i64
Legal result type
Legally typed node: t1: i64 = FrameIndex<3>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Legalizing node: t6: i32 = add nsw t4, Constant:i32<-1>
Analyzing result type: i32
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t5: i32 = Constant<-1>
Legal operand
Legally typed node: t6: i32 = add nsw t4, Constant:i32<-1>

Legalizing node: t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64
Analyzing result type: ch
Legal result type
Analyzing operand: t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t6: i32 = add nsw t4, Constant:i32<-1>
Legal operand
Analyzing operand: t1: i64 = FrameIndex<3>
Legal operand
Analyzing operand: t3: i64 = undef
Legal operand
Legally typed node: t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64

Legalizing node: t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64
Legal operand
Analyzing operand: t8: ch = BasicBlock<while.cond2 0x773fcd8>
Legal operand
Legally typed node: t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>

Legalizing node: t65535: ch = handlenode t9
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>
Legal operand
Legally typed node: t65535: ch = handlenode t9

Type-legalized selection DAG: %bb.7 'quick_sort:while.body7'
SelectionDAG has 9 nodes:
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t6: i32 = add nsw t4, Constant:i32<-1>
    t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64
  t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>



Legalizing: t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>
Legal node: nothing to do

Legalizing: t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t6: i32 = add nsw t4, Constant:i32<-1>
Legal node: nothing to do

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Legalizing: t8: ch = BasicBlock<while.cond2 0x773fcd8>
Legal node: nothing to do

Legalizing: t5: i32 = Constant<-1>
Legal node: nothing to do

Legalizing: t3: i64 = undef
Legal node: nothing to do

Legalizing: t1: i64 = FrameIndex<3>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.7 'quick_sort:while.body7'
SelectionDAG has 9 nodes:
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t6: i32 = add nsw t4, Constant:i32<-1>
    t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64
  t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>



Legalizing: t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>
Legal node: nothing to do

Combining: t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>

Legalizing: t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64

Legalizing: t6: i32 = add nsw t4, Constant:i32<-1>
Legal node: nothing to do

Combining: t6: i32 = add nsw t4, Constant:i32<-1>

Legalizing: t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
Legalizing non-extending load operation

Combining: t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64

Legalizing: t8: ch = BasicBlock<while.cond2 0x773fcd8>
Legal node: nothing to do

Combining: t8: ch = BasicBlock<while.cond2 0x773fcd8>

Legalizing: t5: i32 = Constant<-1>
Legal node: nothing to do

Combining: t5: i32 = Constant<-1>

Legalizing: t3: i64 = undef
Legal node: nothing to do

Combining: t3: i64 = undef

Legalizing: t1: i64 = FrameIndex<3>
Legal node: nothing to do

Combining: t1: i64 = FrameIndex<3>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.7 'quick_sort:while.body7'
SelectionDAG has 9 nodes:
    t0: ch = EntryToken
  t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
      t6: i32 = add nsw t4, Constant:i32<-1>
    t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64
  t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>


===== Instruction selection begins: %bb.7 'while.body7'

ISEL: Starting selection on root node: t9: ch = br t7, BasicBlock:ch<while.cond2 0x773fcd8>
ISEL: Starting pattern match
  Initial Opcode index to 151806
  Morphed node: t9: ch = JMP_1 BasicBlock:ch<while.cond2 0x773fcd8>, t7
ISEL: Match complete!

ISEL: Starting selection on root node: t7: ch = store<(store 4 into %ir.j)> t4:1, t6, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 6
  Skipped scope entry (due to false predicate) at index 14, continuing at 81
  Skipped scope entry (due to false predicate) at index 82, continuing at 149
  Skipped scope entry (due to false predicate) at index 150, continuing at 199
  Skipped scope entry (due to false predicate) at index 200, continuing at 249
  Skipped scope entry (due to false predicate) at index 250, continuing at 317
  Skipped scope entry (due to false predicate) at index 318, continuing at 367
  Match failed at index 375
  Continuing at 394
  Match failed at index 395
  Continuing at 421
  Match failed at index 422
  Continuing at 471
  Match failed at index 472
  Continuing at 521
  Match failed at index 522
  Continuing at 571
  Match failed at index 572
  Continuing at 639
  Match failed at index 640
  Continuing at 707
  Match failed at index 708
  Continuing at 775
  Match failed at index 776
  Continuing at 804
  Match failed at index 805
  Continuing at 833
  Match failed at index 834
  Continuing at 862
  Match failed at index 863
  Continuing at 891
  Match failed at index 892
  Continuing at 920
  Match failed at index 921
  Continuing at 949
  Match failed at index 950
  Continuing at 987
  Match failed at index 988
  Continuing at 1025
  Continuing at 1026
  OpcodeSwitch from 1029 to 5817
  Match failed at index 5826
  Continuing at 6606
  Match failed at index 6616
  Continuing at 6659
  Match failed at index 6664
  Continuing at 6707
  Match failed at index 6712
  Continuing at 6755
  Continuing at 6756
  Match failed at index 6764
  Continuing at 6886
  Match failed at index 6890
  Continuing at 7016
  Continuing at 13402
  Match failed at index 13406
  Continuing at 14424
  Match failed at index 14427
  Continuing at 14691
  Match failed at index 14692
  Continuing at 14783
  Match failed at index 14784
  Continuing at 14911
  TypeSwitch[i32] from 14914 to 15007
  Match failed at index 15015
  Continuing at 15034
  Match failed at index 15037
  Continuing at 15351
  Skipped scope entry (due to false predicate) at index 15356, continuing at 15438
  Skipped scope entry (due to false predicate) at index 15439, continuing at 15547
  Skipped scope entry (due to false predicate) at index 15548, continuing at 15617
  Skipped scope entry (due to false predicate) at index 15618, continuing at 15640
  Skipped scope entry (due to false predicate) at index 15641, continuing at 15663
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
Creating constant: t12: i8 = TargetConstant<1>
Creating constant: t13: i32 = TargetConstant<0>
  Morphed node: t7: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6, t4:1
ISEL: Match complete!

ISEL: Starting selection on root node: t6: i32 = add nsw t4, Constant:i32<-1>
ISEL: Starting pattern match
  Initial Opcode index to 17918
  Skipped scope entry (due to false predicate) at index 17924, continuing at 17944
  Match failed at index 17946
  Continuing at 18049
  Continuing at 18050
  OpcodeSwitch from 18053 to 18057
  Match failed at index 18059
  Continuing at 18230
  Match failed at index 18233
  Continuing at 18300
  TypeSwitch[i32] from 18302 to 18305
  Skipped scope entry (due to false predicate) at index 18307, continuing at 18323
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
MatchAddress: X86ISelAddressMode 0x7fffa2e6c4b0
Base_Reg t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Match failed at index 18326
  Continuing at 18340
  Continuing at 18358
  Match failed at index 18361
  Continuing at 18382
  Match failed at index 18384
  Continuing at 18406
  Skipped scope entry (due to false predicate) at index 18411, continuing at 18463
  TypeSwitch[i32] from 18475 to 18502
  Match failed at index 18502
  Continuing at 18525
  Match failed at index 18526
  Continuing at 18600
  Match failed at index 18601
  Continuing at 18630
  Match failed at index 18644
  Continuing at 18657
Creating constant: t15: i32 = TargetConstant<-1>
  Morphed node: t6: i32,i32 = ADD32ri8 nsw t4, TargetConstant:i32<-1>
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = load<(dereferenceable load 4 from %ir.j)> t0, FrameIndex:i64<3>, undef:i64
ISEL: Starting pattern match
  Initial Opcode index to 137182
  Match failed at index 137191
  Continuing at 137208
  Match failed at index 137211
  Continuing at 137228
MatchAddress: X86ISelAddressMode 0x7fffa2e6c5f0
Base_Reg nul
 Scale 1
IndexReg nul
 Disp 0
GV nul CP nul
ES nul MCSym nul JT-1 Align0
  Morphed node: t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch = BasicBlock<while.cond2 0x773fcd8>

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.7 'quick_sort:while.body7'
SelectionDAG has 12 nodes:
    t0: ch = EntryToken
  t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0
      t6: i32,i32 = ADD32ri8 nsw t4, TargetConstant:i32<-1>
    t7: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6, t4:1
  t9: ch = JMP_1 BasicBlock:ch<while.cond2 0x773fcd8>, t7


********** List Scheduling %bb.7 'while.body7' **********
SU(0): t9: ch = JMP_1 BasicBlock:ch<while.cond2 0x773fcd8>, t7

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t7: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6, t4:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(1): Ord  Latency=1 Barrier
    SU(3): Data Latency=1
SU(3): t6: i32,i32 = ADD32ri8 nsw t4, TargetConstant:i32<-1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t9: ch = JMP_1 BasicBlock:ch<while.cond2 0x773fcd8>, t7


*** Scheduling [0]: SU(0): t9: ch = JMP_1 BasicBlock:ch<while.cond2 0x773fcd8>, t7


Examining Available:
Height 1: SU(1): t7: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6, t4:1


*** Scheduling [1]: SU(1): t7: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6, t4:1


Examining Available:
Height 2: SU(3): t6: i32,i32 = ADD32ri8 nsw t4, TargetConstant:i32<-1>


*** Scheduling [2]: SU(3): t6: i32,i32 = ADD32ri8 nsw t4, TargetConstant:i32<-1>


Examining Available:
Height 3: SU(2): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0


*** Scheduling [3]: SU(2): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

*** Final schedule ***
SU(2): t4: i32,ch = MOV32rm<Mem:(dereferenceable load 4 from %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t0

SU(3): t6: i32,i32 = ADD32ri8 nsw t4, TargetConstant:i32<-1>

SU(1): t7: ch = MOV32mr<Mem:(store 4 into %ir.j)> TargetFrameIndex:i64<3>, TargetConstant:i8<1>, Register:i64 $noreg, TargetConstant:i32<0>, Register:i32 $noreg, t6, t4:1

SU(0): t9: ch = JMP_1 BasicBlock:ch<while.cond2 0x773fcd8>, t7


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function quick_sort: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=4, align=4, at location [SP+8]
  fi#3: size=4, align=4, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
Function Live Ins: $edi in %4, $esi in %5

bb.0.entry:
  successors: %bb.1, %bb.19
  liveins: $edi, $esi
  %5:gr32 = COPY $esi
  %4:gr32 = COPY $edi
  MOV32mr %stack.0.l.addr, 1, $noreg, 0, $noreg, %4:gr32 :: (store 4 into %ir.l.addr)
  MOV32mr %stack.1.r.addr, 1, $noreg, 0, $noreg, %5:gr32 :: (store 4 into %ir.r.addr)
  %6:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
  %7:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
  %8:gr32 = SUB32rr %6:gr32, killed %7:gr32, implicit-def $eflags
  JGE_1 %bb.19, implicit $eflags
  JMP_1 %bb.1

bb.1.if.then:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(200.00%)

  %9:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed %9:gr32 :: (store 4 into %ir.i)
  %10:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed %10:gr32 :: (store 4 into %ir.j)
  %11:gr64_nosp = MOVSX64rm32 %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
  %12:gr32 = MOV32rm $noreg, 4, killed %11:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx)
  MOV32mr %stack.4.x, 1, $noreg, 0, $noreg, killed %12:gr32 :: (store 4 into %ir.x)
  JMP_1 %bb.2

bb.2.while.cond:
; predecessors: %bb.1, %bb.17
  successors: %bb.3, %bb.18

  %13:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %14:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
  %15:gr32 = SUB32rr %13:gr32, killed %14:gr32, implicit-def $eflags
  JGE_1 %bb.18, implicit $eflags
  JMP_1 %bb.3

bb.3.while.body:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(200.00%)

  JMP_1 %bb.4

bb.4.while.cond2:
; predecessors: %bb.3, %bb.7
  successors: %bb.5, %bb.6

  %25:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %26:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
  %27:gr32 = MOV32r0 implicit-def dead $eflags
  %24:gr8 = COPY %27.sub_8bit:gr32
  %28:gr32 = SUB32rr %25:gr32, killed %26:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.land.rhs:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(200.00%)

  %29:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
  %30:gr32 = MOV32rm $noreg, 4, killed %29:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx5)
  %31:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
  %32:gr32 = SUB32rr %30:gr32, killed %31:gr32, implicit-def $eflags
  %0:gr8 = SETGEr implicit $eflags
  JMP_1 %bb.6

bb.6.land.end:
; predecessors: %bb.4, %bb.5
  successors: %bb.7, %bb.8

  %1:gr8 = PHI %24:gr8, %bb.4, %0:gr8, %bb.5
  TEST8ri %1:gr8, 1, implicit-def $eflags
  JE_1 %bb.8, implicit $eflags
  JMP_1 %bb.7

bb.7.while.body7:
; predecessors: %bb.6
  successors: %bb.4(0x80000000); %bb.4(200.00%)

  %60:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
  %61:gr32 = ADD32ri8 %60:gr32, -1, implicit-def dead $eflags
  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed %61:gr32 :: (store 4 into %ir.j)
  JMP_1 %bb.4

bb.8.while.end:
; predecessors: %bb.6
  successors: %bb.9, %bb.10

  %33:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %34:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
  %35:gr32 = SUB32rr %33:gr32, killed %34:gr32, implicit-def $eflags
  JGE_1 %bb.10, implicit $eflags
  JMP_1 %bb.9

bb.9.if.then9:
; predecessors: %bb.8
  successors: %bb.10(0x80000000); %bb.10(200.00%)

  %36:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
  %37:gr32 = MOV32rm $noreg, 4, killed %36:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx11)
  %38:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %39:gr32 = COPY %38.sub_32bit:gr64_nosp
  %40:gr32 = ADD32ri8 %39:gr32, 1, implicit-def dead $eflags
  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed %40:gr32 :: (store 4 into %ir.i)
  MOV32mr $noreg, 4, %38:gr64_nosp, @s, $noreg, killed %37:gr32 :: (store 4 into %ir.arrayidx13)
  JMP_1 %bb.10

bb.10.if.end:
; predecessors: %bb.8, %bb.9
  successors: %bb.11(0x80000000); %bb.11(200.00%)

  JMP_1 %bb.11

bb.11.while.cond14:
; predecessors: %bb.10, %bb.14
  successors: %bb.12, %bb.13

  %42:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %43:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
  %44:gr32 = MOV32r0 implicit-def dead $eflags
  %41:gr8 = COPY %44.sub_8bit:gr32
  %45:gr32 = SUB32rr %42:gr32, killed %43:gr32, implicit-def $eflags
  JGE_1 %bb.13, implicit $eflags
  JMP_1 %bb.12

bb.12.land.rhs16:
; predecessors: %bb.11
  successors: %bb.13(0x80000000); %bb.13(200.00%)

  %46:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %47:gr32 = MOV32rm $noreg, 4, killed %46:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx18)
  %48:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
  %49:gr32 = SUB32rr %47:gr32, killed %48:gr32, implicit-def $eflags
  %2:gr8 = SETLr implicit $eflags
  JMP_1 %bb.13

bb.13.land.end20:
; predecessors: %bb.11, %bb.12
  successors: %bb.14, %bb.15

  %3:gr8 = PHI %41:gr8, %bb.11, %2:gr8, %bb.12
  TEST8ri %3:gr8, 1, implicit-def $eflags
  JE_1 %bb.15, implicit $eflags
  JMP_1 %bb.14

bb.14.while.body21:
; predecessors: %bb.13
  successors: %bb.11(0x80000000); %bb.11(200.00%)

  %58:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %59:gr32 = ADD32ri8 %58:gr32, 1, implicit-def dead $eflags
  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed %59:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.11

bb.15.while.end23:
; predecessors: %bb.13
  successors: %bb.16, %bb.17

  %50:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %51:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
  %52:gr32 = SUB32rr %50:gr32, killed %51:gr32, implicit-def $eflags
  JGE_1 %bb.17, implicit $eflags
  JMP_1 %bb.16

bb.16.if.then25:
; predecessors: %bb.15
  successors: %bb.17(0x80000000); %bb.17(200.00%)

  %53:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %54:gr32 = MOV32rm $noreg, 4, killed %53:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx27)
  %55:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
  %56:gr32 = COPY %55.sub_32bit:gr64_nosp
  %57:gr32 = ADD32ri8 %56:gr32, -1, implicit-def dead $eflags
  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed %57:gr32 :: (store 4 into %ir.j)
  MOV32mr $noreg, 4, %55:gr64_nosp, @s, $noreg, killed %54:gr32 :: (store 4 into %ir.arrayidx30)
  JMP_1 %bb.17

bb.17.if.end31:
; predecessors: %bb.15, %bb.16
  successors: %bb.2(0x80000000); %bb.2(200.00%)

  JMP_1 %bb.2

bb.18.while.end32:
; predecessors: %bb.2
  successors: %bb.19(0x80000000); %bb.19(200.00%)

  %16:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
  %17:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV32mr $noreg, 4, killed %17:gr64_nosp, @s, $noreg, killed %16:gr32 :: (store 4 into %ir.arrayidx34)
  %18:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
  %19:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %20:gr32 = ADD32ri8 %19:gr32, -1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %18:gr32
  $esi = COPY %20:gr32
  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %21:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %22:gr32 = ADD32ri8 %21:gr32, 1, implicit-def dead $eflags
  %23:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $edi = COPY %22:gr32
  $esi = COPY %23:gr32
  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  JMP_1 %bb.19

bb.19.if.end35:
; predecessors: %bb.0, %bb.18

  RET 0

# End machine code for function quick_sort.


Restoring optimization level for Function quick_sort
	Before: -O0 ; After: -O2
	discovered a new reachable node %bb.0
	discovered a new reachable node %bb.1
	discovered a new reachable node %bb.2
	discovered a new reachable node %bb.3
	discovered a new reachable node %bb.4
	discovered a new reachable node %bb.5
	discovered a new reachable node %bb.6
	discovered a new reachable node %bb.7
	discovered a new reachable node %bb.8
	discovered a new reachable node %bb.9
	discovered a new reachable node %bb.10
	discovered a new reachable node %bb.11
	discovered a new reachable node %bb.12
	discovered a new reachable node %bb.13
	discovered a new reachable node %bb.14
	discovered a new reachable node %bb.15
	discovered a new reachable node %bb.16
	discovered a new reachable node %bb.17
	discovered a new reachable node %bb.18
	discovered a new reachable node %bb.19
Skipping pass 'Local Dynamic TLS Access Clean-up' on function quick_sort
Skipping pass 'X86 Domain Reassignment Pass' on function quick_sort
Skipping pass 'Early Tail Duplication' on function quick_sort
Skipping pass 'Optimize machine instruction PHIs' on function quick_sort
# Machine code for function quick_sort: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=4, align=4, at location [SP+8]
  fi#3: size=4, align=4, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
Function Live Ins: $edi in %4, $esi in %5

0B	bb.0.entry:
	  successors: %bb.1, %bb.19
	  liveins: $edi, $esi
16B	  %5:gr32 = COPY $esi
32B	  %4:gr32 = COPY $edi
48B	  MOV32mr %stack.0.l.addr, 1, $noreg, 0, $noreg, %4:gr32 :: (store 4 into %ir.l.addr)
64B	  MOV32mr %stack.1.r.addr, 1, $noreg, 0, $noreg, %5:gr32 :: (store 4 into %ir.r.addr)
80B	  %6:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
96B	  %7:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
112B	  %8:gr32 = SUB32rr %6:gr32, killed %7:gr32, implicit-def $eflags
128B	  JGE_1 %bb.19, implicit $eflags
144B	  JMP_1 %bb.1

160B	bb.1.if.then:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(200.00%)

176B	  %9:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
192B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed %9:gr32 :: (store 4 into %ir.i)
208B	  %10:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
224B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed %10:gr32 :: (store 4 into %ir.j)
240B	  %11:gr64_nosp = MOVSX64rm32 %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
256B	  %12:gr32 = MOV32rm $noreg, 4, killed %11:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx)
272B	  MOV32mr %stack.4.x, 1, $noreg, 0, $noreg, killed %12:gr32 :: (store 4 into %ir.x)
288B	  JMP_1 %bb.2

304B	bb.2.while.cond:
	; predecessors: %bb.1, %bb.17
	  successors: %bb.3, %bb.18

320B	  %13:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
336B	  %14:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
352B	  %15:gr32 = SUB32rr %13:gr32, killed %14:gr32, implicit-def $eflags
368B	  JGE_1 %bb.18, implicit $eflags
384B	  JMP_1 %bb.3

400B	bb.3.while.body:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(200.00%)

416B	  JMP_1 %bb.4

432B	bb.4.while.cond2:
	; predecessors: %bb.3, %bb.7
	  successors: %bb.5, %bb.6

448B	  %25:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
464B	  %26:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
480B	  %27:gr32 = MOV32r0 implicit-def dead $eflags
496B	  %24:gr8 = COPY %27.sub_8bit:gr32
512B	  %28:gr32 = SUB32rr %25:gr32, killed %26:gr32, implicit-def $eflags
528B	  JGE_1 %bb.6, implicit $eflags
544B	  JMP_1 %bb.5

560B	bb.5.land.rhs:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(200.00%)

576B	  %29:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
592B	  %30:gr32 = MOV32rm $noreg, 4, killed %29:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx5)
608B	  %31:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
624B	  %32:gr32 = SUB32rr %30:gr32, killed %31:gr32, implicit-def $eflags
640B	  %0:gr8 = SETGEr implicit $eflags
656B	  JMP_1 %bb.6

672B	bb.6.land.end:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7, %bb.8

688B	  %1:gr8 = PHI %24:gr8, %bb.4, %0:gr8, %bb.5
704B	  TEST8ri %1:gr8, 1, implicit-def $eflags
720B	  JE_1 %bb.8, implicit $eflags
736B	  JMP_1 %bb.7

752B	bb.7.while.body7:
	; predecessors: %bb.6
	  successors: %bb.4(0x80000000); %bb.4(200.00%)

768B	  %60:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
784B	  %61:gr32 = ADD32ri8 %60:gr32, -1, implicit-def dead $eflags
800B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed %61:gr32 :: (store 4 into %ir.j)
816B	  JMP_1 %bb.4

832B	bb.8.while.end:
	; predecessors: %bb.6
	  successors: %bb.9, %bb.10

848B	  %33:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
864B	  %34:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
880B	  %35:gr32 = SUB32rr %33:gr32, killed %34:gr32, implicit-def $eflags
896B	  JGE_1 %bb.10, implicit $eflags
912B	  JMP_1 %bb.9

928B	bb.9.if.then9:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(200.00%)

944B	  %36:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
960B	  %37:gr32 = MOV32rm $noreg, 4, killed %36:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx11)
976B	  %38:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
992B	  %39:gr32 = COPY %38.sub_32bit:gr64_nosp
1008B	  %40:gr32 = ADD32ri8 %39:gr32, 1, implicit-def dead $eflags
1024B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed %40:gr32 :: (store 4 into %ir.i)
1040B	  MOV32mr $noreg, 4, %38:gr64_nosp, @s, $noreg, killed %37:gr32 :: (store 4 into %ir.arrayidx13)
1056B	  JMP_1 %bb.10

1072B	bb.10.if.end:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x80000000); %bb.11(200.00%)

1088B	  JMP_1 %bb.11

1104B	bb.11.while.cond14:
	; predecessors: %bb.10, %bb.14
	  successors: %bb.12, %bb.13

1120B	  %42:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1136B	  %43:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1152B	  %44:gr32 = MOV32r0 implicit-def dead $eflags
1168B	  %41:gr8 = COPY %44.sub_8bit:gr32
1184B	  %45:gr32 = SUB32rr %42:gr32, killed %43:gr32, implicit-def $eflags
1200B	  JGE_1 %bb.13, implicit $eflags
1216B	  JMP_1 %bb.12

1232B	bb.12.land.rhs16:
	; predecessors: %bb.11
	  successors: %bb.13(0x80000000); %bb.13(200.00%)

1248B	  %46:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1264B	  %47:gr32 = MOV32rm $noreg, 4, killed %46:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx18)
1280B	  %48:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
1296B	  %49:gr32 = SUB32rr %47:gr32, killed %48:gr32, implicit-def $eflags
1312B	  %2:gr8 = SETLr implicit $eflags
1328B	  JMP_1 %bb.13

1344B	bb.13.land.end20:
	; predecessors: %bb.11, %bb.12
	  successors: %bb.14, %bb.15

1360B	  %3:gr8 = PHI %41:gr8, %bb.11, %2:gr8, %bb.12
1376B	  TEST8ri %3:gr8, 1, implicit-def $eflags
1392B	  JE_1 %bb.15, implicit $eflags
1408B	  JMP_1 %bb.14

1424B	bb.14.while.body21:
	; predecessors: %bb.13
	  successors: %bb.11(0x80000000); %bb.11(200.00%)

1440B	  %58:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1456B	  %59:gr32 = ADD32ri8 %58:gr32, 1, implicit-def dead $eflags
1472B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed %59:gr32 :: (store 4 into %ir.i)
1488B	  JMP_1 %bb.11

1504B	bb.15.while.end23:
	; predecessors: %bb.13
	  successors: %bb.16, %bb.17

1520B	  %50:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1536B	  %51:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1552B	  %52:gr32 = SUB32rr %50:gr32, killed %51:gr32, implicit-def $eflags
1568B	  JGE_1 %bb.17, implicit $eflags
1584B	  JMP_1 %bb.16

1600B	bb.16.if.then25:
	; predecessors: %bb.15
	  successors: %bb.17(0x80000000); %bb.17(200.00%)

1616B	  %53:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1632B	  %54:gr32 = MOV32rm $noreg, 4, killed %53:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx27)
1648B	  %55:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1664B	  %56:gr32 = COPY %55.sub_32bit:gr64_nosp
1680B	  %57:gr32 = ADD32ri8 %56:gr32, -1, implicit-def dead $eflags
1696B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed %57:gr32 :: (store 4 into %ir.j)
1712B	  MOV32mr $noreg, 4, %55:gr64_nosp, @s, $noreg, killed %54:gr32 :: (store 4 into %ir.arrayidx30)
1728B	  JMP_1 %bb.17

1744B	bb.17.if.end31:
	; predecessors: %bb.15, %bb.16
	  successors: %bb.2(0x80000000); %bb.2(200.00%)

1760B	  JMP_1 %bb.2

1776B	bb.18.while.end32:
	; predecessors: %bb.2
	  successors: %bb.19(0x80000000); %bb.19(200.00%)

1792B	  %16:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
1808B	  %17:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1824B	  MOV32mr $noreg, 4, killed %17:gr64_nosp, @s, $noreg, killed %16:gr32 :: (store 4 into %ir.arrayidx34)
1840B	  %18:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
1856B	  %19:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1872B	  %20:gr32 = ADD32ri8 %19:gr32, -1, implicit-def dead $eflags
1888B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1904B	  $edi = COPY %18:gr32
1920B	  $esi = COPY %20:gr32
1936B	  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
1952B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
1968B	  %21:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1984B	  %22:gr32 = ADD32ri8 %21:gr32, 1, implicit-def dead $eflags
2000B	  %23:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
2016B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2032B	  $edi = COPY %22:gr32
2048B	  $esi = COPY %23:gr32
2064B	  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
2080B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2096B	  JMP_1 %bb.19

2112B	bb.19.if.end35:
	; predecessors: %bb.0, %bb.18

2128B	  RET 0

# End machine code for function quick_sort.

********** Stack Coloring **********
********** Function: quick_sort
Found 0 markers and 5 slots
Slot structure:
Slot #0 - 4 bytes.
Slot #1 - 4 bytes.
Slot #2 - 4 bytes.
Slot #3 - 4 bytes.
Slot #4 - 4 bytes.
Total Stack size: 20 bytes

Will not try to merge slots.
Removed 0 markers.
Skipping pass 'Remove dead machine instructions' on function quick_sort
	discovered a new reachable node %bb.0
	discovered a new reachable node %bb.1
	discovered a new reachable node %bb.2
	discovered a new reachable node %bb.3
	discovered a new reachable node %bb.4
	discovered a new reachable node %bb.5
	discovered a new reachable node %bb.6
	discovered a new reachable node %bb.7
	discovered a new reachable node %bb.8
	discovered a new reachable node %bb.9
	discovered a new reachable node %bb.10
	discovered a new reachable node %bb.11
	discovered a new reachable node %bb.12
	discovered a new reachable node %bb.13
	discovered a new reachable node %bb.14
	discovered a new reachable node %bb.15
	discovered a new reachable node %bb.16
	discovered a new reachable node %bb.17
	discovered a new reachable node %bb.18
	discovered a new reachable node %bb.19
********** EARLY IF-CONVERSION **********
********** Function: quick_sort
Skipping pass 'Early If-Conversion' on function quick_sort
Machine InstCombiner: quick_sort
Combining MBB entry
Combining MBB if.then
Combining MBB while.cond
Combining MBB while.body
Combining MBB while.cond2
Combining MBB land.rhs
Combining MBB land.end
Combining MBB while.body7
Combining MBB while.end
Combining MBB if.then9
Combining MBB if.end
Combining MBB while.cond14
Combining MBB land.rhs16
Combining MBB land.end20
Combining MBB while.body21
Combining MBB while.end23
Combining MBB if.then25
Combining MBB if.end31
Combining MBB while.end32
Combining MBB if.end35
Skipping pass 'X86 cmov Conversion' on function quick_sort
	discovered a new reachable node %bb.0
	discovered a new reachable node %bb.1
	discovered a new reachable node %bb.2
	discovered a new reachable node %bb.3
	discovered a new reachable node %bb.4
	discovered a new reachable node %bb.5
	discovered a new reachable node %bb.6
	discovered a new reachable node %bb.7
	discovered a new reachable node %bb.8
	discovered a new reachable node %bb.9
	discovered a new reachable node %bb.10
	discovered a new reachable node %bb.11
	discovered a new reachable node %bb.12
	discovered a new reachable node %bb.13
	discovered a new reachable node %bb.14
	discovered a new reachable node %bb.15
	discovered a new reachable node %bb.16
	discovered a new reachable node %bb.17
	discovered a new reachable node %bb.18
	discovered a new reachable node %bb.19
Skipping pass 'Early Machine Loop Invariant Code Motion' on function quick_sort
Skipping pass 'Machine Common Subexpression Elimination' on function quick_sort
		Looking for trivial roots
Found a new trivial root: %bb.19
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 20, Num: 21
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.19
3: %bb.18
4: %bb.2
5: %bb.17
6: %bb.16
7: %bb.15
8: %bb.13
9: %bb.12
10: %bb.11
11: %bb.14
12: %bb.10
13: %bb.9
14: %bb.8
15: %bb.6
16: %bb.5
17: %bb.4
18: %bb.7
19: %bb.3
20: %bb.1
21: %bb.0
Found roots: %bb.19 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.19
	discovered a new reachable node %bb.18
	discovered a new reachable node %bb.2
	discovered a new reachable node %bb.17
	discovered a new reachable node %bb.16
	discovered a new reachable node %bb.15
	discovered a new reachable node %bb.13
	discovered a new reachable node %bb.12
	discovered a new reachable node %bb.11
	discovered a new reachable node %bb.14
	discovered a new reachable node %bb.10
	discovered a new reachable node %bb.9
	discovered a new reachable node %bb.8
	discovered a new reachable node %bb.6
	discovered a new reachable node %bb.5
	discovered a new reachable node %bb.4
	discovered a new reachable node %bb.7
	discovered a new reachable node %bb.3
	discovered a new reachable node %bb.1
	discovered a new reachable node %bb.0

block-frequency: quick_sort
===========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[if.then]
 - 2: BB2[while.cond]
 - 3: BB18[while.end32]
 - 4: BB19[if.end35]
 - 5: BB3[while.body]
 - 6: BB4[while.cond2]
 - 7: BB5[land.rhs]
 - 8: BB6[land.end]
 - 9: BB8[while.end]
 - 10: BB9[if.then9]
 - 11: BB10[if.end]
 - 12: BB11[while.cond14]
 - 13: BB12[land.rhs16]
 - 14: BB13[land.end20]
 - 15: BB15[while.end23]
 - 16: BB16[if.then25]
 - 17: BB17[if.end31]
 - 18: BB14[while.body21]
 - 19: BB7[while.body7]
loop-detection
 - loop = BB2[while.cond]
 - loop = BB4[while.cond2]
 - loop = BB11[while.cond14]
 - loop = BB2[while.cond]: member = BB3[while.body]
 - loop = BB4[while.cond2]: member = BB5[land.rhs]
 - loop = BB4[while.cond2]: member = BB6[land.end]
 - loop = BB2[while.cond]: member = BB8[while.end]
 - loop = BB2[while.cond]: member = BB9[if.then9]
 - loop = BB2[while.cond]: member = BB10[if.end]
 - loop = BB11[while.cond14]: member = BB12[land.rhs16]
 - loop = BB11[while.cond14]: member = BB13[land.end20]
 - loop = BB2[while.cond]: member = BB15[while.end23]
 - loop = BB2[while.cond]: member = BB16[if.then25]
 - loop = BB2[while.cond]: member = BB17[if.end31]
 - loop = BB11[while.cond14]: member = BB14[while.body21]
 - loop = BB4[while.cond2]: member = BB7[while.body7]
compute-mass-in-loop: BB11[while.cond14]*
 - node: BB11[while.cond14]
  => [ local  ] weight = 1073741824, succ = BB12[land.rhs16]
  => [ local  ] weight = 1073741824, succ = BB13[land.end20]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB12[land.rhs16]
  => assign 8000000000000000 (0000000000000000) to BB13[land.end20]
 - node: BB12[land.rhs16]
  => [ local  ] weight = 2147483648, succ = BB13[land.end20]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB13[land.end20]
 - node: BB13[land.end20]
  => [ local  ] weight = 1073741824, succ = BB14[while.body21]
  => [  exit  ] weight = 1073741824, succ = BB15[while.end23]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) [exit] to BB15[while.end23]
  => assign 8000000000000000 (0000000000000000) to BB14[while.body21]
 - node: BB14[while.body21]
  => [backedge] weight = 2147483648
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) [back] to BB11[while.cond14]
compute-loop-scale: BB11[while.cond14]*
 - exit-mass = 7fffffffffffffff (ffffffffffffffff - 8000000000000000)
 - scale = 2.0
packaging-loop: BB11[while.cond14]*
 - node: BB11[while.cond14]
 - node: BB12[land.rhs16]
 - node: BB13[land.end20]
 - node: BB14[while.body21]
compute-mass-in-loop: BB4[while.cond2]*
 - node: BB4[while.cond2]
  => [ local  ] weight = 1073741824, succ = BB5[land.rhs]
  => [ local  ] weight = 1073741824, succ = BB6[land.end]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB5[land.rhs]
  => assign 8000000000000000 (0000000000000000) to BB6[land.end]
 - node: BB5[land.rhs]
  => [ local  ] weight = 2147483648, succ = BB6[land.end]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB6[land.end]
 - node: BB6[land.end]
  => [ local  ] weight = 1073741824, succ = BB7[while.body7]
  => [  exit  ] weight = 1073741824, succ = BB8[while.end]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) [exit] to BB8[while.end]
  => assign 8000000000000000 (0000000000000000) to BB7[while.body7]
 - node: BB7[while.body7]
  => [backedge] weight = 2147483648
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) [back] to BB4[while.cond2]
compute-loop-scale: BB4[while.cond2]*
 - exit-mass = 7fffffffffffffff (ffffffffffffffff - 8000000000000000)
 - scale = 2.0
packaging-loop: BB4[while.cond2]*
 - node: BB4[while.cond2]
 - node: BB5[land.rhs]
 - node: BB6[land.end]
 - node: BB7[while.body7]
compute-mass-in-loop: BB2[while.cond]*
 - node: BB2[while.cond]
  => [ local  ] weight = 1073741824, succ = BB3[while.body]
  => [  exit  ] weight = 1073741824, succ = BB18[while.end32]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) [exit] to BB18[while.end32]
  => assign 8000000000000000 (0000000000000000) to BB3[while.body]
 - node: BB3[while.body]
  => [ local  ] weight = 2147483648, succ = BB4[while.cond2]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB4[while.cond2]
 - node: BB4[while.cond2]
  => [ local  ] weight = 9223372036854775807, succ = BB8[while.end]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB8[while.end]
 - node: BB8[while.end]
  => [ local  ] weight = 1073741824, succ = BB9[if.then9]
  => [ local  ] weight = 1073741824, succ = BB10[if.end]
  => mass:  8000000000000000
  => assign 4000000000000000 (4000000000000000) to BB9[if.then9]
  => assign 4000000000000000 (0000000000000000) to BB10[if.end]
 - node: BB9[if.then9]
  => [ local  ] weight = 2147483648, succ = BB10[if.end]
  => mass:  4000000000000000
  => assign 4000000000000000 (0000000000000000) to BB10[if.end]
 - node: BB10[if.end]
  => [ local  ] weight = 2147483648, succ = BB11[while.cond14]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB11[while.cond14]
 - node: BB11[while.cond14]
  => [ local  ] weight = 9223372036854775807, succ = BB15[while.end23]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB15[while.end23]
 - node: BB15[while.end23]
  => [ local  ] weight = 1073741824, succ = BB16[if.then25]
  => [ local  ] weight = 1073741824, succ = BB17[if.end31]
  => mass:  8000000000000000
  => assign 4000000000000000 (4000000000000000) to BB16[if.then25]
  => assign 4000000000000000 (0000000000000000) to BB17[if.end31]
 - node: BB16[if.then25]
  => [ local  ] weight = 2147483648, succ = BB17[if.end31]
  => mass:  4000000000000000
  => assign 4000000000000000 (0000000000000000) to BB17[if.end31]
 - node: BB17[if.end31]
  => [backedge] weight = 2147483648
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) [back] to BB2[while.cond]
compute-loop-scale: BB2[while.cond]*
 - exit-mass = 7fffffffffffffff (ffffffffffffffff - 8000000000000000)
 - scale = 2.0
packaging-loop: BB2[while.cond]*
 - node: BB2[while.cond]
 - node: BB3[while.body]
 - node: BB4[while.cond2]
 - node: BB8[while.end]
 - node: BB9[if.then9]
 - node: BB10[if.end]
 - node: BB11[while.cond14]
 - node: BB15[while.end23]
 - node: BB16[if.then25]
 - node: BB17[if.end31]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB1[if.then]
  => [ local  ] weight = 1073741824, succ = BB19[if.end35]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB1[if.then]
  => assign 8000000000000000 (0000000000000000) to BB19[if.end35]
 - node: BB1[if.then]
  => [ local  ] weight = 2147483648, succ = BB2[while.cond]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB2[while.cond]
 - node: BB2[while.cond]
  => [ local  ] weight = 9223372036854775807, succ = BB18[while.end32]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB18[while.end32]
 - node: BB18[while.end32]
  => [ local  ] weight = 2147483648, succ = BB19[if.end35]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB19[if.end35]
 - node: BB19[if.end35]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB2[while.cond]*: mass = 7fffffffffffffff, scale = 2.0
  => combined-scale = 1.0
 - BB2[while.cond]: 1.0 => 1.0
 - BB3[while.body]: 0.5 => 0.5
 - BB4[while.cond2]: 2.0 => 2.0
 - BB8[while.end]: 0.5 => 0.5
 - BB9[if.then9]: 0.25 => 0.25
 - BB10[if.end]: 0.5 => 0.5
 - BB11[while.cond14]: 2.0 => 2.0
 - BB15[while.end23]: 0.5 => 0.5
 - BB16[if.then25]: 0.25 => 0.25
 - BB17[if.end31]: 0.5 => 0.5
unwrap-loop-package: BB4[while.cond2]*: mass = 8000000000000000, scale = 2.0
  => combined-scale = 1.0
 - BB4[while.cond2]: 1.0 => 1.0
 - BB5[land.rhs]: 0.5 => 0.5
 - BB6[land.end]: 1.0 => 1.0
 - BB7[while.body7]: 0.5 => 0.5
unwrap-loop-package: BB11[while.cond14]*: mass = 8000000000000000, scale = 2.0
  => combined-scale = 1.0
 - BB11[while.cond14]: 1.0 => 1.0
 - BB12[land.rhs16]: 0.5 => 0.5
 - BB13[land.end20]: 1.0 => 1.0
 - BB14[while.body21]: 0.5 => 0.5
float-to-int: min = 0.25, max = 1.0, factor = 32.0
 - BB0[entry]: float = 1.0, scaled = 32.0, int = 31
 - BB1[if.then]: float = 0.5, scaled = 16.0, int = 15
 - BB2[while.cond]: float = 1.0, scaled = 32.0, int = 31
 - BB18[while.end32]: float = 0.5, scaled = 16.0, int = 15
 - BB19[if.end35]: float = 1.0, scaled = 32.0, int = 31
 - BB3[while.body]: float = 0.5, scaled = 16.0, int = 15
 - BB4[while.cond2]: float = 1.0, scaled = 32.0, int = 31
 - BB5[land.rhs]: float = 0.5, scaled = 16.0, int = 15
 - BB6[land.end]: float = 1.0, scaled = 32.0, int = 31
 - BB8[while.end]: float = 0.5, scaled = 16.0, int = 15
 - BB9[if.then9]: float = 0.25, scaled = 8.0, int = 8
 - BB10[if.end]: float = 0.5, scaled = 16.0, int = 15
 - BB11[while.cond14]: float = 1.0, scaled = 32.0, int = 31
 - BB12[land.rhs16]: float = 0.5, scaled = 16.0, int = 15
 - BB13[land.end20]: float = 1.0, scaled = 32.0, int = 31
 - BB15[while.end23]: float = 0.5, scaled = 16.0, int = 15
 - BB16[if.then25]: float = 0.25, scaled = 8.0, int = 8
 - BB17[if.end31]: float = 0.5, scaled = 16.0, int = 15
 - BB14[while.body21]: float = 0.5, scaled = 16.0, int = 16
 - BB7[while.body7]: float = 0.5, scaled = 16.0, int = 16
block-frequency-info: quick_sort
 - BB0[entry]: float = 1.0, int = 31
 - BB1[if.then]: float = 0.5, int = 15
 - BB2[while.cond]: float = 1.0, int = 31
 - BB3[while.body]: float = 0.5, int = 15
 - BB4[while.cond2]: float = 1.0, int = 31
 - BB5[land.rhs]: float = 0.5, int = 15
 - BB6[land.end]: float = 1.0, int = 31
 - BB7[while.body7]: float = 0.5, int = 16
 - BB8[while.end]: float = 0.5, int = 15
 - BB9[if.then9]: float = 0.25, int = 8
 - BB10[if.end]: float = 0.5, int = 15
 - BB11[while.cond14]: float = 1.0, int = 31
 - BB12[land.rhs16]: float = 0.5, int = 15
 - BB13[land.end20]: float = 1.0, int = 31
 - BB14[while.body21]: float = 0.5, int = 16
 - BB15[while.end23]: float = 0.5, int = 15
 - BB16[if.then25]: float = 0.25, int = 8
 - BB17[if.end31]: float = 0.5, int = 15
 - BB18[while.end32]: float = 0.5, int = 15
 - BB19[if.end35]: float = 1.0, int = 31

Skipping pass 'Machine code sinking' on function quick_sort
Skipping pass 'Peephole Optimizations' on function quick_sort
Skipping pass 'Remove dead machine instructions' on function quick_sort
Skipping pass 'Live Range Shrink' on function quick_sort
Skipping pass 'X86 LEA Optimize' on function quick_sort
Skipping pass 'X86 Optimize Call Frame' on function quick_sort
Skipping pass 'X86 Avoid Store Forwarding Blocks' on function quick_sort
	discovered a new reachable node %bb.0
	discovered a new reachable node %bb.1
	discovered a new reachable node %bb.2
	discovered a new reachable node %bb.3
	discovered a new reachable node %bb.4
	discovered a new reachable node %bb.5
	discovered a new reachable node %bb.6
	discovered a new reachable node %bb.7
	discovered a new reachable node %bb.8
	discovered a new reachable node %bb.9
	discovered a new reachable node %bb.10
	discovered a new reachable node %bb.11
	discovered a new reachable node %bb.12
	discovered a new reachable node %bb.13
	discovered a new reachable node %bb.14
	discovered a new reachable node %bb.15
	discovered a new reachable node %bb.16
	discovered a new reachable node %bb.17
	discovered a new reachable node %bb.18
	discovered a new reachable node %bb.19
********** X86 EFLAGS copy lowering : quick_sort **********
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: quick_sort
	discovered a new reachable node %bb.0
	discovered a new reachable node %bb.1
	discovered a new reachable node %bb.2
	discovered a new reachable node %bb.3
	discovered a new reachable node %bb.4
	discovered a new reachable node %bb.5
	discovered a new reachable node %bb.6
	discovered a new reachable node %bb.7
	discovered a new reachable node %bb.8
	discovered a new reachable node %bb.9
	discovered a new reachable node %bb.10
	discovered a new reachable node %bb.11
	discovered a new reachable node %bb.12
	discovered a new reachable node %bb.13
	discovered a new reachable node %bb.14
	discovered a new reachable node %bb.15
	discovered a new reachable node %bb.16
	discovered a new reachable node %bb.17
	discovered a new reachable node %bb.18
	discovered a new reachable node %bb.19
Skipping pass 'Two-Address instruction pass' on function quick_sort
********** REWRITING TWO-ADDR INSTRS **********
********** Function: quick_sort
	dead %8:gr32 = SUB32rr killed %6:gr32, killed %7:gr32, implicit-def $eflags
		prepend:	%8:gr32 = COPY %6:gr32
		rewrite to:	dead %8:gr32 = SUB32rr %8:gr32, killed %7:gr32, implicit-def $eflags
	dead %15:gr32 = SUB32rr killed %13:gr32, killed %14:gr32, implicit-def $eflags
		prepend:	%15:gr32 = COPY %13:gr32
		rewrite to:	dead %15:gr32 = SUB32rr %15:gr32, killed %14:gr32, implicit-def $eflags
	dead %28:gr32 = SUB32rr killed %25:gr32, killed %26:gr32, implicit-def $eflags
		prepend:	%28:gr32 = COPY %25:gr32
		rewrite to:	dead %28:gr32 = SUB32rr %28:gr32, killed %26:gr32, implicit-def $eflags
	dead %32:gr32 = SUB32rr killed %30:gr32, killed %31:gr32, implicit-def $eflags
		prepend:	%32:gr32 = COPY %30:gr32
		rewrite to:	dead %32:gr32 = SUB32rr %32:gr32, killed %31:gr32, implicit-def $eflags
	%61:gr32 = ADD32ri8 killed %60:gr32, -1, implicit-def dead $eflags
		prepend:	%61:gr32 = COPY %60:gr32
		rewrite to:	%61:gr32 = ADD32ri8 %61:gr32, -1, implicit-def dead $eflags
	dead %35:gr32 = SUB32rr killed %33:gr32, killed %34:gr32, implicit-def $eflags
		prepend:	%35:gr32 = COPY %33:gr32
		rewrite to:	dead %35:gr32 = SUB32rr %35:gr32, killed %34:gr32, implicit-def $eflags
	%40:gr32 = ADD32ri8 killed %39:gr32, 1, implicit-def dead $eflags
		prepend:	%40:gr32 = COPY %39:gr32
		rewrite to:	%40:gr32 = ADD32ri8 %40:gr32, 1, implicit-def dead $eflags
	dead %45:gr32 = SUB32rr killed %42:gr32, killed %43:gr32, implicit-def $eflags
		prepend:	%45:gr32 = COPY %42:gr32
		rewrite to:	dead %45:gr32 = SUB32rr %45:gr32, killed %43:gr32, implicit-def $eflags
	dead %49:gr32 = SUB32rr killed %47:gr32, killed %48:gr32, implicit-def $eflags
		prepend:	%49:gr32 = COPY %47:gr32
		rewrite to:	dead %49:gr32 = SUB32rr %49:gr32, killed %48:gr32, implicit-def $eflags
	%59:gr32 = ADD32ri8 killed %58:gr32, 1, implicit-def dead $eflags
		prepend:	%59:gr32 = COPY %58:gr32
		rewrite to:	%59:gr32 = ADD32ri8 %59:gr32, 1, implicit-def dead $eflags
	dead %52:gr32 = SUB32rr killed %50:gr32, killed %51:gr32, implicit-def $eflags
		prepend:	%52:gr32 = COPY %50:gr32
		rewrite to:	dead %52:gr32 = SUB32rr %52:gr32, killed %51:gr32, implicit-def $eflags
	%57:gr32 = ADD32ri8 killed %56:gr32, -1, implicit-def dead $eflags
		prepend:	%57:gr32 = COPY %56:gr32
		rewrite to:	%57:gr32 = ADD32ri8 %57:gr32, -1, implicit-def dead $eflags
	%20:gr32 = ADD32ri8 killed %19:gr32, -1, implicit-def dead $eflags
		prepend:	%20:gr32 = COPY %19:gr32
		rewrite to:	%20:gr32 = ADD32ri8 %20:gr32, -1, implicit-def dead $eflags
	%22:gr32 = ADD32ri8 killed %21:gr32, 1, implicit-def dead $eflags
		prepend:	%22:gr32 = COPY %21:gr32
		rewrite to:	%22:gr32 = ADD32ri8 %22:gr32, 1, implicit-def dead $eflags
# Machine code for function quick_sort: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=4, align=4, at location [SP+8]
  fi#3: size=4, align=4, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
Function Live Ins: $edi in %4, $esi in %5

0B	bb.0.entry:
	  successors: %bb.1, %bb.19
	  liveins: $edi, $esi
16B	  %5:gr32 = COPY killed $esi
32B	  %4:gr32 = COPY killed $edi
48B	  MOV32mr %stack.0.l.addr, 1, $noreg, 0, $noreg, killed %4:gr32 :: (store 4 into %ir.l.addr)
64B	  MOV32mr %stack.1.r.addr, 1, $noreg, 0, $noreg, killed %5:gr32 :: (store 4 into %ir.r.addr)
80B	  %6:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
96B	  %7:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
112B	  %8:gr32 = COPY killed %6:gr32
128B	  dead %8:gr32 = SUB32rr %8:gr32, killed %7:gr32, implicit-def $eflags
144B	  JGE_1 %bb.19, implicit killed $eflags
160B	  JMP_1 %bb.1

176B	bb.1.if.then:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(200.00%)

192B	  %9:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
208B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed %9:gr32 :: (store 4 into %ir.i)
224B	  %10:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
240B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed %10:gr32 :: (store 4 into %ir.j)
256B	  %11:gr64_nosp = MOVSX64rm32 %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
272B	  %12:gr32 = MOV32rm $noreg, 4, killed %11:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx)
288B	  MOV32mr %stack.4.x, 1, $noreg, 0, $noreg, killed %12:gr32 :: (store 4 into %ir.x)
304B	  JMP_1 %bb.2

320B	bb.2.while.cond:
	; predecessors: %bb.1, %bb.17
	  successors: %bb.3, %bb.18

336B	  %13:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
352B	  %14:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
368B	  %15:gr32 = COPY killed %13:gr32
384B	  dead %15:gr32 = SUB32rr %15:gr32, killed %14:gr32, implicit-def $eflags
400B	  JGE_1 %bb.18, implicit killed $eflags
416B	  JMP_1 %bb.3

432B	bb.3.while.body:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(200.00%)

448B	  JMP_1 %bb.4

464B	bb.4.while.cond2:
	; predecessors: %bb.3, %bb.7
	  successors: %bb.5, %bb.6

480B	  %25:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
496B	  %26:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
512B	  %27:gr32 = MOV32r0 implicit-def dead $eflags
528B	  %24:gr8 = COPY killed %27.sub_8bit:gr32
544B	  %28:gr32 = COPY killed %25:gr32
560B	  dead %28:gr32 = SUB32rr %28:gr32, killed %26:gr32, implicit-def $eflags
576B	  %62:gr8 = COPY killed %24:gr8
592B	  JGE_1 %bb.6, implicit killed $eflags
608B	  JMP_1 %bb.5

624B	bb.5.land.rhs:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(200.00%)

640B	  %29:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
656B	  %30:gr32 = MOV32rm $noreg, 4, killed %29:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx5)
672B	  %31:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
688B	  %32:gr32 = COPY killed %30:gr32
704B	  dead %32:gr32 = SUB32rr %32:gr32, killed %31:gr32, implicit-def $eflags
720B	  %0:gr8 = SETGEr implicit killed $eflags
736B	  %62:gr8 = COPY killed %0:gr8
752B	  JMP_1 %bb.6

768B	bb.6.land.end:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7, %bb.8

784B	  %1:gr8 = COPY killed %62:gr8
800B	  TEST8ri killed %1:gr8, 1, implicit-def $eflags
816B	  JE_1 %bb.8, implicit killed $eflags
832B	  JMP_1 %bb.7

848B	bb.7.while.body7:
	; predecessors: %bb.6
	  successors: %bb.4(0x80000000); %bb.4(200.00%)

864B	  %60:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
880B	  %61:gr32 = COPY killed %60:gr32
896B	  %61:gr32 = ADD32ri8 %61:gr32, -1, implicit-def dead $eflags
912B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed %61:gr32 :: (store 4 into %ir.j)
928B	  JMP_1 %bb.4

944B	bb.8.while.end:
	; predecessors: %bb.6
	  successors: %bb.9, %bb.10

960B	  %33:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
976B	  %34:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
992B	  %35:gr32 = COPY killed %33:gr32
1008B	  dead %35:gr32 = SUB32rr %35:gr32, killed %34:gr32, implicit-def $eflags
1024B	  JGE_1 %bb.10, implicit killed $eflags
1040B	  JMP_1 %bb.9

1056B	bb.9.if.then9:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(200.00%)

1072B	  %36:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1088B	  %37:gr32 = MOV32rm $noreg, 4, killed %36:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx11)
1104B	  %38:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1120B	  %39:gr32 = COPY %38.sub_32bit:gr64_nosp
1136B	  %40:gr32 = COPY killed %39:gr32
1152B	  %40:gr32 = ADD32ri8 %40:gr32, 1, implicit-def dead $eflags
1168B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed %40:gr32 :: (store 4 into %ir.i)
1184B	  MOV32mr $noreg, 4, killed %38:gr64_nosp, @s, $noreg, killed %37:gr32 :: (store 4 into %ir.arrayidx13)
1200B	  JMP_1 %bb.10

1216B	bb.10.if.end:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x80000000); %bb.11(200.00%)

1232B	  JMP_1 %bb.11

1248B	bb.11.while.cond14:
	; predecessors: %bb.10, %bb.14
	  successors: %bb.12, %bb.13

1264B	  %42:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1280B	  %43:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1296B	  %44:gr32 = MOV32r0 implicit-def dead $eflags
1312B	  %41:gr8 = COPY killed %44.sub_8bit:gr32
1328B	  %45:gr32 = COPY killed %42:gr32
1344B	  dead %45:gr32 = SUB32rr %45:gr32, killed %43:gr32, implicit-def $eflags
1360B	  %63:gr8 = COPY killed %41:gr8
1376B	  JGE_1 %bb.13, implicit killed $eflags
1392B	  JMP_1 %bb.12

1408B	bb.12.land.rhs16:
	; predecessors: %bb.11
	  successors: %bb.13(0x80000000); %bb.13(200.00%)

1424B	  %46:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1440B	  %47:gr32 = MOV32rm $noreg, 4, killed %46:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx18)
1456B	  %48:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
1472B	  %49:gr32 = COPY killed %47:gr32
1488B	  dead %49:gr32 = SUB32rr %49:gr32, killed %48:gr32, implicit-def $eflags
1504B	  %2:gr8 = SETLr implicit killed $eflags
1520B	  %63:gr8 = COPY killed %2:gr8
1536B	  JMP_1 %bb.13

1552B	bb.13.land.end20:
	; predecessors: %bb.11, %bb.12
	  successors: %bb.14, %bb.15

1568B	  %3:gr8 = COPY killed %63:gr8
1584B	  TEST8ri killed %3:gr8, 1, implicit-def $eflags
1600B	  JE_1 %bb.15, implicit killed $eflags
1616B	  JMP_1 %bb.14

1632B	bb.14.while.body21:
	; predecessors: %bb.13
	  successors: %bb.11(0x80000000); %bb.11(200.00%)

1648B	  %58:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1664B	  %59:gr32 = COPY killed %58:gr32
1680B	  %59:gr32 = ADD32ri8 %59:gr32, 1, implicit-def dead $eflags
1696B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed %59:gr32 :: (store 4 into %ir.i)
1712B	  JMP_1 %bb.11

1728B	bb.15.while.end23:
	; predecessors: %bb.13
	  successors: %bb.16, %bb.17

1744B	  %50:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1760B	  %51:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1776B	  %52:gr32 = COPY killed %50:gr32
1792B	  dead %52:gr32 = SUB32rr %52:gr32, killed %51:gr32, implicit-def $eflags
1808B	  JGE_1 %bb.17, implicit killed $eflags
1824B	  JMP_1 %bb.16

1840B	bb.16.if.then25:
	; predecessors: %bb.15
	  successors: %bb.17(0x80000000); %bb.17(200.00%)

1856B	  %53:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1872B	  %54:gr32 = MOV32rm $noreg, 4, killed %53:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx27)
1888B	  %55:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1904B	  %56:gr32 = COPY %55.sub_32bit:gr64_nosp
1920B	  %57:gr32 = COPY killed %56:gr32
1936B	  %57:gr32 = ADD32ri8 %57:gr32, -1, implicit-def dead $eflags
1952B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed %57:gr32 :: (store 4 into %ir.j)
1968B	  MOV32mr $noreg, 4, killed %55:gr64_nosp, @s, $noreg, killed %54:gr32 :: (store 4 into %ir.arrayidx30)
1984B	  JMP_1 %bb.17

2000B	bb.17.if.end31:
	; predecessors: %bb.15, %bb.16
	  successors: %bb.2(0x80000000); %bb.2(200.00%)

2016B	  JMP_1 %bb.2

2032B	bb.18.while.end32:
	; predecessors: %bb.2
	  successors: %bb.19(0x80000000); %bb.19(200.00%)

2048B	  %16:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
2064B	  %17:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2080B	  MOV32mr $noreg, 4, killed %17:gr64_nosp, @s, $noreg, killed %16:gr32 :: (store 4 into %ir.arrayidx34)
2096B	  %18:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
2112B	  %19:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2128B	  %20:gr32 = COPY killed %19:gr32
2144B	  %20:gr32 = ADD32ri8 %20:gr32, -1, implicit-def dead $eflags
2160B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2176B	  $edi = COPY killed %18:gr32
2192B	  $esi = COPY killed %20:gr32
2208B	  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp
2224B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2240B	  %21:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2256B	  %22:gr32 = COPY killed %21:gr32
2272B	  %22:gr32 = ADD32ri8 %22:gr32, 1, implicit-def dead $eflags
2288B	  %23:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
2304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2320B	  $edi = COPY killed %22:gr32
2336B	  $esi = COPY killed %23:gr32
2352B	  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $edi, implicit killed $esi, implicit-def $rsp, implicit-def $ssp
2368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2384B	  JMP_1 %bb.19

2400B	bb.19.if.end35:
	; predecessors: %bb.0, %bb.18

2416B	  RET 0

# End machine code for function quick_sort.

Computing live-in reg-units in ABI blocks.
0B	%bb.0 DIL#0 DIH#0 HDI#0 SIL#0 SIH#0 HSI#0
Created 6 new intervals.
********** INTERVALS **********
DIL [0B,32r:0)[2176r,2208r:2)[2320r,2352r:1)  0@0B-phi 1@2320r 2@2176r
DIH [0B,32r:0)[2176r,2208r:2)[2320r,2352r:1)  0@0B-phi 1@2320r 2@2176r
HDI [0B,32r:0)[2176r,2208r:2)[2320r,2352r:1)  0@0B-phi 1@2320r 2@2176r
SIL [0B,16r:0)[2192r,2208r:2)[2336r,2352r:1)  0@0B-phi 1@2336r 2@2192r
SIH [0B,16r:0)[2192r,2208r:2)[2336r,2352r:1)  0@0B-phi 1@2336r 2@2192r
HSI [0B,16r:0)[2192r,2208r:2)[2336r,2352r:1)  0@0B-phi 1@2336r 2@2192r
%0 [720r,736r:0)  0@720r weight:0.000000e+00
%1 [784r,800r:0)  0@784r weight:0.000000e+00
%2 [1504r,1520r:0)  0@1504r weight:0.000000e+00
%3 [1568r,1584r:0)  0@1568r weight:0.000000e+00
%4 [32r,48r:0)  0@32r weight:0.000000e+00
%5 [16r,64r:0)  0@16r weight:0.000000e+00
%6 [80r,112r:0)  0@80r weight:0.000000e+00
%7 [96r,128r:0)  0@96r weight:0.000000e+00
%8 [112r,128r:0)[128r,128d:1)  0@112r 1@128r weight:0.000000e+00
%9 [192r,208r:0)  0@192r weight:0.000000e+00
%10 [224r,240r:0)  0@224r weight:0.000000e+00
%11 [256r,272r:0)  0@256r weight:0.000000e+00
%12 [272r,288r:0)  0@272r weight:0.000000e+00
%13 [336r,368r:0)  0@336r weight:0.000000e+00
%14 [352r,384r:0)  0@352r weight:0.000000e+00
%15 [368r,384r:0)[384r,384d:1)  0@368r 1@384r weight:0.000000e+00
%16 [2048r,2080r:0)  0@2048r weight:0.000000e+00
%17 [2064r,2080r:0)  0@2064r weight:0.000000e+00
%18 [2096r,2176r:0)  0@2096r weight:0.000000e+00
%19 [2112r,2128r:0)  0@2112r weight:0.000000e+00
%20 [2128r,2144r:0)[2144r,2192r:1)  0@2128r 1@2144r weight:0.000000e+00
%21 [2240r,2256r:0)  0@2240r weight:0.000000e+00
%22 [2256r,2272r:0)[2272r,2320r:1)  0@2256r 1@2272r weight:0.000000e+00
%23 [2288r,2336r:0)  0@2288r weight:0.000000e+00
%24 [528r,576r:0)  0@528r weight:0.000000e+00
%25 [480r,544r:0)  0@480r weight:0.000000e+00
%26 [496r,560r:0)  0@496r weight:0.000000e+00
%27 [512r,528r:0)  0@512r weight:0.000000e+00
%28 [544r,560r:0)[560r,560d:1)  0@544r 1@560r weight:0.000000e+00
%29 [640r,656r:0)  0@640r weight:0.000000e+00
%30 [656r,688r:0)  0@656r weight:0.000000e+00
%31 [672r,704r:0)  0@672r weight:0.000000e+00
%32 [688r,704r:0)[704r,704d:1)  0@688r 1@704r weight:0.000000e+00
%33 [960r,992r:0)  0@960r weight:0.000000e+00
%34 [976r,1008r:0)  0@976r weight:0.000000e+00
%35 [992r,1008r:0)[1008r,1008d:1)  0@992r 1@1008r weight:0.000000e+00
%36 [1072r,1088r:0)  0@1072r weight:0.000000e+00
%37 [1088r,1184r:0)  0@1088r weight:0.000000e+00
%38 [1104r,1184r:0)  0@1104r weight:0.000000e+00
%39 [1120r,1136r:0)  0@1120r weight:0.000000e+00
%40 [1136r,1152r:0)[1152r,1168r:1)  0@1136r 1@1152r weight:0.000000e+00
%41 [1312r,1360r:0)  0@1312r weight:0.000000e+00
%42 [1264r,1328r:0)  0@1264r weight:0.000000e+00
%43 [1280r,1344r:0)  0@1280r weight:0.000000e+00
%44 [1296r,1312r:0)  0@1296r weight:0.000000e+00
%45 [1328r,1344r:0)[1344r,1344d:1)  0@1328r 1@1344r weight:0.000000e+00
%46 [1424r,1440r:0)  0@1424r weight:0.000000e+00
%47 [1440r,1472r:0)  0@1440r weight:0.000000e+00
%48 [1456r,1488r:0)  0@1456r weight:0.000000e+00
%49 [1472r,1488r:0)[1488r,1488d:1)  0@1472r 1@1488r weight:0.000000e+00
%50 [1744r,1776r:0)  0@1744r weight:0.000000e+00
%51 [1760r,1792r:0)  0@1760r weight:0.000000e+00
%52 [1776r,1792r:0)[1792r,1792d:1)  0@1776r 1@1792r weight:0.000000e+00
%53 [1856r,1872r:0)  0@1856r weight:0.000000e+00
%54 [1872r,1968r:0)  0@1872r weight:0.000000e+00
%55 [1888r,1968r:0)  0@1888r weight:0.000000e+00
%56 [1904r,1920r:0)  0@1904r weight:0.000000e+00
%57 [1920r,1936r:0)[1936r,1952r:1)  0@1920r 1@1936r weight:0.000000e+00
%58 [1648r,1664r:0)  0@1648r weight:0.000000e+00
%59 [1664r,1680r:0)[1680r,1696r:1)  0@1664r 1@1680r weight:0.000000e+00
%60 [864r,880r:0)  0@864r weight:0.000000e+00
%61 [880r,896r:0)[896r,912r:1)  0@880r 1@896r weight:0.000000e+00
%62 [576r,624B:0)[736r,768B:1)[768B,784r:2)  0@576r 1@736r 2@768B-phi weight:0.000000e+00
%63 [1360r,1408B:0)[1520r,1552B:1)[1552B,1568r:2)  0@1360r 1@1520r 2@1552B-phi weight:0.000000e+00
RegMasks: 2208r 2352r
********** MACHINEINSTRS **********
# Machine code for function quick_sort: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=4, align=4, at location [SP+8]
  fi#3: size=4, align=4, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
Function Live Ins: $edi in %4, $esi in %5

0B	bb.0.entry:
	  successors: %bb.1, %bb.19
	  liveins: $edi, $esi
16B	  %5:gr32 = COPY $esi
32B	  %4:gr32 = COPY $edi
48B	  MOV32mr %stack.0.l.addr, 1, $noreg, 0, $noreg, %4:gr32 :: (store 4 into %ir.l.addr)
64B	  MOV32mr %stack.1.r.addr, 1, $noreg, 0, $noreg, %5:gr32 :: (store 4 into %ir.r.addr)
80B	  %6:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
96B	  %7:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
112B	  %8:gr32 = COPY %6:gr32
128B	  dead %8:gr32 = SUB32rr %8:gr32, %7:gr32, implicit-def $eflags
144B	  JGE_1 %bb.19, implicit killed $eflags
160B	  JMP_1 %bb.1

176B	bb.1.if.then:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(200.00%)

192B	  %9:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
208B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, %9:gr32 :: (store 4 into %ir.i)
224B	  %10:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
240B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, %10:gr32 :: (store 4 into %ir.j)
256B	  %11:gr64_nosp = MOVSX64rm32 %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
272B	  %12:gr32 = MOV32rm $noreg, 4, %11:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx)
288B	  MOV32mr %stack.4.x, 1, $noreg, 0, $noreg, %12:gr32 :: (store 4 into %ir.x)
304B	  JMP_1 %bb.2

320B	bb.2.while.cond:
	; predecessors: %bb.1, %bb.17
	  successors: %bb.3, %bb.18

336B	  %13:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
352B	  %14:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
368B	  %15:gr32 = COPY %13:gr32
384B	  dead %15:gr32 = SUB32rr %15:gr32, %14:gr32, implicit-def $eflags
400B	  JGE_1 %bb.18, implicit killed $eflags
416B	  JMP_1 %bb.3

432B	bb.3.while.body:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(200.00%)

448B	  JMP_1 %bb.4

464B	bb.4.while.cond2:
	; predecessors: %bb.3, %bb.7
	  successors: %bb.5, %bb.6

480B	  %25:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
496B	  %26:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
512B	  %27:gr32 = MOV32r0 implicit-def dead $eflags
528B	  %24:gr8 = COPY %27.sub_8bit:gr32
544B	  %28:gr32 = COPY %25:gr32
560B	  dead %28:gr32 = SUB32rr %28:gr32, %26:gr32, implicit-def $eflags
576B	  %62:gr8 = COPY %24:gr8
592B	  JGE_1 %bb.6, implicit killed $eflags
608B	  JMP_1 %bb.5

624B	bb.5.land.rhs:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(200.00%)

640B	  %29:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
656B	  %30:gr32 = MOV32rm $noreg, 4, %29:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx5)
672B	  %31:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
688B	  %32:gr32 = COPY %30:gr32
704B	  dead %32:gr32 = SUB32rr %32:gr32, %31:gr32, implicit-def $eflags
720B	  %0:gr8 = SETGEr implicit killed $eflags
736B	  %62:gr8 = COPY %0:gr8
752B	  JMP_1 %bb.6

768B	bb.6.land.end:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7, %bb.8

784B	  %1:gr8 = COPY %62:gr8
800B	  TEST8ri %1:gr8, 1, implicit-def $eflags
816B	  JE_1 %bb.8, implicit killed $eflags
832B	  JMP_1 %bb.7

848B	bb.7.while.body7:
	; predecessors: %bb.6
	  successors: %bb.4(0x80000000); %bb.4(200.00%)

864B	  %60:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
880B	  %61:gr32 = COPY %60:gr32
896B	  %61:gr32 = ADD32ri8 %61:gr32, -1, implicit-def dead $eflags
912B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, %61:gr32 :: (store 4 into %ir.j)
928B	  JMP_1 %bb.4

944B	bb.8.while.end:
	; predecessors: %bb.6
	  successors: %bb.9, %bb.10

960B	  %33:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
976B	  %34:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
992B	  %35:gr32 = COPY %33:gr32
1008B	  dead %35:gr32 = SUB32rr %35:gr32, %34:gr32, implicit-def $eflags
1024B	  JGE_1 %bb.10, implicit killed $eflags
1040B	  JMP_1 %bb.9

1056B	bb.9.if.then9:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(200.00%)

1072B	  %36:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1088B	  %37:gr32 = MOV32rm $noreg, 4, %36:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx11)
1104B	  %38:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1120B	  %39:gr32 = COPY %38.sub_32bit:gr64_nosp
1136B	  %40:gr32 = COPY %39:gr32
1152B	  %40:gr32 = ADD32ri8 %40:gr32, 1, implicit-def dead $eflags
1168B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, %40:gr32 :: (store 4 into %ir.i)
1184B	  MOV32mr $noreg, 4, %38:gr64_nosp, @s, $noreg, %37:gr32 :: (store 4 into %ir.arrayidx13)
1200B	  JMP_1 %bb.10

1216B	bb.10.if.end:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x80000000); %bb.11(200.00%)

1232B	  JMP_1 %bb.11

1248B	bb.11.while.cond14:
	; predecessors: %bb.10, %bb.14
	  successors: %bb.12, %bb.13

1264B	  %42:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1280B	  %43:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1296B	  %44:gr32 = MOV32r0 implicit-def dead $eflags
1312B	  %41:gr8 = COPY %44.sub_8bit:gr32
1328B	  %45:gr32 = COPY %42:gr32
1344B	  dead %45:gr32 = SUB32rr %45:gr32, %43:gr32, implicit-def $eflags
1360B	  %63:gr8 = COPY %41:gr8
1376B	  JGE_1 %bb.13, implicit killed $eflags
1392B	  JMP_1 %bb.12

1408B	bb.12.land.rhs16:
	; predecessors: %bb.11
	  successors: %bb.13(0x80000000); %bb.13(200.00%)

1424B	  %46:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1440B	  %47:gr32 = MOV32rm $noreg, 4, %46:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx18)
1456B	  %48:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
1472B	  %49:gr32 = COPY %47:gr32
1488B	  dead %49:gr32 = SUB32rr %49:gr32, %48:gr32, implicit-def $eflags
1504B	  %2:gr8 = SETLr implicit killed $eflags
1520B	  %63:gr8 = COPY %2:gr8
1536B	  JMP_1 %bb.13

1552B	bb.13.land.end20:
	; predecessors: %bb.11, %bb.12
	  successors: %bb.14, %bb.15

1568B	  %3:gr8 = COPY %63:gr8
1584B	  TEST8ri %3:gr8, 1, implicit-def $eflags
1600B	  JE_1 %bb.15, implicit killed $eflags
1616B	  JMP_1 %bb.14

1632B	bb.14.while.body21:
	; predecessors: %bb.13
	  successors: %bb.11(0x80000000); %bb.11(200.00%)

1648B	  %58:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1664B	  %59:gr32 = COPY %58:gr32
1680B	  %59:gr32 = ADD32ri8 %59:gr32, 1, implicit-def dead $eflags
1696B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, %59:gr32 :: (store 4 into %ir.i)
1712B	  JMP_1 %bb.11

1728B	bb.15.while.end23:
	; predecessors: %bb.13
	  successors: %bb.16, %bb.17

1744B	  %50:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1760B	  %51:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1776B	  %52:gr32 = COPY %50:gr32
1792B	  dead %52:gr32 = SUB32rr %52:gr32, %51:gr32, implicit-def $eflags
1808B	  JGE_1 %bb.17, implicit killed $eflags
1824B	  JMP_1 %bb.16

1840B	bb.16.if.then25:
	; predecessors: %bb.15
	  successors: %bb.17(0x80000000); %bb.17(200.00%)

1856B	  %53:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1872B	  %54:gr32 = MOV32rm $noreg, 4, %53:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx27)
1888B	  %55:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1904B	  %56:gr32 = COPY %55.sub_32bit:gr64_nosp
1920B	  %57:gr32 = COPY %56:gr32
1936B	  %57:gr32 = ADD32ri8 %57:gr32, -1, implicit-def dead $eflags
1952B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, %57:gr32 :: (store 4 into %ir.j)
1968B	  MOV32mr $noreg, 4, %55:gr64_nosp, @s, $noreg, %54:gr32 :: (store 4 into %ir.arrayidx30)
1984B	  JMP_1 %bb.17

2000B	bb.17.if.end31:
	; predecessors: %bb.15, %bb.16
	  successors: %bb.2(0x80000000); %bb.2(200.00%)

2016B	  JMP_1 %bb.2

2032B	bb.18.while.end32:
	; predecessors: %bb.2
	  successors: %bb.19(0x80000000); %bb.19(200.00%)

2048B	  %16:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
2064B	  %17:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2080B	  MOV32mr $noreg, 4, %17:gr64_nosp, @s, $noreg, %16:gr32 :: (store 4 into %ir.arrayidx34)
2096B	  %18:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
2112B	  %19:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2128B	  %20:gr32 = COPY %19:gr32
2144B	  %20:gr32 = ADD32ri8 %20:gr32, -1, implicit-def dead $eflags
2160B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2176B	  $edi = COPY %18:gr32
2192B	  $esi = COPY %20:gr32
2208B	  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
2224B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2240B	  %21:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2256B	  %22:gr32 = COPY %21:gr32
2272B	  %22:gr32 = ADD32ri8 %22:gr32, 1, implicit-def dead $eflags
2288B	  %23:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
2304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2320B	  $edi = COPY %22:gr32
2336B	  $esi = COPY %23:gr32
2352B	  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
2368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2384B	  JMP_1 %bb.19

2400B	bb.19.if.end35:
	; predecessors: %bb.0, %bb.18

2416B	  RET 0

# End machine code for function quick_sort.

********** SIMPLE REGISTER COALESCING **********
********** Function: quick_sort
********** JOINING INTERVALS ***********
while.cond2:
land.end:
while.cond14:
land.end20:
land.rhs:
while.body7:
land.rhs16:
while.body21:
528B	%24:gr8 = COPY %27.sub_8bit:gr32
	Considering merging to GR32 with %24 in %27:sub_8bit
		RHS = %24 [528r,576r:0)  0@528r weight:0.000000e+00
		LHS = %27 [512r,528r:0)  0@512r weight:0.000000e+00
		merge %24:0@528r into %27:0@512r --> @512r
		erased:	528r	%24:gr8 = COPY %27.sub_8bit:gr32
AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $r14d $r15d $r12d $r13d ]
		updated: 576B	%62:gr8 = COPY %27.sub_8bit:gr32
	Success: %24:sub_8bit -> %27
	Result = %27 [512r,576r:0)  0@512r weight:0.000000e+00
544B	%28:gr32 = COPY %25:gr32
	Considering merging to GR32 with %25 in %28
		RHS = %25 [480r,544r:0)  0@480r weight:0.000000e+00
		LHS = %28 [544r,560r:0)[560r,560d:1)  0@544r 1@560r weight:0.000000e+00
		merge %28:0@544r into %25:0@480r --> @480r
		erased:	544r	%28:gr32 = COPY %25:gr32
		updated: 480B	%28:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
	Success: %25 -> %28
	Result = %28 [480r,560r:0)[560r,560d:1)  0@480r 1@560r weight:0.000000e+00
576B	%62:gr8 = COPY %27.sub_8bit:gr32
	Considering merging to GR32 with %62 in %27:sub_8bit
		RHS = %62 [576r,624B:0)[736r,768B:1)[768B,784r:2)  0@576r 1@736r 2@768B-phi weight:0.000000e+00
		LHS = %27 [512r,576r:0)  0@512r weight:0.000000e+00
		merge %62:0@576r into %27:0@512r --> @512r
		erased:	576r	%62:gr8 = COPY %27.sub_8bit:gr32
		updated: 736B	undef %27.sub_8bit:gr32 = COPY %0:gr8
		updated: 784B	%1:gr8 = COPY %27.sub_8bit:gr32
	Success: %62:sub_8bit -> %27
	Result = %27 [512r,624B:0)[736r,768B:1)[768B,784r:2)  0@512r 1@736r 2@768B-phi weight:0.000000e+00
784B	%1:gr8 = COPY %27.sub_8bit:gr32
	Considering merging to GR32 with %1 in %27:sub_8bit
		RHS = %1 [784r,800r:0)  0@784r weight:0.000000e+00
		LHS = %27 [512r,624B:0)[736r,768B:1)[768B,784r:2)  0@512r 1@736r 2@768B-phi weight:0.000000e+00
		merge %1:0@784r into %27:2@768B --> @768B
		erased:	784r	%1:gr8 = COPY %27.sub_8bit:gr32
		updated: 800B	TEST8ri %27.sub_8bit:gr32, 1, implicit-def $eflags
	Success: %1:sub_8bit -> %27
	Result = %27 [512r,624B:0)[736r,768B:1)[768B,800r:2)  0@512r 1@736r 2@768B-phi weight:0.000000e+00
1312B	%41:gr8 = COPY %44.sub_8bit:gr32
	Considering merging to GR32 with %41 in %44:sub_8bit
		RHS = %41 [1312r,1360r:0)  0@1312r weight:0.000000e+00
		LHS = %44 [1296r,1312r:0)  0@1296r weight:0.000000e+00
		merge %41:0@1312r into %44:0@1296r --> @1296r
		erased:	1312r	%41:gr8 = COPY %44.sub_8bit:gr32
		updated: 1360B	%63:gr8 = COPY %44.sub_8bit:gr32
	Success: %41:sub_8bit -> %44
	Result = %44 [1296r,1360r:0)  0@1296r weight:0.000000e+00
1328B	%45:gr32 = COPY %42:gr32
	Considering merging to GR32 with %42 in %45
		RHS = %42 [1264r,1328r:0)  0@1264r weight:0.000000e+00
		LHS = %45 [1328r,1344r:0)[1344r,1344d:1)  0@1328r 1@1344r weight:0.000000e+00
		merge %45:0@1328r into %42:0@1264r --> @1264r
		erased:	1328r	%45:gr32 = COPY %42:gr32
		updated: 1264B	%45:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
	Success: %42 -> %45
	Result = %45 [1264r,1344r:0)[1344r,1344d:1)  0@1264r 1@1344r weight:0.000000e+00
1360B	%63:gr8 = COPY %44.sub_8bit:gr32
	Considering merging to GR32 with %63 in %44:sub_8bit
		RHS = %63 [1360r,1408B:0)[1520r,1552B:1)[1552B,1568r:2)  0@1360r 1@1520r 2@1552B-phi weight:0.000000e+00
		LHS = %44 [1296r,1360r:0)  0@1296r weight:0.000000e+00
		merge %63:0@1360r into %44:0@1296r --> @1296r
		erased:	1360r	%63:gr8 = COPY %44.sub_8bit:gr32
		updated: 1520B	undef %44.sub_8bit:gr32 = COPY %2:gr8
		updated: 1568B	%3:gr8 = COPY %44.sub_8bit:gr32
	Success: %63:sub_8bit -> %44
	Result = %44 [1296r,1408B:0)[1520r,1552B:1)[1552B,1568r:2)  0@1296r 1@1520r 2@1552B-phi weight:0.000000e+00
1568B	%3:gr8 = COPY %44.sub_8bit:gr32
	Considering merging to GR32 with %3 in %44:sub_8bit
		RHS = %3 [1568r,1584r:0)  0@1568r weight:0.000000e+00
		LHS = %44 [1296r,1408B:0)[1520r,1552B:1)[1552B,1568r:2)  0@1296r 1@1520r 2@1552B-phi weight:0.000000e+00
		merge %3:0@1568r into %44:2@1552B --> @1552B
		erased:	1568r	%3:gr8 = COPY %44.sub_8bit:gr32
		updated: 1584B	TEST8ri %44.sub_8bit:gr32, 1, implicit-def $eflags
	Success: %3:sub_8bit -> %44
	Result = %44 [1296r,1408B:0)[1520r,1552B:1)[1552B,1584r:2)  0@1296r 1@1520r 2@1552B-phi weight:0.000000e+00
688B	%32:gr32 = COPY %30:gr32
	Considering merging to GR32 with %30 in %32
		RHS = %30 [656r,688r:0)  0@656r weight:0.000000e+00
		LHS = %32 [688r,704r:0)[704r,704d:1)  0@688r 1@704r weight:0.000000e+00
		merge %32:0@688r into %30:0@656r --> @656r
		erased:	688r	%32:gr32 = COPY %30:gr32
		updated: 656B	%32:gr32 = MOV32rm $noreg, 4, %29:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx5)
	Success: %30 -> %32
	Result = %32 [656r,704r:0)[704r,704d:1)  0@656r 1@704r weight:0.000000e+00
736B	undef %27.sub_8bit:gr32 = COPY %0:gr8
	Considering merging to GR32 with %0 in %27:sub_8bit
		RHS = %0 [720r,736r:0)  0@720r weight:0.000000e+00
		LHS = %27 [512r,624B:0)[736r,768B:1)[768B,800r:2)  0@512r 1@736r 2@768B-phi weight:0.000000e+00
		merge %27:1@736r into %0:0@720r --> @720r
		erased:	736r	undef %27.sub_8bit:gr32 = COPY %0:gr8
		updated: 720B	undef %27.sub_8bit:gr32 = SETGEr implicit killed $eflags
	Success: %0:sub_8bit -> %27
	Result = %27 [512r,624B:0)[720r,768B:1)[768B,800r:2)  0@512r 1@720r 2@768B-phi weight:0.000000e+00
880B	%61:gr32 = COPY %60:gr32
	Considering merging to GR32 with %60 in %61
		RHS = %60 [864r,880r:0)  0@864r weight:0.000000e+00
		LHS = %61 [880r,896r:0)[896r,912r:1)  0@880r 1@896r weight:0.000000e+00
		merge %61:0@880r into %60:0@864r --> @864r
		erased:	880r	%61:gr32 = COPY %60:gr32
		updated: 864B	%61:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
	Success: %60 -> %61
	Result = %61 [864r,896r:0)[896r,912r:1)  0@864r 1@896r weight:0.000000e+00
1472B	%49:gr32 = COPY %47:gr32
	Considering merging to GR32 with %47 in %49
		RHS = %47 [1440r,1472r:0)  0@1440r weight:0.000000e+00
		LHS = %49 [1472r,1488r:0)[1488r,1488d:1)  0@1472r 1@1488r weight:0.000000e+00
		merge %49:0@1472r into %47:0@1440r --> @1440r
		erased:	1472r	%49:gr32 = COPY %47:gr32
		updated: 1440B	%49:gr32 = MOV32rm $noreg, 4, %46:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx18)
	Success: %47 -> %49
	Result = %49 [1440r,1488r:0)[1488r,1488d:1)  0@1440r 1@1488r weight:0.000000e+00
1520B	undef %44.sub_8bit:gr32 = COPY %2:gr8
	Considering merging to GR32 with %2 in %44:sub_8bit
		RHS = %2 [1504r,1520r:0)  0@1504r weight:0.000000e+00
		LHS = %44 [1296r,1408B:0)[1520r,1552B:1)[1552B,1584r:2)  0@1296r 1@1520r 2@1552B-phi weight:0.000000e+00
		merge %44:1@1520r into %2:0@1504r --> @1504r
		erased:	1520r	undef %44.sub_8bit:gr32 = COPY %2:gr8
		updated: 1504B	undef %44.sub_8bit:gr32 = SETLr implicit killed $eflags
	Success: %2:sub_8bit -> %44
	Result = %44 [1296r,1408B:0)[1504r,1552B:1)[1552B,1584r:2)  0@1296r 1@1504r 2@1552B-phi weight:0.000000e+00
1664B	%59:gr32 = COPY %58:gr32
	Considering merging to GR32 with %58 in %59
		RHS = %58 [1648r,1664r:0)  0@1648r weight:0.000000e+00
		LHS = %59 [1664r,1680r:0)[1680r,1696r:1)  0@1664r 1@1680r weight:0.000000e+00
		merge %59:0@1664r into %58:0@1648r --> @1648r
		erased:	1664r	%59:gr32 = COPY %58:gr32
		updated: 1648B	%59:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
	Success: %58 -> %59
	Result = %59 [1648r,1680r:0)[1680r,1696r:1)  0@1648r 1@1680r weight:0.000000e+00
while.cond:
while.end:
if.end:
while.end23:
if.end31:
while.body:
if.then9:
if.then25:
368B	%15:gr32 = COPY %13:gr32
	Considering merging to GR32 with %13 in %15
		RHS = %13 [336r,368r:0)  0@336r weight:0.000000e+00
		LHS = %15 [368r,384r:0)[384r,384d:1)  0@368r 1@384r weight:0.000000e+00
		merge %15:0@368r into %13:0@336r --> @336r
		erased:	368r	%15:gr32 = COPY %13:gr32
		updated: 336B	%15:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
	Success: %13 -> %15
	Result = %15 [336r,384r:0)[384r,384d:1)  0@336r 1@384r weight:0.000000e+00
992B	%35:gr32 = COPY %33:gr32
	Considering merging to GR32 with %33 in %35
		RHS = %33 [960r,992r:0)  0@960r weight:0.000000e+00
		LHS = %35 [992r,1008r:0)[1008r,1008d:1)  0@992r 1@1008r weight:0.000000e+00
		merge %35:0@992r into %33:0@960r --> @960r
		erased:	992r	%35:gr32 = COPY %33:gr32
		updated: 960B	%35:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
	Success: %33 -> %35
	Result = %35 [960r,1008r:0)[1008r,1008d:1)  0@960r 1@1008r weight:0.000000e+00
1776B	%52:gr32 = COPY %50:gr32
	Considering merging to GR32 with %50 in %52
		RHS = %50 [1744r,1776r:0)  0@1744r weight:0.000000e+00
		LHS = %52 [1776r,1792r:0)[1792r,1792d:1)  0@1776r 1@1792r weight:0.000000e+00
		merge %52:0@1776r into %50:0@1744r --> @1744r
		erased:	1776r	%52:gr32 = COPY %50:gr32
		updated: 1744B	%52:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
	Success: %50 -> %52
	Result = %52 [1744r,1792r:0)[1792r,1792d:1)  0@1744r 1@1792r weight:0.000000e+00
1120B	%39:gr32 = COPY %38.sub_32bit:gr64_nosp
	Considering merging to GR64_NOSP with %39 in %38:sub_32bit
		RHS = %39 [1120r,1136r:0)  0@1120r weight:0.000000e+00
		LHS = %38 [1104r,1184r:0)  0@1104r weight:0.000000e+00
		merge %39:0@1120r into %38:0@1104r --> @1104r
		erased:	1120r	%39:gr32 = COPY %38.sub_32bit:gr64_nosp
AllocationOrder(GR64) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 ]
AllocationOrder(GR64_NOSP) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 ]
		updated: 1136B	%40:gr32 = COPY %38.sub_32bit:gr64_nosp
	Success: %39:sub_32bit -> %38
	Result = %38 [1104r,1184r:0)  0@1104r weight:0.000000e+00
1136B	%40:gr32 = COPY %38.sub_32bit:gr64_nosp
	Considering merging to GR64_NOSP with %40 in %38:sub_32bit
		RHS = %40 [1136r,1152r:0)[1152r,1168r:1)  0@1136r 1@1152r weight:0.000000e+00
		LHS = %38 [1104r,1184r:0)  0@1104r weight:0.000000e+00
		merge %40:0@1136r into %38:0@1104r --> @1104r
		conflict at %40:1@1152r
		taints local %38:0@1104r to 1184r
		tainted lanes used by: MOV32mr $noreg, 4, %38:gr64_nosp, @s, $noreg, %37:gr32 :: (store 4 into %ir.arrayidx13)
	Interference!
1904B	%56:gr32 = COPY %55.sub_32bit:gr64_nosp
	Considering merging to GR64_NOSP with %56 in %55:sub_32bit
		RHS = %56 [1904r,1920r:0)  0@1904r weight:0.000000e+00
		LHS = %55 [1888r,1968r:0)  0@1888r weight:0.000000e+00
		merge %56:0@1904r into %55:0@1888r --> @1888r
		erased:	1904r	%56:gr32 = COPY %55.sub_32bit:gr64_nosp
		updated: 1920B	%57:gr32 = COPY %55.sub_32bit:gr64_nosp
	Success: %56:sub_32bit -> %55
	Result = %55 [1888r,1968r:0)  0@1888r weight:0.000000e+00
1920B	%57:gr32 = COPY %55.sub_32bit:gr64_nosp
	Considering merging to GR64_NOSP with %57 in %55:sub_32bit
		RHS = %57 [1920r,1936r:0)[1936r,1952r:1)  0@1920r 1@1936r weight:0.000000e+00
		LHS = %55 [1888r,1968r:0)  0@1888r weight:0.000000e+00
		merge %57:0@1920r into %55:0@1888r --> @1888r
		conflict at %57:1@1936r
		taints local %55:0@1888r to 1968r
		tainted lanes used by: MOV32mr $noreg, 4, %55:gr64_nosp, @s, $noreg, %54:gr32 :: (store 4 into %ir.arrayidx30)
	Interference!
entry:
16B	%5:gr32 = COPY $esi
	Considering merging %5 with $esi
	Can only merge into reserved registers.
32B	%4:gr32 = COPY $edi
	Considering merging %4 with $edi
	Can only merge into reserved registers.
if.then:
while.end32:
2176B	$edi = COPY %18:gr32
	Considering merging %18 with $edi
	Can only merge into reserved registers.
2192B	$esi = COPY %20:gr32
	Considering merging %20 with $esi
	Can only merge into reserved registers.
2320B	$edi = COPY %22:gr32
	Considering merging %22 with $edi
	Can only merge into reserved registers.
2336B	$esi = COPY %23:gr32
	Considering merging %23 with $esi
	Can only merge into reserved registers.
if.end35:
112B	%8:gr32 = COPY %6:gr32
	Considering merging to GR32 with %6 in %8
		RHS = %6 [80r,112r:0)  0@80r weight:0.000000e+00
		LHS = %8 [112r,128r:0)[128r,128d:1)  0@112r 1@128r weight:0.000000e+00
		merge %8:0@112r into %6:0@80r --> @80r
		erased:	112r	%8:gr32 = COPY %6:gr32
		updated: 80B	%8:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
	Success: %6 -> %8
	Result = %8 [80r,128r:0)[128r,128d:1)  0@80r 1@128r weight:0.000000e+00
2128B	%20:gr32 = COPY %19:gr32
	Considering merging to GR32 with %19 in %20
		RHS = %19 [2112r,2128r:0)  0@2112r weight:0.000000e+00
		LHS = %20 [2128r,2144r:0)[2144r,2192r:1)  0@2128r 1@2144r weight:0.000000e+00
		merge %20:0@2128r into %19:0@2112r --> @2112r
		erased:	2128r	%20:gr32 = COPY %19:gr32
		updated: 2112B	%20:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
	Success: %19 -> %20
	Result = %20 [2112r,2144r:0)[2144r,2192r:1)  0@2112r 1@2144r weight:0.000000e+00
2256B	%22:gr32 = COPY %21:gr32
	Considering merging to GR32 with %21 in %22
		RHS = %21 [2240r,2256r:0)  0@2240r weight:0.000000e+00
		LHS = %22 [2256r,2272r:0)[2272r,2320r:1)  0@2256r 1@2272r weight:0.000000e+00
		merge %22:0@2256r into %21:0@2240r --> @2240r
		erased:	2256r	%22:gr32 = COPY %21:gr32
		updated: 2240B	%22:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
	Success: %21 -> %22
	Result = %22 [2240r,2272r:0)[2272r,2320r:1)  0@2240r 1@2272r weight:0.000000e+00
1136B	%40:gr32 = COPY %38.sub_32bit:gr64_nosp
	Considering merging to GR64_NOSP with %40 in %38:sub_32bit
		RHS = %40 [1136r,1152r:0)[1152r,1168r:1)  0@1136r 1@1152r weight:0.000000e+00
		LHS = %38 [1104r,1184r:0)  0@1104r weight:0.000000e+00
		merge %40:0@1136r into %38:0@1104r --> @1104r
		conflict at %40:1@1152r
		taints local %38:0@1104r to 1184r
		tainted lanes used by: MOV32mr $noreg, 4, %38:gr64_nosp, @s, $noreg, %37:gr32 :: (store 4 into %ir.arrayidx13)
	Interference!
1920B	%57:gr32 = COPY %55.sub_32bit:gr64_nosp
	Considering merging to GR64_NOSP with %57 in %55:sub_32bit
		RHS = %57 [1920r,1936r:0)[1936r,1952r:1)  0@1920r 1@1936r weight:0.000000e+00
		LHS = %55 [1888r,1968r:0)  0@1888r weight:0.000000e+00
		merge %57:0@1920r into %55:0@1888r --> @1888r
		conflict at %57:1@1936r
		taints local %55:0@1888r to 1968r
		tainted lanes used by: MOV32mr $noreg, 4, %55:gr64_nosp, @s, $noreg, %54:gr32 :: (store 4 into %ir.arrayidx30)
	Interference!
Trying to inflate 0 regs.
********** INTERVALS **********
DIL [0B,32r:0)[2176r,2208r:2)[2320r,2352r:1)  0@0B-phi 1@2320r 2@2176r
DIH [0B,32r:0)[2176r,2208r:2)[2320r,2352r:1)  0@0B-phi 1@2320r 2@2176r
HDI [0B,32r:0)[2176r,2208r:2)[2320r,2352r:1)  0@0B-phi 1@2320r 2@2176r
SIL [0B,16r:0)[2192r,2208r:2)[2336r,2352r:1)  0@0B-phi 1@2336r 2@2192r
SIH [0B,16r:0)[2192r,2208r:2)[2336r,2352r:1)  0@0B-phi 1@2336r 2@2192r
HSI [0B,16r:0)[2192r,2208r:2)[2336r,2352r:1)  0@0B-phi 1@2336r 2@2192r
%4 [32r,48r:0)  0@32r weight:0.000000e+00
%5 [16r,64r:0)  0@16r weight:0.000000e+00
%7 [96r,128r:0)  0@96r weight:0.000000e+00
%8 [80r,128r:0)[128r,128d:1)  0@80r 1@128r weight:0.000000e+00
%9 [192r,208r:0)  0@192r weight:0.000000e+00
%10 [224r,240r:0)  0@224r weight:0.000000e+00
%11 [256r,272r:0)  0@256r weight:0.000000e+00
%12 [272r,288r:0)  0@272r weight:0.000000e+00
%14 [352r,384r:0)  0@352r weight:0.000000e+00
%15 [336r,384r:0)[384r,384d:1)  0@336r 1@384r weight:0.000000e+00
%16 [2048r,2080r:0)  0@2048r weight:0.000000e+00
%17 [2064r,2080r:0)  0@2064r weight:0.000000e+00
%18 [2096r,2176r:0)  0@2096r weight:0.000000e+00
%20 [2112r,2144r:0)[2144r,2192r:1)  0@2112r 1@2144r weight:0.000000e+00
%22 [2240r,2272r:0)[2272r,2320r:1)  0@2240r 1@2272r weight:0.000000e+00
%23 [2288r,2336r:0)  0@2288r weight:0.000000e+00
%26 [496r,560r:0)  0@496r weight:0.000000e+00
%27 [512r,624B:0)[720r,768B:1)[768B,800r:2)  0@512r 1@720r 2@768B-phi weight:0.000000e+00
%28 [480r,560r:0)[560r,560d:1)  0@480r 1@560r weight:0.000000e+00
%29 [640r,656r:0)  0@640r weight:0.000000e+00
%31 [672r,704r:0)  0@672r weight:0.000000e+00
%32 [656r,704r:0)[704r,704d:1)  0@656r 1@704r weight:0.000000e+00
%34 [976r,1008r:0)  0@976r weight:0.000000e+00
%35 [960r,1008r:0)[1008r,1008d:1)  0@960r 1@1008r weight:0.000000e+00
%36 [1072r,1088r:0)  0@1072r weight:0.000000e+00
%37 [1088r,1184r:0)  0@1088r weight:0.000000e+00
%38 [1104r,1184r:0)  0@1104r weight:0.000000e+00
%40 [1136r,1152r:0)[1152r,1168r:1)  0@1136r 1@1152r weight:0.000000e+00
%43 [1280r,1344r:0)  0@1280r weight:0.000000e+00
%44 [1296r,1408B:0)[1504r,1552B:1)[1552B,1584r:2)  0@1296r 1@1504r 2@1552B-phi weight:0.000000e+00
%45 [1264r,1344r:0)[1344r,1344d:1)  0@1264r 1@1344r weight:0.000000e+00
%46 [1424r,1440r:0)  0@1424r weight:0.000000e+00
%48 [1456r,1488r:0)  0@1456r weight:0.000000e+00
%49 [1440r,1488r:0)[1488r,1488d:1)  0@1440r 1@1488r weight:0.000000e+00
%51 [1760r,1792r:0)  0@1760r weight:0.000000e+00
%52 [1744r,1792r:0)[1792r,1792d:1)  0@1744r 1@1792r weight:0.000000e+00
%53 [1856r,1872r:0)  0@1856r weight:0.000000e+00
%54 [1872r,1968r:0)  0@1872r weight:0.000000e+00
%55 [1888r,1968r:0)  0@1888r weight:0.000000e+00
%57 [1920r,1936r:0)[1936r,1952r:1)  0@1920r 1@1936r weight:0.000000e+00
%59 [1648r,1680r:0)[1680r,1696r:1)  0@1648r 1@1680r weight:0.000000e+00
%61 [864r,896r:0)[896r,912r:1)  0@864r 1@896r weight:0.000000e+00
RegMasks: 2208r 2352r
********** MACHINEINSTRS **********
# Machine code for function quick_sort: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=4, align=4, at location [SP+8]
  fi#3: size=4, align=4, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
Function Live Ins: $edi in %4, $esi in %5

0B	bb.0.entry:
	  successors: %bb.1, %bb.19
	  liveins: $edi, $esi
16B	  %5:gr32 = COPY $esi
32B	  %4:gr32 = COPY $edi
48B	  MOV32mr %stack.0.l.addr, 1, $noreg, 0, $noreg, %4:gr32 :: (store 4 into %ir.l.addr)
64B	  MOV32mr %stack.1.r.addr, 1, $noreg, 0, $noreg, %5:gr32 :: (store 4 into %ir.r.addr)
80B	  %8:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
96B	  %7:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
128B	  dead %8:gr32 = SUB32rr %8:gr32, %7:gr32, implicit-def $eflags
144B	  JGE_1 %bb.19, implicit killed $eflags
160B	  JMP_1 %bb.1

176B	bb.1.if.then:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(200.00%)

192B	  %9:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
208B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, %9:gr32 :: (store 4 into %ir.i)
224B	  %10:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
240B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, %10:gr32 :: (store 4 into %ir.j)
256B	  %11:gr64_nosp = MOVSX64rm32 %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
272B	  %12:gr32 = MOV32rm $noreg, 4, %11:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx)
288B	  MOV32mr %stack.4.x, 1, $noreg, 0, $noreg, %12:gr32 :: (store 4 into %ir.x)
304B	  JMP_1 %bb.2

320B	bb.2.while.cond:
	; predecessors: %bb.1, %bb.17
	  successors: %bb.3, %bb.18

336B	  %15:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
352B	  %14:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
384B	  dead %15:gr32 = SUB32rr %15:gr32, %14:gr32, implicit-def $eflags
400B	  JGE_1 %bb.18, implicit killed $eflags
416B	  JMP_1 %bb.3

432B	bb.3.while.body:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(200.00%)

448B	  JMP_1 %bb.4

464B	bb.4.while.cond2:
	; predecessors: %bb.3, %bb.7
	  successors: %bb.5, %bb.6

480B	  %28:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
496B	  %26:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
512B	  %27:gr32 = MOV32r0 implicit-def dead $eflags
560B	  dead %28:gr32 = SUB32rr %28:gr32, %26:gr32, implicit-def $eflags
592B	  JGE_1 %bb.6, implicit killed $eflags
608B	  JMP_1 %bb.5

624B	bb.5.land.rhs:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(200.00%)

640B	  %29:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
656B	  %32:gr32 = MOV32rm $noreg, 4, %29:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx5)
672B	  %31:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
704B	  dead %32:gr32 = SUB32rr %32:gr32, %31:gr32, implicit-def $eflags
720B	  undef %27.sub_8bit:gr32 = SETGEr implicit killed $eflags
752B	  JMP_1 %bb.6

768B	bb.6.land.end:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7, %bb.8

800B	  TEST8ri %27.sub_8bit:gr32, 1, implicit-def $eflags
816B	  JE_1 %bb.8, implicit killed $eflags
832B	  JMP_1 %bb.7

848B	bb.7.while.body7:
	; predecessors: %bb.6
	  successors: %bb.4(0x80000000); %bb.4(200.00%)

864B	  %61:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
896B	  %61:gr32 = ADD32ri8 %61:gr32, -1, implicit-def dead $eflags
912B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, %61:gr32 :: (store 4 into %ir.j)
928B	  JMP_1 %bb.4

944B	bb.8.while.end:
	; predecessors: %bb.6
	  successors: %bb.9, %bb.10

960B	  %35:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
976B	  %34:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1008B	  dead %35:gr32 = SUB32rr %35:gr32, %34:gr32, implicit-def $eflags
1024B	  JGE_1 %bb.10, implicit killed $eflags
1040B	  JMP_1 %bb.9

1056B	bb.9.if.then9:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(200.00%)

1072B	  %36:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1088B	  %37:gr32 = MOV32rm $noreg, 4, %36:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx11)
1104B	  %38:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1136B	  %40:gr32 = COPY %38.sub_32bit:gr64_nosp
1152B	  %40:gr32 = ADD32ri8 %40:gr32, 1, implicit-def dead $eflags
1168B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, %40:gr32 :: (store 4 into %ir.i)
1184B	  MOV32mr $noreg, 4, %38:gr64_nosp, @s, $noreg, %37:gr32 :: (store 4 into %ir.arrayidx13)
1200B	  JMP_1 %bb.10

1216B	bb.10.if.end:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x80000000); %bb.11(200.00%)

1232B	  JMP_1 %bb.11

1248B	bb.11.while.cond14:
	; predecessors: %bb.10, %bb.14
	  successors: %bb.12, %bb.13

1264B	  %45:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1280B	  %43:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1296B	  %44:gr32 = MOV32r0 implicit-def dead $eflags
1344B	  dead %45:gr32 = SUB32rr %45:gr32, %43:gr32, implicit-def $eflags
1376B	  JGE_1 %bb.13, implicit killed $eflags
1392B	  JMP_1 %bb.12

1408B	bb.12.land.rhs16:
	; predecessors: %bb.11
	  successors: %bb.13(0x80000000); %bb.13(200.00%)

1424B	  %46:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1440B	  %49:gr32 = MOV32rm $noreg, 4, %46:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx18)
1456B	  %48:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
1488B	  dead %49:gr32 = SUB32rr %49:gr32, %48:gr32, implicit-def $eflags
1504B	  undef %44.sub_8bit:gr32 = SETLr implicit killed $eflags
1536B	  JMP_1 %bb.13

1552B	bb.13.land.end20:
	; predecessors: %bb.11, %bb.12
	  successors: %bb.14, %bb.15

1584B	  TEST8ri %44.sub_8bit:gr32, 1, implicit-def $eflags
1600B	  JE_1 %bb.15, implicit killed $eflags
1616B	  JMP_1 %bb.14

1632B	bb.14.while.body21:
	; predecessors: %bb.13
	  successors: %bb.11(0x80000000); %bb.11(200.00%)

1648B	  %59:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1680B	  %59:gr32 = ADD32ri8 %59:gr32, 1, implicit-def dead $eflags
1696B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, %59:gr32 :: (store 4 into %ir.i)
1712B	  JMP_1 %bb.11

1728B	bb.15.while.end23:
	; predecessors: %bb.13
	  successors: %bb.16, %bb.17

1744B	  %52:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1760B	  %51:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1792B	  dead %52:gr32 = SUB32rr %52:gr32, %51:gr32, implicit-def $eflags
1808B	  JGE_1 %bb.17, implicit killed $eflags
1824B	  JMP_1 %bb.16

1840B	bb.16.if.then25:
	; predecessors: %bb.15
	  successors: %bb.17(0x80000000); %bb.17(200.00%)

1856B	  %53:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1872B	  %54:gr32 = MOV32rm $noreg, 4, %53:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx27)
1888B	  %55:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1920B	  %57:gr32 = COPY %55.sub_32bit:gr64_nosp
1936B	  %57:gr32 = ADD32ri8 %57:gr32, -1, implicit-def dead $eflags
1952B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, %57:gr32 :: (store 4 into %ir.j)
1968B	  MOV32mr $noreg, 4, %55:gr64_nosp, @s, $noreg, %54:gr32 :: (store 4 into %ir.arrayidx30)
1984B	  JMP_1 %bb.17

2000B	bb.17.if.end31:
	; predecessors: %bb.15, %bb.16
	  successors: %bb.2(0x80000000); %bb.2(200.00%)

2016B	  JMP_1 %bb.2

2032B	bb.18.while.end32:
	; predecessors: %bb.2
	  successors: %bb.19(0x80000000); %bb.19(200.00%)

2048B	  %16:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
2064B	  %17:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2080B	  MOV32mr $noreg, 4, %17:gr64_nosp, @s, $noreg, %16:gr32 :: (store 4 into %ir.arrayidx34)
2096B	  %18:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
2112B	  %20:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2144B	  %20:gr32 = ADD32ri8 %20:gr32, -1, implicit-def dead $eflags
2160B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2176B	  $edi = COPY %18:gr32
2192B	  $esi = COPY %20:gr32
2208B	  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
2224B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2240B	  %22:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2272B	  %22:gr32 = ADD32ri8 %22:gr32, 1, implicit-def dead $eflags
2288B	  %23:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
2304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2320B	  $edi = COPY %22:gr32
2336B	  $esi = COPY %23:gr32
2352B	  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
2368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2384B	  JMP_1 %bb.19

2400B	bb.19.if.end35:
	; predecessors: %bb.0, %bb.18

2416B	  RET 0

# End machine code for function quick_sort.

Skipping pass 'Machine Instruction Scheduler' on function quick_sort

block-frequency: quick_sort
===========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[if.then]
 - 2: BB2[while.cond]
 - 3: BB18[while.end32]
 - 4: BB19[if.end35]
 - 5: BB3[while.body]
 - 6: BB4[while.cond2]
 - 7: BB5[land.rhs]
 - 8: BB6[land.end]
 - 9: BB8[while.end]
 - 10: BB9[if.then9]
 - 11: BB10[if.end]
 - 12: BB11[while.cond14]
 - 13: BB12[land.rhs16]
 - 14: BB13[land.end20]
 - 15: BB15[while.end23]
 - 16: BB16[if.then25]
 - 17: BB17[if.end31]
 - 18: BB14[while.body21]
 - 19: BB7[while.body7]
loop-detection
 - loop = BB2[while.cond]
 - loop = BB4[while.cond2]
 - loop = BB11[while.cond14]
 - loop = BB2[while.cond]: member = BB3[while.body]
 - loop = BB4[while.cond2]: member = BB5[land.rhs]
 - loop = BB4[while.cond2]: member = BB6[land.end]
 - loop = BB2[while.cond]: member = BB8[while.end]
 - loop = BB2[while.cond]: member = BB9[if.then9]
 - loop = BB2[while.cond]: member = BB10[if.end]
 - loop = BB11[while.cond14]: member = BB12[land.rhs16]
 - loop = BB11[while.cond14]: member = BB13[land.end20]
 - loop = BB2[while.cond]: member = BB15[while.end23]
 - loop = BB2[while.cond]: member = BB16[if.then25]
 - loop = BB2[while.cond]: member = BB17[if.end31]
 - loop = BB11[while.cond14]: member = BB14[while.body21]
 - loop = BB4[while.cond2]: member = BB7[while.body7]
compute-mass-in-loop: BB11[while.cond14]*
 - node: BB11[while.cond14]
  => [ local  ] weight = 1073741824, succ = BB12[land.rhs16]
  => [ local  ] weight = 1073741824, succ = BB13[land.end20]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB12[land.rhs16]
  => assign 8000000000000000 (0000000000000000) to BB13[land.end20]
 - node: BB12[land.rhs16]
  => [ local  ] weight = 2147483648, succ = BB13[land.end20]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB13[land.end20]
 - node: BB13[land.end20]
  => [ local  ] weight = 1073741824, succ = BB14[while.body21]
  => [  exit  ] weight = 1073741824, succ = BB15[while.end23]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) [exit] to BB15[while.end23]
  => assign 8000000000000000 (0000000000000000) to BB14[while.body21]
 - node: BB14[while.body21]
  => [backedge] weight = 2147483648
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) [back] to BB11[while.cond14]
compute-loop-scale: BB11[while.cond14]*
 - exit-mass = 7fffffffffffffff (ffffffffffffffff - 8000000000000000)
 - scale = 2.0
packaging-loop: BB11[while.cond14]*
 - node: BB11[while.cond14]
 - node: BB12[land.rhs16]
 - node: BB13[land.end20]
 - node: BB14[while.body21]
compute-mass-in-loop: BB4[while.cond2]*
 - node: BB4[while.cond2]
  => [ local  ] weight = 1073741824, succ = BB5[land.rhs]
  => [ local  ] weight = 1073741824, succ = BB6[land.end]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB5[land.rhs]
  => assign 8000000000000000 (0000000000000000) to BB6[land.end]
 - node: BB5[land.rhs]
  => [ local  ] weight = 2147483648, succ = BB6[land.end]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB6[land.end]
 - node: BB6[land.end]
  => [ local  ] weight = 1073741824, succ = BB7[while.body7]
  => [  exit  ] weight = 1073741824, succ = BB8[while.end]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) [exit] to BB8[while.end]
  => assign 8000000000000000 (0000000000000000) to BB7[while.body7]
 - node: BB7[while.body7]
  => [backedge] weight = 2147483648
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) [back] to BB4[while.cond2]
compute-loop-scale: BB4[while.cond2]*
 - exit-mass = 7fffffffffffffff (ffffffffffffffff - 8000000000000000)
 - scale = 2.0
packaging-loop: BB4[while.cond2]*
 - node: BB4[while.cond2]
 - node: BB5[land.rhs]
 - node: BB6[land.end]
 - node: BB7[while.body7]
compute-mass-in-loop: BB2[while.cond]*
 - node: BB2[while.cond]
  => [ local  ] weight = 1073741824, succ = BB3[while.body]
  => [  exit  ] weight = 1073741824, succ = BB18[while.end32]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) [exit] to BB18[while.end32]
  => assign 8000000000000000 (0000000000000000) to BB3[while.body]
 - node: BB3[while.body]
  => [ local  ] weight = 2147483648, succ = BB4[while.cond2]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB4[while.cond2]
 - node: BB4[while.cond2]
  => [ local  ] weight = 9223372036854775807, succ = BB8[while.end]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB8[while.end]
 - node: BB8[while.end]
  => [ local  ] weight = 1073741824, succ = BB9[if.then9]
  => [ local  ] weight = 1073741824, succ = BB10[if.end]
  => mass:  8000000000000000
  => assign 4000000000000000 (4000000000000000) to BB9[if.then9]
  => assign 4000000000000000 (0000000000000000) to BB10[if.end]
 - node: BB9[if.then9]
  => [ local  ] weight = 2147483648, succ = BB10[if.end]
  => mass:  4000000000000000
  => assign 4000000000000000 (0000000000000000) to BB10[if.end]
 - node: BB10[if.end]
  => [ local  ] weight = 2147483648, succ = BB11[while.cond14]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB11[while.cond14]
 - node: BB11[while.cond14]
  => [ local  ] weight = 9223372036854775807, succ = BB15[while.end23]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB15[while.end23]
 - node: BB15[while.end23]
  => [ local  ] weight = 1073741824, succ = BB16[if.then25]
  => [ local  ] weight = 1073741824, succ = BB17[if.end31]
  => mass:  8000000000000000
  => assign 4000000000000000 (4000000000000000) to BB16[if.then25]
  => assign 4000000000000000 (0000000000000000) to BB17[if.end31]
 - node: BB16[if.then25]
  => [ local  ] weight = 2147483648, succ = BB17[if.end31]
  => mass:  4000000000000000
  => assign 4000000000000000 (0000000000000000) to BB17[if.end31]
 - node: BB17[if.end31]
  => [backedge] weight = 2147483648
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) [back] to BB2[while.cond]
compute-loop-scale: BB2[while.cond]*
 - exit-mass = 7fffffffffffffff (ffffffffffffffff - 8000000000000000)
 - scale = 2.0
packaging-loop: BB2[while.cond]*
 - node: BB2[while.cond]
 - node: BB3[while.body]
 - node: BB4[while.cond2]
 - node: BB8[while.end]
 - node: BB9[if.then9]
 - node: BB10[if.end]
 - node: BB11[while.cond14]
 - node: BB15[while.end23]
 - node: BB16[if.then25]
 - node: BB17[if.end31]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB1[if.then]
  => [ local  ] weight = 1073741824, succ = BB19[if.end35]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB1[if.then]
  => assign 8000000000000000 (0000000000000000) to BB19[if.end35]
 - node: BB1[if.then]
  => [ local  ] weight = 2147483648, succ = BB2[while.cond]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB2[while.cond]
 - node: BB2[while.cond]
  => [ local  ] weight = 9223372036854775807, succ = BB18[while.end32]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB18[while.end32]
 - node: BB18[while.end32]
  => [ local  ] weight = 2147483648, succ = BB19[if.end35]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB19[if.end35]
 - node: BB19[if.end35]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB2[while.cond]*: mass = 7fffffffffffffff, scale = 2.0
  => combined-scale = 1.0
 - BB2[while.cond]: 1.0 => 1.0
 - BB3[while.body]: 0.5 => 0.5
 - BB4[while.cond2]: 2.0 => 2.0
 - BB8[while.end]: 0.5 => 0.5
 - BB9[if.then9]: 0.25 => 0.25
 - BB10[if.end]: 0.5 => 0.5
 - BB11[while.cond14]: 2.0 => 2.0
 - BB15[while.end23]: 0.5 => 0.5
 - BB16[if.then25]: 0.25 => 0.25
 - BB17[if.end31]: 0.5 => 0.5
unwrap-loop-package: BB4[while.cond2]*: mass = 8000000000000000, scale = 2.0
  => combined-scale = 1.0
 - BB4[while.cond2]: 1.0 => 1.0
 - BB5[land.rhs]: 0.5 => 0.5
 - BB6[land.end]: 1.0 => 1.0
 - BB7[while.body7]: 0.5 => 0.5
unwrap-loop-package: BB11[while.cond14]*: mass = 8000000000000000, scale = 2.0
  => combined-scale = 1.0
 - BB11[while.cond14]: 1.0 => 1.0
 - BB12[land.rhs16]: 0.5 => 0.5
 - BB13[land.end20]: 1.0 => 1.0
 - BB14[while.body21]: 0.5 => 0.5
float-to-int: min = 0.25, max = 1.0, factor = 32.0
 - BB0[entry]: float = 1.0, scaled = 32.0, int = 31
 - BB1[if.then]: float = 0.5, scaled = 16.0, int = 15
 - BB2[while.cond]: float = 1.0, scaled = 32.0, int = 31
 - BB18[while.end32]: float = 0.5, scaled = 16.0, int = 15
 - BB19[if.end35]: float = 1.0, scaled = 32.0, int = 31
 - BB3[while.body]: float = 0.5, scaled = 16.0, int = 15
 - BB4[while.cond2]: float = 1.0, scaled = 32.0, int = 31
 - BB5[land.rhs]: float = 0.5, scaled = 16.0, int = 15
 - BB6[land.end]: float = 1.0, scaled = 32.0, int = 31
 - BB8[while.end]: float = 0.5, scaled = 16.0, int = 15
 - BB9[if.then9]: float = 0.25, scaled = 8.0, int = 8
 - BB10[if.end]: float = 0.5, scaled = 16.0, int = 15
 - BB11[while.cond14]: float = 1.0, scaled = 32.0, int = 31
 - BB12[land.rhs16]: float = 0.5, scaled = 16.0, int = 15
 - BB13[land.end20]: float = 1.0, scaled = 32.0, int = 31
 - BB15[while.end23]: float = 0.5, scaled = 16.0, int = 15
 - BB16[if.then25]: float = 0.25, scaled = 8.0, int = 8
 - BB17[if.end31]: float = 0.5, scaled = 16.0, int = 15
 - BB14[while.body21]: float = 0.5, scaled = 16.0, int = 16
 - BB7[while.body7]: float = 0.5, scaled = 16.0, int = 16
block-frequency-info: quick_sort
 - BB0[entry]: float = 1.0, int = 31
 - BB1[if.then]: float = 0.5, int = 15
 - BB2[while.cond]: float = 1.0, int = 31
 - BB3[while.body]: float = 0.5, int = 15
 - BB4[while.cond2]: float = 1.0, int = 31
 - BB5[land.rhs]: float = 0.5, int = 15
 - BB6[land.end]: float = 1.0, int = 31
 - BB7[while.body7]: float = 0.5, int = 16
 - BB8[while.end]: float = 0.5, int = 15
 - BB9[if.then9]: float = 0.25, int = 8
 - BB10[if.end]: float = 0.5, int = 15
 - BB11[while.cond14]: float = 1.0, int = 31
 - BB12[land.rhs16]: float = 0.5, int = 15
 - BB13[land.end20]: float = 1.0, int = 31
 - BB14[while.body21]: float = 0.5, int = 16
 - BB15[while.end23]: float = 0.5, int = 15
 - BB16[if.then25]: float = 0.25, int = 8
 - BB17[if.end31]: float = 0.5, int = 15
 - BB18[while.end32]: float = 0.5, int = 15
 - BB19[if.end35]: float = 1.0, int = 31

********** GREEDY REGISTER ALLOCATION **********
********** Function: quick_sort
********** Compute Spill Weights **********
********** Function: quick_sort
********** INTERVALS **********
DIL [0B,32r:0)[2176r,2208r:2)[2320r,2352r:1)  0@0B-phi 1@2320r 2@2176r
DIH [0B,32r:0)[2176r,2208r:2)[2320r,2352r:1)  0@0B-phi 1@2320r 2@2176r
HDI [0B,32r:0)[2176r,2208r:2)[2320r,2352r:1)  0@0B-phi 1@2320r 2@2176r
SIL [0B,16r:0)[2192r,2208r:2)[2336r,2352r:1)  0@0B-phi 1@2336r 2@2192r
SIH [0B,16r:0)[2192r,2208r:2)[2336r,2352r:1)  0@0B-phi 1@2336r 2@2192r
HSI [0B,16r:0)[2192r,2208r:2)[2336r,2352r:1)  0@0B-phi 1@2336r 2@2192r
%4 [32r,48r:0)  0@32r weight:INF
%5 [16r,64r:0)  0@16r weight:4.508928e-03
%7 [96r,128r:0)  0@96r weight:INF
%8 [80r,128r:0)[128r,128d:1)  0@80r 1@128r weight:6.681514e-03
%9 [192r,208r:0)  0@192r weight:INF
%10 [224r,240r:0)  0@224r weight:INF
%11 [256r,272r:0)  0@256r weight:INF
%12 [272r,288r:0)  0@272r weight:INF
%14 [352r,384r:0)  0@352r weight:INF
%15 [336r,384r:0)[384r,384d:1)  0@336r 1@384r weight:6.681514e-03
%16 [2048r,2080r:0)  0@2048r weight:2.240143e-03
%17 [2064r,2080r:0)  0@2064r weight:INF
%18 [2096r,2176r:0)  0@2096r weight:2.036290e-03
%20 [2112r,2144r:0)[2144r,2192r:1)  0@2112r 1@2144r weight:4.072580e-03
%22 [2240r,2272r:0)[2272r,2320r:1)  0@2240r 1@2272r weight:4.072580e-03
%23 [2288r,2336r:0)  0@2288r weight:2.181740e-03
%26 [496r,560r:0)  0@496r weight:4.310345e-03
%27 [512r,624B:0)[720r,768B:1)[768B,800r:2)  0@512r 1@720r 2@768B-phi weight:4.209951e-03
%28 [480r,560r:0)[560r,560d:1)  0@480r 1@560r weight:6.237006e-03
%29 [640r,656r:0)  0@640r weight:INF
%31 [672r,704r:0)  0@672r weight:INF
%32 [656r,704r:0)[704r,704d:1)  0@656r 1@704r weight:3.232991e-03
%34 [976r,1008r:0)  0@976r weight:INF
%35 [960r,1008r:0)[1008r,1008d:1)  0@960r 1@1008r weight:3.232991e-03
%36 [1072r,1088r:0)  0@1072r weight:INF
%37 [1088r,1184r:0)  0@1088r weight:1.040583e-03
%38 [1104r,1184r:0)  0@1104r weight:1.612903e-03
%40 [1136r,1152r:0)[1152r,1168r:1)  0@1136r 1@1152r weight:INF
%43 [1280r,1344r:0)  0@1280r weight:4.310345e-03
%44 [1296r,1408B:0)[1504r,1552B:1)[1552B,1584r:2)  0@1296r 1@1504r 2@1552B-phi weight:4.209951e-03
%45 [1264r,1344r:0)[1344r,1344d:1)  0@1264r 1@1344r weight:6.237006e-03
%46 [1424r,1440r:0)  0@1424r weight:INF
%48 [1456r,1488r:0)  0@1456r weight:INF
%49 [1440r,1488r:0)[1488r,1488d:1)  0@1440r 1@1488r weight:3.232991e-03
%51 [1760r,1792r:0)  0@1760r weight:INF
%52 [1744r,1792r:0)[1792r,1792d:1)  0@1744r 1@1792r weight:3.232991e-03
%53 [1856r,1872r:0)  0@1856r weight:INF
%54 [1872r,1968r:0)  0@1872r weight:1.040583e-03
%55 [1888r,1968r:0)  0@1888r weight:1.612903e-03
%57 [1920r,1936r:0)[1936r,1952r:1)  0@1920r 1@1936r weight:INF
%59 [1648r,1680r:0)[1680r,1696r:1)  0@1648r 1@1680r weight:INF
%61 [864r,896r:0)[896r,912r:1)  0@864r 1@896r weight:INF
RegMasks: 2208r 2352r
********** MACHINEINSTRS **********
# Machine code for function quick_sort: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=4, align=4, at location [SP+8]
  fi#3: size=4, align=4, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
Function Live Ins: $edi in %4, $esi in %5

0B	bb.0.entry:
	  successors: %bb.1, %bb.19
	  liveins: $edi, $esi
16B	  %5:gr32 = COPY $esi
32B	  %4:gr32 = COPY $edi
48B	  MOV32mr %stack.0.l.addr, 1, $noreg, 0, $noreg, %4:gr32 :: (store 4 into %ir.l.addr)
64B	  MOV32mr %stack.1.r.addr, 1, $noreg, 0, $noreg, %5:gr32 :: (store 4 into %ir.r.addr)
80B	  %8:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
96B	  %7:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
128B	  dead %8:gr32 = SUB32rr %8:gr32, %7:gr32, implicit-def $eflags
144B	  JGE_1 %bb.19, implicit killed $eflags
160B	  JMP_1 %bb.1

176B	bb.1.if.then:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(200.00%)

192B	  %9:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
208B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, %9:gr32 :: (store 4 into %ir.i)
224B	  %10:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
240B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, %10:gr32 :: (store 4 into %ir.j)
256B	  %11:gr64_nosp = MOVSX64rm32 %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
272B	  %12:gr32 = MOV32rm $noreg, 4, %11:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx)
288B	  MOV32mr %stack.4.x, 1, $noreg, 0, $noreg, %12:gr32 :: (store 4 into %ir.x)
304B	  JMP_1 %bb.2

320B	bb.2.while.cond:
	; predecessors: %bb.1, %bb.17
	  successors: %bb.3, %bb.18

336B	  %15:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
352B	  %14:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
384B	  dead %15:gr32 = SUB32rr %15:gr32, %14:gr32, implicit-def $eflags
400B	  JGE_1 %bb.18, implicit killed $eflags
416B	  JMP_1 %bb.3

432B	bb.3.while.body:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(200.00%)

448B	  JMP_1 %bb.4

464B	bb.4.while.cond2:
	; predecessors: %bb.3, %bb.7
	  successors: %bb.5, %bb.6

480B	  %28:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
496B	  %26:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
512B	  %27:gr32 = MOV32r0 implicit-def dead $eflags
560B	  dead %28:gr32 = SUB32rr %28:gr32, %26:gr32, implicit-def $eflags
592B	  JGE_1 %bb.6, implicit killed $eflags
608B	  JMP_1 %bb.5

624B	bb.5.land.rhs:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(200.00%)

640B	  %29:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
656B	  %32:gr32 = MOV32rm $noreg, 4, %29:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx5)
672B	  %31:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
704B	  dead %32:gr32 = SUB32rr %32:gr32, %31:gr32, implicit-def $eflags
720B	  undef %27.sub_8bit:gr32 = SETGEr implicit killed $eflags
752B	  JMP_1 %bb.6

768B	bb.6.land.end:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7, %bb.8

800B	  TEST8ri %27.sub_8bit:gr32, 1, implicit-def $eflags
816B	  JE_1 %bb.8, implicit killed $eflags
832B	  JMP_1 %bb.7

848B	bb.7.while.body7:
	; predecessors: %bb.6
	  successors: %bb.4(0x80000000); %bb.4(200.00%)

864B	  %61:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
896B	  %61:gr32 = ADD32ri8 %61:gr32, -1, implicit-def dead $eflags
912B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, %61:gr32 :: (store 4 into %ir.j)
928B	  JMP_1 %bb.4

944B	bb.8.while.end:
	; predecessors: %bb.6
	  successors: %bb.9, %bb.10

960B	  %35:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
976B	  %34:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1008B	  dead %35:gr32 = SUB32rr %35:gr32, %34:gr32, implicit-def $eflags
1024B	  JGE_1 %bb.10, implicit killed $eflags
1040B	  JMP_1 %bb.9

1056B	bb.9.if.then9:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(200.00%)

1072B	  %36:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1088B	  %37:gr32 = MOV32rm $noreg, 4, %36:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx11)
1104B	  %38:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1136B	  %40:gr32 = COPY %38.sub_32bit:gr64_nosp
1152B	  %40:gr32 = ADD32ri8 %40:gr32, 1, implicit-def dead $eflags
1168B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, %40:gr32 :: (store 4 into %ir.i)
1184B	  MOV32mr $noreg, 4, %38:gr64_nosp, @s, $noreg, %37:gr32 :: (store 4 into %ir.arrayidx13)
1200B	  JMP_1 %bb.10

1216B	bb.10.if.end:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x80000000); %bb.11(200.00%)

1232B	  JMP_1 %bb.11

1248B	bb.11.while.cond14:
	; predecessors: %bb.10, %bb.14
	  successors: %bb.12, %bb.13

1264B	  %45:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1280B	  %43:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1296B	  %44:gr32 = MOV32r0 implicit-def dead $eflags
1344B	  dead %45:gr32 = SUB32rr %45:gr32, %43:gr32, implicit-def $eflags
1376B	  JGE_1 %bb.13, implicit killed $eflags
1392B	  JMP_1 %bb.12

1408B	bb.12.land.rhs16:
	; predecessors: %bb.11
	  successors: %bb.13(0x80000000); %bb.13(200.00%)

1424B	  %46:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1440B	  %49:gr32 = MOV32rm $noreg, 4, %46:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx18)
1456B	  %48:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
1488B	  dead %49:gr32 = SUB32rr %49:gr32, %48:gr32, implicit-def $eflags
1504B	  undef %44.sub_8bit:gr32 = SETLr implicit killed $eflags
1536B	  JMP_1 %bb.13

1552B	bb.13.land.end20:
	; predecessors: %bb.11, %bb.12
	  successors: %bb.14, %bb.15

1584B	  TEST8ri %44.sub_8bit:gr32, 1, implicit-def $eflags
1600B	  JE_1 %bb.15, implicit killed $eflags
1616B	  JMP_1 %bb.14

1632B	bb.14.while.body21:
	; predecessors: %bb.13
	  successors: %bb.11(0x80000000); %bb.11(200.00%)

1648B	  %59:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1680B	  %59:gr32 = ADD32ri8 %59:gr32, 1, implicit-def dead $eflags
1696B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, %59:gr32 :: (store 4 into %ir.i)
1712B	  JMP_1 %bb.11

1728B	bb.15.while.end23:
	; predecessors: %bb.13
	  successors: %bb.16, %bb.17

1744B	  %52:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1760B	  %51:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1792B	  dead %52:gr32 = SUB32rr %52:gr32, %51:gr32, implicit-def $eflags
1808B	  JGE_1 %bb.17, implicit killed $eflags
1824B	  JMP_1 %bb.16

1840B	bb.16.if.then25:
	; predecessors: %bb.15
	  successors: %bb.17(0x80000000); %bb.17(200.00%)

1856B	  %53:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1872B	  %54:gr32 = MOV32rm $noreg, 4, %53:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx27)
1888B	  %55:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1920B	  %57:gr32 = COPY %55.sub_32bit:gr64_nosp
1936B	  %57:gr32 = ADD32ri8 %57:gr32, -1, implicit-def dead $eflags
1952B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, %57:gr32 :: (store 4 into %ir.j)
1968B	  MOV32mr $noreg, 4, %55:gr64_nosp, @s, $noreg, %54:gr32 :: (store 4 into %ir.arrayidx30)
1984B	  JMP_1 %bb.17

2000B	bb.17.if.end31:
	; predecessors: %bb.15, %bb.16
	  successors: %bb.2(0x80000000); %bb.2(200.00%)

2016B	  JMP_1 %bb.2

2032B	bb.18.while.end32:
	; predecessors: %bb.2
	  successors: %bb.19(0x80000000); %bb.19(200.00%)

2048B	  %16:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
2064B	  %17:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2080B	  MOV32mr $noreg, 4, %17:gr64_nosp, @s, $noreg, %16:gr32 :: (store 4 into %ir.arrayidx34)
2096B	  %18:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
2112B	  %20:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2144B	  %20:gr32 = ADD32ri8 %20:gr32, -1, implicit-def dead $eflags
2160B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2176B	  $edi = COPY %18:gr32
2192B	  $esi = COPY %20:gr32
2208B	  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
2224B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2240B	  %22:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2272B	  %22:gr32 = ADD32ri8 %22:gr32, 1, implicit-def dead $eflags
2288B	  %23:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
2304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2320B	  $edi = COPY %22:gr32
2336B	  $esi = COPY %23:gr32
2352B	  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
2368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2384B	  JMP_1 %bb.19

2400B	bb.19.if.end35:
	; predecessors: %bb.0, %bb.18

2416B	  RET 0

# End machine code for function quick_sort.


selectOrSplit GR32:%5 [16r,64r:0)  0@16r weight:4.508928e-03 w=4.508928e-03
AllocationOrder(GR32) = [ $eax $ecx $edx $esi $edi $r8d $r9d $r10d $r11d $ebx $r14d $r15d $r12d $r13d ]
hints: $esi
assigning %5 to $esi: SIL [16r,64r:0)  0@16r SIH [16r,64r:0)  0@16r HSI [16r,64r:0)  0@16r

selectOrSplit GR32:%4 [32r,48r:0)  0@32r weight:INF w=INF
hints: $edi
assigning %4 to $edi: DIL [32r,48r:0)  0@32r DIH [32r,48r:0)  0@32r HDI [32r,48r:0)  0@32r

selectOrSplit GR32:%18 [2096r,2176r:0)  0@2096r weight:2.036290e-03 w=2.036290e-03
hints: $edi
assigning %18 to $edi: DIL [2096r,2176r:0)  0@2096r DIH [2096r,2176r:0)  0@2096r HDI [2096r,2176r:0)  0@2096r

selectOrSplit GR32:%20 [2112r,2144r:0)[2144r,2192r:1)  0@2112r 1@2144r weight:4.072580e-03 w=4.072580e-03
hints: $esi
assigning %20 to $esi: SIL [2112r,2144r:0)[2144r,2192r:1)  0@2112r 1@2144r SIH [2112r,2144r:0)[2144r,2192r:1)  0@2112r 1@2144r HSI [2112r,2144r:0)[2144r,2192r:1)  0@2112r 1@2144r

selectOrSplit GR32:%22 [2240r,2272r:0)[2272r,2320r:1)  0@2240r 1@2272r weight:4.072580e-03 w=4.072580e-03
hints: $edi
assigning %22 to $edi: DIL [2240r,2272r:0)[2272r,2320r:1)  0@2240r 1@2272r DIH [2240r,2272r:0)[2272r,2320r:1)  0@2240r 1@2272r HDI [2240r,2272r:0)[2272r,2320r:1)  0@2240r 1@2272r

selectOrSplit GR32:%23 [2288r,2336r:0)  0@2288r weight:2.181740e-03 w=2.181740e-03
hints: $esi
assigning %23 to $esi: SIL [2288r,2336r:0)  0@2288r SIH [2288r,2336r:0)  0@2288r HSI [2288r,2336r:0)  0@2288r

selectOrSplit GR32:%27 [512r,624B:0)[720r,768B:1)[768B,800r:2)  0@512r 1@720r 2@768B-phi weight:4.209951e-03 w=4.209951e-03
assigning %27 to $eax: AH [512r,624B:0)[720r,768B:1)[768B,800r:2)  0@512r 1@720r 2@768B-phi AL [512r,624B:0)[720r,768B:1)[768B,800r:2)  0@512r 1@720r 2@768B-phi HAX [512r,624B:0)[720r,768B:1)[768B,800r:2)  0@512r 1@720r 2@768B-phi

selectOrSplit GR32:%44 [1296r,1408B:0)[1504r,1552B:1)[1552B,1584r:2)  0@1296r 1@1504r 2@1552B-phi weight:4.209951e-03 w=4.209951e-03
assigning %44 to $eax: AH [1296r,1408B:0)[1504r,1552B:1)[1552B,1584r:2)  0@1296r 1@1504r 2@1552B-phi AL [1296r,1408B:0)[1504r,1552B:1)[1552B,1584r:2)  0@1296r 1@1504r 2@1552B-phi HAX [1296r,1408B:0)[1504r,1552B:1)[1552B,1584r:2)  0@1296r 1@1504r 2@1552B-phi

selectOrSplit GR32:%8 [80r,128r:0)[128r,128d:1)  0@80r 1@128r weight:6.681514e-03 w=6.681514e-03
assigning %8 to $eax: AH [80r,128r:0)[128r,128d:1)  0@80r 1@128r AL [80r,128r:0)[128r,128d:1)  0@80r 1@128r HAX [80r,128r:0)[128r,128d:1)  0@80r 1@128r

selectOrSplit GR32:%7 [96r,128r:0)  0@96r weight:INF w=INF
assigning %7 to $ecx: CH [96r,128r:0)  0@96r CL [96r,128r:0)  0@96r HCX [96r,128r:0)  0@96r

selectOrSplit GR32:%9 [192r,208r:0)  0@192r weight:INF w=INF
assigning %9 to $eax: AH [192r,208r:0)  0@192r AL [192r,208r:0)  0@192r HAX [192r,208r:0)  0@192r

selectOrSplit GR32:%10 [224r,240r:0)  0@224r weight:INF w=INF
assigning %10 to $eax: AH [224r,240r:0)  0@224r AL [224r,240r:0)  0@224r HAX [224r,240r:0)  0@224r

selectOrSplit GR64_NOSP:%11 [256r,272r:0)  0@256r weight:INF w=INF
AllocationOrder(GR64) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 ]
AllocationOrder(GR64_NOSP) = [ $rax $rcx $rdx $rsi $rdi $r8 $r9 $r10 $r11 $rbx $r14 $r15 $r12 $r13 ]
assigning %11 to $rax: AH [256r,272r:0)  0@256r AL [256r,272r:0)  0@256r HAX [256r,272r:0)  0@256r

selectOrSplit GR32:%12 [272r,288r:0)  0@272r weight:INF w=INF
assigning %12 to $eax: AH [272r,288r:0)  0@272r AL [272r,288r:0)  0@272r HAX [272r,288r:0)  0@272r

selectOrSplit GR32:%15 [336r,384r:0)[384r,384d:1)  0@336r 1@384r weight:6.681514e-03 w=6.681514e-03
assigning %15 to $eax: AH [336r,384r:0)[384r,384d:1)  0@336r 1@384r AL [336r,384r:0)[384r,384d:1)  0@336r 1@384r HAX [336r,384r:0)[384r,384d:1)  0@336r 1@384r

selectOrSplit GR32:%14 [352r,384r:0)  0@352r weight:INF w=INF
assigning %14 to $ecx: CH [352r,384r:0)  0@352r CL [352r,384r:0)  0@352r HCX [352r,384r:0)  0@352r

selectOrSplit GR32:%28 [480r,560r:0)[560r,560d:1)  0@480r 1@560r weight:6.237006e-03 w=6.237006e-03
assigning %28 to $ecx: CH [480r,560r:0)[560r,560d:1)  0@480r 1@560r CL [480r,560r:0)[560r,560d:1)  0@480r 1@560r HCX [480r,560r:0)[560r,560d:1)  0@480r 1@560r

selectOrSplit GR32:%26 [496r,560r:0)  0@496r weight:4.310345e-03 w=4.310345e-03
assigning %26 to $edx: DH [496r,560r:0)  0@496r DL [496r,560r:0)  0@496r HDX [496r,560r:0)  0@496r

selectOrSplit GR64_NOSP:%29 [640r,656r:0)  0@640r weight:INF w=INF
assigning %29 to $rax: AH [640r,656r:0)  0@640r AL [640r,656r:0)  0@640r HAX [640r,656r:0)  0@640r

selectOrSplit GR32:%32 [656r,704r:0)[704r,704d:1)  0@656r 1@704r weight:3.232991e-03 w=3.232991e-03
assigning %32 to $eax: AH [656r,704r:0)[704r,704d:1)  0@656r 1@704r AL [656r,704r:0)[704r,704d:1)  0@656r 1@704r HAX [656r,704r:0)[704r,704d:1)  0@656r 1@704r

selectOrSplit GR32:%31 [672r,704r:0)  0@672r weight:INF w=INF
assigning %31 to $ecx: CH [672r,704r:0)  0@672r CL [672r,704r:0)  0@672r HCX [672r,704r:0)  0@672r

selectOrSplit GR32:%61 [864r,896r:0)[896r,912r:1)  0@864r 1@896r weight:INF w=INF
assigning %61 to $eax: AH [864r,896r:0)[896r,912r:1)  0@864r 1@896r AL [864r,896r:0)[896r,912r:1)  0@864r 1@896r HAX [864r,896r:0)[896r,912r:1)  0@864r 1@896r

selectOrSplit GR32:%35 [960r,1008r:0)[1008r,1008d:1)  0@960r 1@1008r weight:3.232991e-03 w=3.232991e-03
assigning %35 to $eax: AH [960r,1008r:0)[1008r,1008d:1)  0@960r 1@1008r AL [960r,1008r:0)[1008r,1008d:1)  0@960r 1@1008r HAX [960r,1008r:0)[1008r,1008d:1)  0@960r 1@1008r

selectOrSplit GR32:%34 [976r,1008r:0)  0@976r weight:INF w=INF
assigning %34 to $ecx: CH [976r,1008r:0)  0@976r CL [976r,1008r:0)  0@976r HCX [976r,1008r:0)  0@976r

selectOrSplit GR64_NOSP:%36 [1072r,1088r:0)  0@1072r weight:INF w=INF
assigning %36 to $rax: AH [1072r,1088r:0)  0@1072r AL [1072r,1088r:0)  0@1072r HAX [1072r,1088r:0)  0@1072r

selectOrSplit GR32:%37 [1088r,1184r:0)  0@1088r weight:1.040583e-03 w=1.040583e-03
assigning %37 to $eax: AH [1088r,1184r:0)  0@1088r AL [1088r,1184r:0)  0@1088r HAX [1088r,1184r:0)  0@1088r

selectOrSplit GR64_NOSP:%38 [1104r,1184r:0)  0@1104r weight:1.612903e-03 w=1.612903e-03
assigning %38 to $rcx: CH [1104r,1184r:0)  0@1104r CL [1104r,1184r:0)  0@1104r HCX [1104r,1184r:0)  0@1104r

selectOrSplit GR32:%40 [1136r,1152r:0)[1152r,1168r:1)  0@1136r 1@1152r weight:INF w=INF
assigning %40 to $edx: DH [1136r,1152r:0)[1152r,1168r:1)  0@1136r 1@1152r DL [1136r,1152r:0)[1152r,1168r:1)  0@1136r 1@1152r HDX [1136r,1152r:0)[1152r,1168r:1)  0@1136r 1@1152r

selectOrSplit GR32:%45 [1264r,1344r:0)[1344r,1344d:1)  0@1264r 1@1344r weight:6.237006e-03 w=6.237006e-03
assigning %45 to $ecx: CH [1264r,1344r:0)[1344r,1344d:1)  0@1264r 1@1344r CL [1264r,1344r:0)[1344r,1344d:1)  0@1264r 1@1344r HCX [1264r,1344r:0)[1344r,1344d:1)  0@1264r 1@1344r

selectOrSplit GR32:%43 [1280r,1344r:0)  0@1280r weight:4.310345e-03 w=4.310345e-03
assigning %43 to $edx: DH [1280r,1344r:0)  0@1280r DL [1280r,1344r:0)  0@1280r HDX [1280r,1344r:0)  0@1280r

selectOrSplit GR64_NOSP:%46 [1424r,1440r:0)  0@1424r weight:INF w=INF
assigning %46 to $rax: AH [1424r,1440r:0)  0@1424r AL [1424r,1440r:0)  0@1424r HAX [1424r,1440r:0)  0@1424r

selectOrSplit GR32:%49 [1440r,1488r:0)[1488r,1488d:1)  0@1440r 1@1488r weight:3.232991e-03 w=3.232991e-03
assigning %49 to $eax: AH [1440r,1488r:0)[1488r,1488d:1)  0@1440r 1@1488r AL [1440r,1488r:0)[1488r,1488d:1)  0@1440r 1@1488r HAX [1440r,1488r:0)[1488r,1488d:1)  0@1440r 1@1488r

selectOrSplit GR32:%48 [1456r,1488r:0)  0@1456r weight:INF w=INF
assigning %48 to $ecx: CH [1456r,1488r:0)  0@1456r CL [1456r,1488r:0)  0@1456r HCX [1456r,1488r:0)  0@1456r

selectOrSplit GR32:%59 [1648r,1680r:0)[1680r,1696r:1)  0@1648r 1@1680r weight:INF w=INF
assigning %59 to $eax: AH [1648r,1680r:0)[1680r,1696r:1)  0@1648r 1@1680r AL [1648r,1680r:0)[1680r,1696r:1)  0@1648r 1@1680r HAX [1648r,1680r:0)[1680r,1696r:1)  0@1648r 1@1680r

selectOrSplit GR32:%52 [1744r,1792r:0)[1792r,1792d:1)  0@1744r 1@1792r weight:3.232991e-03 w=3.232991e-03
assigning %52 to $eax: AH [1744r,1792r:0)[1792r,1792d:1)  0@1744r 1@1792r AL [1744r,1792r:0)[1792r,1792d:1)  0@1744r 1@1792r HAX [1744r,1792r:0)[1792r,1792d:1)  0@1744r 1@1792r

selectOrSplit GR32:%51 [1760r,1792r:0)  0@1760r weight:INF w=INF
assigning %51 to $ecx: CH [1760r,1792r:0)  0@1760r CL [1760r,1792r:0)  0@1760r HCX [1760r,1792r:0)  0@1760r

selectOrSplit GR64_NOSP:%53 [1856r,1872r:0)  0@1856r weight:INF w=INF
assigning %53 to $rax: AH [1856r,1872r:0)  0@1856r AL [1856r,1872r:0)  0@1856r HAX [1856r,1872r:0)  0@1856r

selectOrSplit GR32:%54 [1872r,1968r:0)  0@1872r weight:1.040583e-03 w=1.040583e-03
assigning %54 to $eax: AH [1872r,1968r:0)  0@1872r AL [1872r,1968r:0)  0@1872r HAX [1872r,1968r:0)  0@1872r

selectOrSplit GR64_NOSP:%55 [1888r,1968r:0)  0@1888r weight:1.612903e-03 w=1.612903e-03
assigning %55 to $rcx: CH [1888r,1968r:0)  0@1888r CL [1888r,1968r:0)  0@1888r HCX [1888r,1968r:0)  0@1888r

selectOrSplit GR32:%57 [1920r,1936r:0)[1936r,1952r:1)  0@1920r 1@1936r weight:INF w=INF
assigning %57 to $edx: DH [1920r,1936r:0)[1936r,1952r:1)  0@1920r 1@1936r DL [1920r,1936r:0)[1936r,1952r:1)  0@1920r 1@1936r HDX [1920r,1936r:0)[1936r,1952r:1)  0@1920r 1@1936r

selectOrSplit GR32:%16 [2048r,2080r:0)  0@2048r weight:2.240143e-03 w=2.240143e-03
assigning %16 to $eax: AH [2048r,2080r:0)  0@2048r AL [2048r,2080r:0)  0@2048r HAX [2048r,2080r:0)  0@2048r

selectOrSplit GR64_NOSP:%17 [2064r,2080r:0)  0@2064r weight:INF w=INF
assigning %17 to $rcx: CH [2064r,2080r:0)  0@2064r CL [2064r,2080r:0)  0@2064r HCX [2064r,2080r:0)  0@2064r
********** REWRITE VIRTUAL REGISTERS **********
********** Function: quick_sort
********** REGISTER MAP **********
[%4 -> $edi] GR32
[%5 -> $esi] GR32
[%7 -> $ecx] GR32
[%8 -> $eax] GR32
[%9 -> $eax] GR32
[%10 -> $eax] GR32
[%11 -> $rax] GR64_NOSP
[%12 -> $eax] GR32
[%14 -> $ecx] GR32
[%15 -> $eax] GR32
[%16 -> $eax] GR32
[%17 -> $rcx] GR64_NOSP
[%18 -> $edi] GR32
[%20 -> $esi] GR32
[%22 -> $edi] GR32
[%23 -> $esi] GR32
[%26 -> $edx] GR32
[%27 -> $eax] GR32
[%28 -> $ecx] GR32
[%29 -> $rax] GR64_NOSP
[%31 -> $ecx] GR32
[%32 -> $eax] GR32
[%34 -> $ecx] GR32
[%35 -> $eax] GR32
[%36 -> $rax] GR64_NOSP
[%37 -> $eax] GR32
[%38 -> $rcx] GR64_NOSP
[%40 -> $edx] GR32
[%43 -> $edx] GR32
[%44 -> $eax] GR32
[%45 -> $ecx] GR32
[%46 -> $rax] GR64_NOSP
[%48 -> $ecx] GR32
[%49 -> $eax] GR32
[%51 -> $ecx] GR32
[%52 -> $eax] GR32
[%53 -> $rax] GR64_NOSP
[%54 -> $eax] GR32
[%55 -> $rcx] GR64_NOSP
[%57 -> $edx] GR32
[%59 -> $eax] GR32
[%61 -> $eax] GR32

0B	bb.0.entry:
	  successors: %bb.1, %bb.19
	  liveins: $edi, $esi
16B	  %5:gr32 = COPY $esi
32B	  %4:gr32 = COPY $edi
48B	  MOV32mr %stack.0.l.addr, 1, $noreg, 0, $noreg, killed %4:gr32 :: (store 4 into %ir.l.addr)
64B	  MOV32mr %stack.1.r.addr, 1, $noreg, 0, $noreg, killed %5:gr32 :: (store 4 into %ir.r.addr)
80B	  %8:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
96B	  %7:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
128B	  dead %8:gr32 = SUB32rr killed %8:gr32, killed %7:gr32, implicit-def $eflags
144B	  JGE_1 %bb.19, implicit killed $eflags
160B	  JMP_1 %bb.1
> renamable $esi = COPY $esi
Identity copy: renamable $esi = COPY $esi
  deleted.
> renamable $edi = COPY $edi
Identity copy: renamable $edi = COPY $edi
  deleted.
> MOV32mr %stack.0.l.addr, 1, $noreg, 0, $noreg, killed renamable $edi :: (store 4 into %ir.l.addr)
> MOV32mr %stack.1.r.addr, 1, $noreg, 0, $noreg, killed renamable $esi :: (store 4 into %ir.r.addr)
> renamable $eax = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
> renamable $ecx = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
> dead renamable $eax = SUB32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
> JGE_1 %bb.19, implicit killed $eflags
> JMP_1 %bb.1
176B	bb.1.if.then:
	; predecessors: %bb.0
	  successors: %bb.2(0x80000000); %bb.2(200.00%)

192B	  %9:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
208B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed %9:gr32 :: (store 4 into %ir.i)
224B	  %10:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
240B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed %10:gr32 :: (store 4 into %ir.j)
256B	  %11:gr64_nosp = MOVSX64rm32 %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
272B	  %12:gr32 = MOV32rm $noreg, 4, killed %11:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx)
288B	  MOV32mr %stack.4.x, 1, $noreg, 0, $noreg, killed %12:gr32 :: (store 4 into %ir.x)
304B	  JMP_1 %bb.2
> renamable $eax = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
> MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
> renamable $eax = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
> MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.j)
> renamable $rax = MOVSX64rm32 %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
> renamable $eax = MOV32rm $noreg, 4, killed renamable $rax, @s, $noreg :: (load 4 from %ir.arrayidx)
> MOV32mr %stack.4.x, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.x)
> JMP_1 %bb.2
320B	bb.2.while.cond:
	; predecessors: %bb.1, %bb.17
	  successors: %bb.3, %bb.18

336B	  %15:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
352B	  %14:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
384B	  dead %15:gr32 = SUB32rr killed %15:gr32, killed %14:gr32, implicit-def $eflags
400B	  JGE_1 %bb.18, implicit killed $eflags
416B	  JMP_1 %bb.3
> renamable $eax = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
> renamable $ecx = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
> dead renamable $eax = SUB32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
> JGE_1 %bb.18, implicit killed $eflags
> JMP_1 %bb.3
432B	bb.3.while.body:
	; predecessors: %bb.2
	  successors: %bb.4(0x80000000); %bb.4(200.00%)

448B	  JMP_1 %bb.4
> JMP_1 %bb.4
464B	bb.4.while.cond2:
	; predecessors: %bb.3, %bb.7
	  successors: %bb.5, %bb.6

480B	  %28:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
496B	  %26:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
512B	  %27:gr32 = MOV32r0 implicit-def dead $eflags
560B	  dead %28:gr32 = SUB32rr killed %28:gr32, killed %26:gr32, implicit-def $eflags
592B	  JGE_1 %bb.6, implicit killed $eflags
608B	  JMP_1 %bb.5
> renamable $ecx = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
> renamable $edx = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
> renamable $eax = MOV32r0 implicit-def dead $eflags
> dead renamable $ecx = SUB32rr killed renamable $ecx, killed renamable $edx, implicit-def $eflags
> JGE_1 %bb.6, implicit killed $eflags
> JMP_1 %bb.5
624B	bb.5.land.rhs:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(200.00%)

640B	  %29:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
656B	  %32:gr32 = MOV32rm $noreg, 4, killed %29:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx5)
672B	  %31:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
704B	  dead %32:gr32 = SUB32rr killed %32:gr32, killed %31:gr32, implicit-def $eflags
720B	  undef %27.sub_8bit:gr32 = SETGEr implicit killed $eflags
752B	  JMP_1 %bb.6
> renamable $rax = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
> renamable $eax = MOV32rm $noreg, 4, killed renamable $rax, @s, $noreg :: (load 4 from %ir.arrayidx5)
> renamable $ecx = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
> dead renamable $eax = SUB32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
> renamable $al = SETGEr implicit killed $eflags, implicit-def $eax
> JMP_1 %bb.6
768B	bb.6.land.end:
	; predecessors: %bb.4, %bb.5
	  successors: %bb.7, %bb.8
	  liveins: $eax
800B	  TEST8ri killed %27.sub_8bit:gr32, 1, implicit-def $eflags
816B	  JE_1 %bb.8, implicit killed $eflags
832B	  JMP_1 %bb.7
> TEST8ri renamable $al, 1, implicit-def $eflags, implicit killed $eax
> JE_1 %bb.8, implicit killed $eflags
> JMP_1 %bb.7
848B	bb.7.while.body7:
	; predecessors: %bb.6
	  successors: %bb.4(0x80000000); %bb.4(200.00%)

864B	  %61:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
896B	  %61:gr32 = ADD32ri8 killed %61:gr32, -1, implicit-def dead $eflags
912B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed %61:gr32 :: (store 4 into %ir.j)
928B	  JMP_1 %bb.4
> renamable $eax = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
> renamable $eax = ADD32ri8 killed renamable $eax, -1, implicit-def dead $eflags
> MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.j)
> JMP_1 %bb.4
944B	bb.8.while.end:
	; predecessors: %bb.6
	  successors: %bb.9, %bb.10

960B	  %35:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
976B	  %34:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1008B	  dead %35:gr32 = SUB32rr killed %35:gr32, killed %34:gr32, implicit-def $eflags
1024B	  JGE_1 %bb.10, implicit killed $eflags
1040B	  JMP_1 %bb.9
> renamable $eax = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
> renamable $ecx = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
> dead renamable $eax = SUB32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
> JGE_1 %bb.10, implicit killed $eflags
> JMP_1 %bb.9
1056B	bb.9.if.then9:
	; predecessors: %bb.8
	  successors: %bb.10(0x80000000); %bb.10(200.00%)

1072B	  %36:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1088B	  %37:gr32 = MOV32rm $noreg, 4, killed %36:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx11)
1104B	  %38:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1136B	  %40:gr32 = COPY %38.sub_32bit:gr64_nosp
1152B	  %40:gr32 = ADD32ri8 killed %40:gr32, 1, implicit-def dead $eflags
1168B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed %40:gr32 :: (store 4 into %ir.i)
1184B	  MOV32mr $noreg, 4, killed %38:gr64_nosp, @s, $noreg, killed %37:gr32 :: (store 4 into %ir.arrayidx13)
1200B	  JMP_1 %bb.10
> renamable $rax = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
> renamable $eax = MOV32rm $noreg, 4, killed renamable $rax, @s, $noreg :: (load 4 from %ir.arrayidx11)
> renamable $rcx = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
> renamable $edx = COPY renamable $ecx
> renamable $edx = ADD32ri8 killed renamable $edx, 1, implicit-def dead $eflags
> MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed renamable $edx :: (store 4 into %ir.i)
> MOV32mr $noreg, 4, killed renamable $rcx, @s, $noreg, killed renamable $eax :: (store 4 into %ir.arrayidx13)
> JMP_1 %bb.10
1216B	bb.10.if.end:
	; predecessors: %bb.8, %bb.9
	  successors: %bb.11(0x80000000); %bb.11(200.00%)

1232B	  JMP_1 %bb.11
> JMP_1 %bb.11
1248B	bb.11.while.cond14:
	; predecessors: %bb.10, %bb.14
	  successors: %bb.12, %bb.13

1264B	  %45:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1280B	  %43:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1296B	  %44:gr32 = MOV32r0 implicit-def dead $eflags
1344B	  dead %45:gr32 = SUB32rr killed %45:gr32, killed %43:gr32, implicit-def $eflags
1376B	  JGE_1 %bb.13, implicit killed $eflags
1392B	  JMP_1 %bb.12
> renamable $ecx = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
> renamable $edx = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
> renamable $eax = MOV32r0 implicit-def dead $eflags
> dead renamable $ecx = SUB32rr killed renamable $ecx, killed renamable $edx, implicit-def $eflags
> JGE_1 %bb.13, implicit killed $eflags
> JMP_1 %bb.12
1408B	bb.12.land.rhs16:
	; predecessors: %bb.11
	  successors: %bb.13(0x80000000); %bb.13(200.00%)

1424B	  %46:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1440B	  %49:gr32 = MOV32rm $noreg, 4, killed %46:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx18)
1456B	  %48:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
1488B	  dead %49:gr32 = SUB32rr killed %49:gr32, killed %48:gr32, implicit-def $eflags
1504B	  undef %44.sub_8bit:gr32 = SETLr implicit killed $eflags
1536B	  JMP_1 %bb.13
> renamable $rax = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
> renamable $eax = MOV32rm $noreg, 4, killed renamable $rax, @s, $noreg :: (load 4 from %ir.arrayidx18)
> renamable $ecx = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
> dead renamable $eax = SUB32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
> renamable $al = SETLr implicit killed $eflags, implicit-def $eax
> JMP_1 %bb.13
1552B	bb.13.land.end20:
	; predecessors: %bb.11, %bb.12
	  successors: %bb.14, %bb.15
	  liveins: $eax
1584B	  TEST8ri killed %44.sub_8bit:gr32, 1, implicit-def $eflags
1600B	  JE_1 %bb.15, implicit killed $eflags
1616B	  JMP_1 %bb.14
> TEST8ri renamable $al, 1, implicit-def $eflags, implicit killed $eax
> JE_1 %bb.15, implicit killed $eflags
> JMP_1 %bb.14
1632B	bb.14.while.body21:
	; predecessors: %bb.13
	  successors: %bb.11(0x80000000); %bb.11(200.00%)

1648B	  %59:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1680B	  %59:gr32 = ADD32ri8 killed %59:gr32, 1, implicit-def dead $eflags
1696B	  MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed %59:gr32 :: (store 4 into %ir.i)
1712B	  JMP_1 %bb.11
> renamable $eax = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
> renamable $eax = ADD32ri8 killed renamable $eax, 1, implicit-def dead $eflags
> MOV32mr %stack.2.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
> JMP_1 %bb.11
1728B	bb.15.while.end23:
	; predecessors: %bb.13
	  successors: %bb.16, %bb.17

1744B	  %52:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1760B	  %51:gr32 = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1792B	  dead %52:gr32 = SUB32rr killed %52:gr32, killed %51:gr32, implicit-def $eflags
1808B	  JGE_1 %bb.17, implicit killed $eflags
1824B	  JMP_1 %bb.16
> renamable $eax = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
> renamable $ecx = MOV32rm %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
> dead renamable $eax = SUB32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
> JGE_1 %bb.17, implicit killed $eflags
> JMP_1 %bb.16
1840B	bb.16.if.then25:
	; predecessors: %bb.15
	  successors: %bb.17(0x80000000); %bb.17(200.00%)

1856B	  %53:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1872B	  %54:gr32 = MOV32rm $noreg, 4, killed %53:gr64_nosp, @s, $noreg :: (load 4 from %ir.arrayidx27)
1888B	  %55:gr64_nosp = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
1920B	  %57:gr32 = COPY %55.sub_32bit:gr64_nosp
1936B	  %57:gr32 = ADD32ri8 killed %57:gr32, -1, implicit-def dead $eflags
1952B	  MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed %57:gr32 :: (store 4 into %ir.j)
1968B	  MOV32mr $noreg, 4, killed %55:gr64_nosp, @s, $noreg, killed %54:gr32 :: (store 4 into %ir.arrayidx30)
1984B	  JMP_1 %bb.17
> renamable $rax = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
> renamable $eax = MOV32rm $noreg, 4, killed renamable $rax, @s, $noreg :: (load 4 from %ir.arrayidx27)
> renamable $rcx = MOVSX64rm32 %stack.3.j, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.j)
> renamable $edx = COPY renamable $ecx
> renamable $edx = ADD32ri8 killed renamable $edx, -1, implicit-def dead $eflags
> MOV32mr %stack.3.j, 1, $noreg, 0, $noreg, killed renamable $edx :: (store 4 into %ir.j)
> MOV32mr $noreg, 4, killed renamable $rcx, @s, $noreg, killed renamable $eax :: (store 4 into %ir.arrayidx30)
> JMP_1 %bb.17
2000B	bb.17.if.end31:
	; predecessors: %bb.15, %bb.16
	  successors: %bb.2(0x80000000); %bb.2(200.00%)

2016B	  JMP_1 %bb.2
> JMP_1 %bb.2
2032B	bb.18.while.end32:
	; predecessors: %bb.2
	  successors: %bb.19(0x80000000); %bb.19(200.00%)

2048B	  %16:gr32 = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
2064B	  %17:gr64_nosp = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2080B	  MOV32mr $noreg, 4, killed %17:gr64_nosp, @s, $noreg, killed %16:gr32 :: (store 4 into %ir.arrayidx34)
2096B	  %18:gr32 = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
2112B	  %20:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2144B	  %20:gr32 = ADD32ri8 killed %20:gr32, -1, implicit-def dead $eflags
2160B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2176B	  $edi = COPY killed %18:gr32
2192B	  $esi = COPY killed %20:gr32
2208B	  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
2224B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2240B	  %22:gr32 = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
2272B	  %22:gr32 = ADD32ri8 killed %22:gr32, 1, implicit-def dead $eflags
2288B	  %23:gr32 = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
2304B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2320B	  $edi = COPY killed %22:gr32
2336B	  $esi = COPY killed %23:gr32
2352B	  CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
2368B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
2384B	  JMP_1 %bb.19
> renamable $eax = MOV32rm %stack.4.x, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.x)
> renamable $rcx = MOVSX64rm32 %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
> MOV32mr $noreg, 4, killed renamable $rcx, @s, $noreg, killed renamable $eax :: (store 4 into %ir.arrayidx34)
> renamable $edi = MOV32rm %stack.0.l.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.l.addr)
> renamable $esi = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
> renamable $esi = ADD32ri8 killed renamable $esi, -1, implicit-def dead $eflags
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $edi = COPY killed renamable $edi
Identity copy: $edi = COPY killed renamable $edi
  deleted.
> $esi = COPY killed renamable $esi
Identity copy: $esi = COPY killed renamable $esi
  deleted.
> CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> renamable $edi = MOV32rm %stack.2.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
> renamable $edi = ADD32ri8 killed renamable $edi, 1, implicit-def dead $eflags
> renamable $esi = MOV32rm %stack.1.r.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.r.addr)
> ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> $edi = COPY killed renamable $edi
Identity copy: $edi = COPY killed renamable $edi
  deleted.
> $esi = COPY killed renamable $esi
Identity copy: $esi = COPY killed renamable $esi
  deleted.
> CALL64pcrel32 @quick_sort, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $edi, implicit $esi, implicit-def $rsp, implicit-def $ssp
> ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
> JMP_1 %bb.19
2400B	bb.19.if.end35:
	; predecessors: %bb.0, %bb.18

2416B	  RET 0
> RET 0
********** Stack Slot Coloring **********
********** Function: quick_sort
Skipping pass 'Stack Slot Coloring' on function quick_sort
Skipping pass 'Machine Copy Propagation Pass' on function quick_sort
Skipping pass 'Machine Loop Invariant Code Motion' on function quick_sort

block-frequency: quick_sort
===========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[if.then]
 - 2: BB2[while.cond]
 - 3: BB18[while.end32]
 - 4: BB19[if.end35]
 - 5: BB3[while.body]
 - 6: BB4[while.cond2]
 - 7: BB5[land.rhs]
 - 8: BB6[land.end]
 - 9: BB8[while.end]
 - 10: BB9[if.then9]
 - 11: BB10[if.end]
 - 12: BB11[while.cond14]
 - 13: BB12[land.rhs16]
 - 14: BB13[land.end20]
 - 15: BB15[while.end23]
 - 16: BB16[if.then25]
 - 17: BB17[if.end31]
 - 18: BB14[while.body21]
 - 19: BB7[while.body7]
loop-detection
 - loop = BB2[while.cond]
 - loop = BB4[while.cond2]
 - loop = BB11[while.cond14]
 - loop = BB2[while.cond]: member = BB3[while.body]
 - loop = BB4[while.cond2]: member = BB5[land.rhs]
 - loop = BB4[while.cond2]: member = BB6[land.end]
 - loop = BB2[while.cond]: member = BB8[while.end]
 - loop = BB2[while.cond]: member = BB9[if.then9]
 - loop = BB2[while.cond]: member = BB10[if.end]
 - loop = BB11[while.cond14]: member = BB12[land.rhs16]
 - loop = BB11[while.cond14]: member = BB13[land.end20]
 - loop = BB2[while.cond]: member = BB15[while.end23]
 - loop = BB2[while.cond]: member = BB16[if.then25]
 - loop = BB2[while.cond]: member = BB17[if.end31]
 - loop = BB11[while.cond14]: member = BB14[while.body21]
 - loop = BB4[while.cond2]: member = BB7[while.body7]
compute-mass-in-loop: BB11[while.cond14]*
 - node: BB11[while.cond14]
  => [ local  ] weight = 1073741824, succ = BB12[land.rhs16]
  => [ local  ] weight = 1073741824, succ = BB13[land.end20]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB12[land.rhs16]
  => assign 8000000000000000 (0000000000000000) to BB13[land.end20]
 - node: BB12[land.rhs16]
  => [ local  ] weight = 2147483648, succ = BB13[land.end20]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB13[land.end20]
 - node: BB13[land.end20]
  => [ local  ] weight = 1073741824, succ = BB14[while.body21]
  => [  exit  ] weight = 1073741824, succ = BB15[while.end23]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) [exit] to BB15[while.end23]
  => assign 8000000000000000 (0000000000000000) to BB14[while.body21]
 - node: BB14[while.body21]
  => [backedge] weight = 2147483648
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) [back] to BB11[while.cond14]
compute-loop-scale: BB11[while.cond14]*
 - exit-mass = 7fffffffffffffff (ffffffffffffffff - 8000000000000000)
 - scale = 2.0
packaging-loop: BB11[while.cond14]*
 - node: BB11[while.cond14]
 - node: BB12[land.rhs16]
 - node: BB13[land.end20]
 - node: BB14[while.body21]
compute-mass-in-loop: BB4[while.cond2]*
 - node: BB4[while.cond2]
  => [ local  ] weight = 1073741824, succ = BB5[land.rhs]
  => [ local  ] weight = 1073741824, succ = BB6[land.end]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB5[land.rhs]
  => assign 8000000000000000 (0000000000000000) to BB6[land.end]
 - node: BB5[land.rhs]
  => [ local  ] weight = 2147483648, succ = BB6[land.end]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB6[land.end]
 - node: BB6[land.end]
  => [ local  ] weight = 1073741824, succ = BB7[while.body7]
  => [  exit  ] weight = 1073741824, succ = BB8[while.end]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) [exit] to BB8[while.end]
  => assign 8000000000000000 (0000000000000000) to BB7[while.body7]
 - node: BB7[while.body7]
  => [backedge] weight = 2147483648
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) [back] to BB4[while.cond2]
compute-loop-scale: BB4[while.cond2]*
 - exit-mass = 7fffffffffffffff (ffffffffffffffff - 8000000000000000)
 - scale = 2.0
packaging-loop: BB4[while.cond2]*
 - node: BB4[while.cond2]
 - node: BB5[land.rhs]
 - node: BB6[land.end]
 - node: BB7[while.body7]
compute-mass-in-loop: BB2[while.cond]*
 - node: BB2[while.cond]
  => [ local  ] weight = 1073741824, succ = BB3[while.body]
  => [  exit  ] weight = 1073741824, succ = BB18[while.end32]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) [exit] to BB18[while.end32]
  => assign 8000000000000000 (0000000000000000) to BB3[while.body]
 - node: BB3[while.body]
  => [ local  ] weight = 2147483648, succ = BB4[while.cond2]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB4[while.cond2]
 - node: BB4[while.cond2]
  => [ local  ] weight = 9223372036854775807, succ = BB8[while.end]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB8[while.end]
 - node: BB8[while.end]
  => [ local  ] weight = 1073741824, succ = BB9[if.then9]
  => [ local  ] weight = 1073741824, succ = BB10[if.end]
  => mass:  8000000000000000
  => assign 4000000000000000 (4000000000000000) to BB9[if.then9]
  => assign 4000000000000000 (0000000000000000) to BB10[if.end]
 - node: BB9[if.then9]
  => [ local  ] weight = 2147483648, succ = BB10[if.end]
  => mass:  4000000000000000
  => assign 4000000000000000 (0000000000000000) to BB10[if.end]
 - node: BB10[if.end]
  => [ local  ] weight = 2147483648, succ = BB11[while.cond14]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB11[while.cond14]
 - node: BB11[while.cond14]
  => [ local  ] weight = 9223372036854775807, succ = BB15[while.end23]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB15[while.end23]
 - node: BB15[while.end23]
  => [ local  ] weight = 1073741824, succ = BB16[if.then25]
  => [ local  ] weight = 1073741824, succ = BB17[if.end31]
  => mass:  8000000000000000
  => assign 4000000000000000 (4000000000000000) to BB16[if.then25]
  => assign 4000000000000000 (0000000000000000) to BB17[if.end31]
 - node: BB16[if.then25]
  => [ local  ] weight = 2147483648, succ = BB17[if.end31]
  => mass:  4000000000000000
  => assign 4000000000000000 (0000000000000000) to BB17[if.end31]
 - node: BB17[if.end31]
  => [backedge] weight = 2147483648
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) [back] to BB2[while.cond]
compute-loop-scale: BB2[while.cond]*
 - exit-mass = 7fffffffffffffff (ffffffffffffffff - 8000000000000000)
 - scale = 2.0
packaging-loop: BB2[while.cond]*
 - node: BB2[while.cond]
 - node: BB3[while.body]
 - node: BB4[while.cond2]
 - node: BB8[while.end]
 - node: BB9[if.then9]
 - node: BB10[if.end]
 - node: BB11[while.cond14]
 - node: BB15[while.end23]
 - node: BB16[if.then25]
 - node: BB17[if.end31]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB1[if.then]
  => [ local  ] weight = 1073741824, succ = BB19[if.end35]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB1[if.then]
  => assign 8000000000000000 (0000000000000000) to BB19[if.end35]
 - node: BB1[if.then]
  => [ local  ] weight = 2147483648, succ = BB2[while.cond]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB2[while.cond]
 - node: BB2[while.cond]
  => [ local  ] weight = 9223372036854775807, succ = BB18[while.end32]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB18[while.end32]
 - node: BB18[while.end32]
  => [ local  ] weight = 2147483648, succ = BB19[if.end35]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB19[if.end35]
 - node: BB19[if.end35]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB2[while.cond]*: mass = 7fffffffffffffff, scale = 2.0
  => combined-scale = 1.0
 - BB2[while.cond]: 1.0 => 1.0
 - BB3[while.body]: 0.5 => 0.5
 - BB4[while.cond2]: 2.0 => 2.0
 - BB8[while.end]: 0.5 => 0.5
 - BB9[if.then9]: 0.25 => 0.25
 - BB10[if.end]: 0.5 => 0.5
 - BB11[while.cond14]: 2.0 => 2.0
 - BB15[while.end23]: 0.5 => 0.5
 - BB16[if.then25]: 0.25 => 0.25
 - BB17[if.end31]: 0.5 => 0.5
unwrap-loop-package: BB4[while.cond2]*: mass = 8000000000000000, scale = 2.0
  => combined-scale = 1.0
 - BB4[while.cond2]: 1.0 => 1.0
 - BB5[land.rhs]: 0.5 => 0.5
 - BB6[land.end]: 1.0 => 1.0
 - BB7[while.body7]: 0.5 => 0.5
unwrap-loop-package: BB11[while.cond14]*: mass = 8000000000000000, scale = 2.0
  => combined-scale = 1.0
 - BB11[while.cond14]: 1.0 => 1.0
 - BB12[land.rhs16]: 0.5 => 0.5
 - BB13[land.end20]: 1.0 => 1.0
 - BB14[while.body21]: 0.5 => 0.5
float-to-int: min = 0.25, max = 1.0, factor = 32.0
 - BB0[entry]: float = 1.0, scaled = 32.0, int = 31
 - BB1[if.then]: float = 0.5, scaled = 16.0, int = 15
 - BB2[while.cond]: float = 1.0, scaled = 32.0, int = 31
 - BB18[while.end32]: float = 0.5, scaled = 16.0, int = 15
 - BB19[if.end35]: float = 1.0, scaled = 32.0, int = 31
 - BB3[while.body]: float = 0.5, scaled = 16.0, int = 15
 - BB4[while.cond2]: float = 1.0, scaled = 32.0, int = 31
 - BB5[land.rhs]: float = 0.5, scaled = 16.0, int = 15
 - BB6[land.end]: float = 1.0, scaled = 32.0, int = 31
 - BB8[while.end]: float = 0.5, scaled = 16.0, int = 15
 - BB9[if.then9]: float = 0.25, scaled = 8.0, int = 8
 - BB10[if.end]: float = 0.5, scaled = 16.0, int = 15
 - BB11[while.cond14]: float = 1.0, scaled = 32.0, int = 31
 - BB12[land.rhs16]: float = 0.5, scaled = 16.0, int = 15
 - BB13[land.end20]: float = 1.0, scaled = 32.0, int = 31
 - BB15[while.end23]: float = 0.5, scaled = 16.0, int = 15
 - BB16[if.then25]: float = 0.25, scaled = 8.0, int = 8
 - BB17[if.end31]: float = 0.5, scaled = 16.0, int = 15
 - BB14[while.body21]: float = 0.5, scaled = 16.0, int = 16
 - BB7[while.body7]: float = 0.5, scaled = 16.0, int = 16
block-frequency-info: quick_sort
 - BB0[entry]: float = 1.0, int = 31
 - BB1[if.then]: float = 0.5, int = 15
 - BB2[while.cond]: float = 1.0, int = 31
 - BB3[while.body]: float = 0.5, int = 15
 - BB4[while.cond2]: float = 1.0, int = 31
 - BB5[land.rhs]: float = 0.5, int = 15
 - BB6[land.end]: float = 1.0, int = 31
 - BB7[while.body7]: float = 0.5, int = 16
 - BB8[while.end]: float = 0.5, int = 15
 - BB9[if.then9]: float = 0.25, int = 8
 - BB10[if.end]: float = 0.5, int = 15
 - BB11[while.cond14]: float = 1.0, int = 31
 - BB12[land.rhs16]: float = 0.5, int = 15
 - BB13[land.end20]: float = 1.0, int = 31
 - BB14[while.body21]: float = 0.5, int = 16
 - BB15[while.end23]: float = 0.5, int = 15
 - BB16[if.then25]: float = 0.25, int = 8
 - BB17[if.end31]: float = 0.5, int = 15
 - BB18[while.end32]: float = 0.5, int = 15
 - BB19[if.end35]: float = 1.0, int = 31

		Looking for trivial roots
Found a new trivial root: %bb.19
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 20, Num: 21
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.19
3: %bb.18
4: %bb.2
5: %bb.17
6: %bb.16
7: %bb.15
8: %bb.13
9: %bb.12
10: %bb.11
11: %bb.14
12: %bb.10
13: %bb.9
14: %bb.8
15: %bb.6
16: %bb.5
17: %bb.4
18: %bb.7
19: %bb.3
20: %bb.1
21: %bb.0
Found roots: %bb.19 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.19
	discovered a new reachable node %bb.18
	discovered a new reachable node %bb.2
	discovered a new reachable node %bb.17
	discovered a new reachable node %bb.16
	discovered a new reachable node %bb.15
	discovered a new reachable node %bb.13
	discovered a new reachable node %bb.12
	discovered a new reachable node %bb.11
	discovered a new reachable node %bb.14
	discovered a new reachable node %bb.10
	discovered a new reachable node %bb.9
	discovered a new reachable node %bb.8
	discovered a new reachable node %bb.6
	discovered a new reachable node %bb.5
	discovered a new reachable node %bb.4
	discovered a new reachable node %bb.7
	discovered a new reachable node %bb.3
	discovered a new reachable node %bb.1
	discovered a new reachable node %bb.0
Skipping pass 'Shrink Wrapping analysis' on function quick_sort
alloc FI(2) at SP[-20]
alloc FI(3) at SP[-24]
alloc FI(0) at SP[-28]
alloc FI(4) at SP[-32]
alloc FI(1) at SP[-36]
Skipping pass 'Control Flow Optimizer' on function quick_sort
Skipping pass 'Tail Duplication' on function quick_sort
Skipping pass 'Machine Copy Propagation Pass' on function quick_sort
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: quick_sort
real copy:   renamable $edx = COPY renamable $ecx
replaced by: $edx = MOV32rr $ecx
real copy:   renamable $edx = COPY renamable $ecx
replaced by: $edx = MOV32rr $ecx
	discovered a new reachable node %bb.0
	discovered a new reachable node %bb.1
	discovered a new reachable node %bb.2
	discovered a new reachable node %bb.3
	discovered a new reachable node %bb.4
	discovered a new reachable node %bb.5
	discovered a new reachable node %bb.6
	discovered a new reachable node %bb.7
	discovered a new reachable node %bb.8
	discovered a new reachable node %bb.9
	discovered a new reachable node %bb.10
	discovered a new reachable node %bb.11
	discovered a new reachable node %bb.12
	discovered a new reachable node %bb.13
	discovered a new reachable node %bb.14
	discovered a new reachable node %bb.15
	discovered a new reachable node %bb.16
	discovered a new reachable node %bb.17
	discovered a new reachable node %bb.18
	discovered a new reachable node %bb.19
Skipping pass 'Post RA top-down list latency scheduler' on function quick_sort

block-frequency: quick_sort
===========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[if.then]
 - 2: BB2[while.cond]
 - 3: BB18[while.end32]
 - 4: BB19[if.end35]
 - 5: BB3[while.body]
 - 6: BB4[while.cond2]
 - 7: BB5[land.rhs]
 - 8: BB6[land.end]
 - 9: BB8[while.end]
 - 10: BB9[if.then9]
 - 11: BB10[if.end]
 - 12: BB11[while.cond14]
 - 13: BB12[land.rhs16]
 - 14: BB13[land.end20]
 - 15: BB15[while.end23]
 - 16: BB16[if.then25]
 - 17: BB17[if.end31]
 - 18: BB14[while.body21]
 - 19: BB7[while.body7]
loop-detection
 - loop = BB2[while.cond]
 - loop = BB4[while.cond2]
 - loop = BB11[while.cond14]
 - loop = BB2[while.cond]: member = BB3[while.body]
 - loop = BB4[while.cond2]: member = BB5[land.rhs]
 - loop = BB4[while.cond2]: member = BB6[land.end]
 - loop = BB2[while.cond]: member = BB8[while.end]
 - loop = BB2[while.cond]: member = BB9[if.then9]
 - loop = BB2[while.cond]: member = BB10[if.end]
 - loop = BB11[while.cond14]: member = BB12[land.rhs16]
 - loop = BB11[while.cond14]: member = BB13[land.end20]
 - loop = BB2[while.cond]: member = BB15[while.end23]
 - loop = BB2[while.cond]: member = BB16[if.then25]
 - loop = BB2[while.cond]: member = BB17[if.end31]
 - loop = BB11[while.cond14]: member = BB14[while.body21]
 - loop = BB4[while.cond2]: member = BB7[while.body7]
compute-mass-in-loop: BB11[while.cond14]*
 - node: BB11[while.cond14]
  => [ local  ] weight = 1073741824, succ = BB12[land.rhs16]
  => [ local  ] weight = 1073741824, succ = BB13[land.end20]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB12[land.rhs16]
  => assign 8000000000000000 (0000000000000000) to BB13[land.end20]
 - node: BB12[land.rhs16]
  => [ local  ] weight = 2147483648, succ = BB13[land.end20]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB13[land.end20]
 - node: BB13[land.end20]
  => [ local  ] weight = 1073741824, succ = BB14[while.body21]
  => [  exit  ] weight = 1073741824, succ = BB15[while.end23]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) [exit] to BB15[while.end23]
  => assign 8000000000000000 (0000000000000000) to BB14[while.body21]
 - node: BB14[while.body21]
  => [backedge] weight = 2147483648
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) [back] to BB11[while.cond14]
compute-loop-scale: BB11[while.cond14]*
 - exit-mass = 7fffffffffffffff (ffffffffffffffff - 8000000000000000)
 - scale = 2.0
packaging-loop: BB11[while.cond14]*
 - node: BB11[while.cond14]
 - node: BB12[land.rhs16]
 - node: BB13[land.end20]
 - node: BB14[while.body21]
compute-mass-in-loop: BB4[while.cond2]*
 - node: BB4[while.cond2]
  => [ local  ] weight = 1073741824, succ = BB5[land.rhs]
  => [ local  ] weight = 1073741824, succ = BB6[land.end]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB5[land.rhs]
  => assign 8000000000000000 (0000000000000000) to BB6[land.end]
 - node: BB5[land.rhs]
  => [ local  ] weight = 2147483648, succ = BB6[land.end]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB6[land.end]
 - node: BB6[land.end]
  => [ local  ] weight = 1073741824, succ = BB7[while.body7]
  => [  exit  ] weight = 1073741824, succ = BB8[while.end]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) [exit] to BB8[while.end]
  => assign 8000000000000000 (0000000000000000) to BB7[while.body7]
 - node: BB7[while.body7]
  => [backedge] weight = 2147483648
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) [back] to BB4[while.cond2]
compute-loop-scale: BB4[while.cond2]*
 - exit-mass = 7fffffffffffffff (ffffffffffffffff - 8000000000000000)
 - scale = 2.0
packaging-loop: BB4[while.cond2]*
 - node: BB4[while.cond2]
 - node: BB5[land.rhs]
 - node: BB6[land.end]
 - node: BB7[while.body7]
compute-mass-in-loop: BB2[while.cond]*
 - node: BB2[while.cond]
  => [ local  ] weight = 1073741824, succ = BB3[while.body]
  => [  exit  ] weight = 1073741824, succ = BB18[while.end32]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) [exit] to BB18[while.end32]
  => assign 8000000000000000 (0000000000000000) to BB3[while.body]
 - node: BB3[while.body]
  => [ local  ] weight = 2147483648, succ = BB4[while.cond2]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB4[while.cond2]
 - node: BB4[while.cond2]
  => [ local  ] weight = 9223372036854775807, succ = BB8[while.end]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB8[while.end]
 - node: BB8[while.end]
  => [ local  ] weight = 1073741824, succ = BB9[if.then9]
  => [ local  ] weight = 1073741824, succ = BB10[if.end]
  => mass:  8000000000000000
  => assign 4000000000000000 (4000000000000000) to BB9[if.then9]
  => assign 4000000000000000 (0000000000000000) to BB10[if.end]
 - node: BB9[if.then9]
  => [ local  ] weight = 2147483648, succ = BB10[if.end]
  => mass:  4000000000000000
  => assign 4000000000000000 (0000000000000000) to BB10[if.end]
 - node: BB10[if.end]
  => [ local  ] weight = 2147483648, succ = BB11[while.cond14]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB11[while.cond14]
 - node: BB11[while.cond14]
  => [ local  ] weight = 9223372036854775807, succ = BB15[while.end23]
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) to BB15[while.end23]
 - node: BB15[while.end23]
  => [ local  ] weight = 1073741824, succ = BB16[if.then25]
  => [ local  ] weight = 1073741824, succ = BB17[if.end31]
  => mass:  8000000000000000
  => assign 4000000000000000 (4000000000000000) to BB16[if.then25]
  => assign 4000000000000000 (0000000000000000) to BB17[if.end31]
 - node: BB16[if.then25]
  => [ local  ] weight = 2147483648, succ = BB17[if.end31]
  => mass:  4000000000000000
  => assign 4000000000000000 (0000000000000000) to BB17[if.end31]
 - node: BB17[if.end31]
  => [backedge] weight = 2147483648
  => mass:  8000000000000000
  => assign 8000000000000000 (0000000000000000) [back] to BB2[while.cond]
compute-loop-scale: BB2[while.cond]*
 - exit-mass = 7fffffffffffffff (ffffffffffffffff - 8000000000000000)
 - scale = 2.0
packaging-loop: BB2[while.cond]*
 - node: BB2[while.cond]
 - node: BB3[while.body]
 - node: BB4[while.cond2]
 - node: BB8[while.end]
 - node: BB9[if.then9]
 - node: BB10[if.end]
 - node: BB11[while.cond14]
 - node: BB15[while.end23]
 - node: BB16[if.then25]
 - node: BB17[if.end31]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1073741824, succ = BB1[if.then]
  => [ local  ] weight = 1073741824, succ = BB19[if.end35]
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to BB1[if.then]
  => assign 8000000000000000 (0000000000000000) to BB19[if.end35]
 - node: BB1[if.then]
  => [ local  ] weight = 2147483648, succ = BB2[while.cond]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB2[while.cond]
 - node: BB2[while.cond]
  => [ local  ] weight = 9223372036854775807, succ = BB18[while.end32]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB18[while.end32]
 - node: BB18[while.end32]
  => [ local  ] weight = 2147483648, succ = BB19[if.end35]
  => mass:  7fffffffffffffff
  => assign 7fffffffffffffff (0000000000000000) to BB19[if.end35]
 - node: BB19[if.end35]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB2[while.cond]*: mass = 7fffffffffffffff, scale = 2.0
  => combined-scale = 1.0
 - BB2[while.cond]: 1.0 => 1.0
 - BB3[while.body]: 0.5 => 0.5
 - BB4[while.cond2]: 2.0 => 2.0
 - BB8[while.end]: 0.5 => 0.5
 - BB9[if.then9]: 0.25 => 0.25
 - BB10[if.end]: 0.5 => 0.5
 - BB11[while.cond14]: 2.0 => 2.0
 - BB15[while.end23]: 0.5 => 0.5
 - BB16[if.then25]: 0.25 => 0.25
 - BB17[if.end31]: 0.5 => 0.5
unwrap-loop-package: BB4[while.cond2]*: mass = 8000000000000000, scale = 2.0
  => combined-scale = 1.0
 - BB4[while.cond2]: 1.0 => 1.0
 - BB5[land.rhs]: 0.5 => 0.5
 - BB6[land.end]: 1.0 => 1.0
 - BB7[while.body7]: 0.5 => 0.5
unwrap-loop-package: BB11[while.cond14]*: mass = 8000000000000000, scale = 2.0
  => combined-scale = 1.0
 - BB11[while.cond14]: 1.0 => 1.0
 - BB12[land.rhs16]: 0.5 => 0.5
 - BB13[land.end20]: 1.0 => 1.0
 - BB14[while.body21]: 0.5 => 0.5
float-to-int: min = 0.25, max = 1.0, factor = 32.0
 - BB0[entry]: float = 1.0, scaled = 32.0, int = 31
 - BB1[if.then]: float = 0.5, scaled = 16.0, int = 15
 - BB2[while.cond]: float = 1.0, scaled = 32.0, int = 31
 - BB18[while.end32]: float = 0.5, scaled = 16.0, int = 15
 - BB19[if.end35]: float = 1.0, scaled = 32.0, int = 31
 - BB3[while.body]: float = 0.5, scaled = 16.0, int = 15
 - BB4[while.cond2]: float = 1.0, scaled = 32.0, int = 31
 - BB5[land.rhs]: float = 0.5, scaled = 16.0, int = 15
 - BB6[land.end]: float = 1.0, scaled = 32.0, int = 31
 - BB8[while.end]: float = 0.5, scaled = 16.0, int = 15
 - BB9[if.then9]: float = 0.25, scaled = 8.0, int = 8
 - BB10[if.end]: float = 0.5, scaled = 16.0, int = 15
 - BB11[while.cond14]: float = 1.0, scaled = 32.0, int = 31
 - BB12[land.rhs16]: float = 0.5, scaled = 16.0, int = 15
 - BB13[land.end20]: float = 1.0, scaled = 32.0, int = 31
 - BB15[while.end23]: float = 0.5, scaled = 16.0, int = 15
 - BB16[if.then25]: float = 0.25, scaled = 8.0, int = 8
 - BB17[if.end31]: float = 0.5, scaled = 16.0, int = 15
 - BB14[while.body21]: float = 0.5, scaled = 16.0, int = 16
 - BB7[while.body7]: float = 0.5, scaled = 16.0, int = 16
block-frequency-info: quick_sort
 - BB0[entry]: float = 1.0, int = 31
 - BB1[if.then]: float = 0.5, int = 15
 - BB2[while.cond]: float = 1.0, int = 31
 - BB3[while.body]: float = 0.5, int = 15
 - BB4[while.cond2]: float = 1.0, int = 31
 - BB5[land.rhs]: float = 0.5, int = 15
 - BB6[land.end]: float = 1.0, int = 31
 - BB7[while.body7]: float = 0.5, int = 16
 - BB8[while.end]: float = 0.5, int = 15
 - BB9[if.then9]: float = 0.25, int = 8
 - BB10[if.end]: float = 0.5, int = 15
 - BB11[while.cond14]: float = 1.0, int = 31
 - BB12[land.rhs16]: float = 0.5, int = 15
 - BB13[land.end20]: float = 1.0, int = 31
 - BB14[while.body21]: float = 0.5, int = 16
 - BB15[while.end23]: float = 0.5, int = 15
 - BB16[if.then25]: float = 0.25, int = 8
 - BB17[if.end31]: float = 0.5, int = 15
 - BB18[while.end32]: float = 0.5, int = 15
 - BB19[if.end35]: float = 1.0, int = 31

		Looking for trivial roots
Found a new trivial root: %bb.19
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 20, Num: 21
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.19
3: %bb.18
4: %bb.2
5: %bb.17
6: %bb.16
7: %bb.15
8: %bb.13
9: %bb.12
10: %bb.11
11: %bb.14
12: %bb.10
13: %bb.9
14: %bb.8
15: %bb.6
16: %bb.5
17: %bb.4
18: %bb.7
19: %bb.3
20: %bb.1
21: %bb.0
Found roots: %bb.19 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.19
	discovered a new reachable node %bb.18
	discovered a new reachable node %bb.2
	discovered a new reachable node %bb.17
	discovered a new reachable node %bb.16
	discovered a new reachable node %bb.15
	discovered a new reachable node %bb.13
	discovered a new reachable node %bb.12
	discovered a new reachable node %bb.11
	discovered a new reachable node %bb.14
	discovered a new reachable node %bb.10
	discovered a new reachable node %bb.9
	discovered a new reachable node %bb.8
	discovered a new reachable node %bb.6
	discovered a new reachable node %bb.5
	discovered a new reachable node %bb.4
	discovered a new reachable node %bb.7
	discovered a new reachable node %bb.3
	discovered a new reachable node %bb.1
	discovered a new reachable node %bb.0
Skipping pass 'Branch Probability Basic Block Placement' on function quick_sort
Skipping pass 'ReachingDefAnalysis' on function quick_sort
Skipping pass 'X86 Execution Dependency Fix' on function quick_sort
Skipping pass 'BreakFalseDeps' on function quick_sort
	discovered a new reachable node %bb.0
	discovered a new reachable node %bb.1
	discovered a new reachable node %bb.2
	discovered a new reachable node %bb.3
	discovered a new reachable node %bb.4
	discovered a new reachable node %bb.5
	discovered a new reachable node %bb.6
	discovered a new reachable node %bb.7
	discovered a new reachable node %bb.8
	discovered a new reachable node %bb.9
	discovered a new reachable node %bb.10
	discovered a new reachable node %bb.11
	discovered a new reachable node %bb.12
	discovered a new reachable node %bb.13
	discovered a new reachable node %bb.14
	discovered a new reachable node %bb.15
	discovered a new reachable node %bb.16
	discovered a new reachable node %bb.17
	discovered a new reachable node %bb.18
	discovered a new reachable node %bb.19
Skipping pass 'X86 Byte/Word Instruction Fixup' on function quick_sort
Skipping pass 'X86 Atom pad short functions' on function quick_sort
Skipping pass 'X86 LEA Fixup' on function quick_sort
********** COMPUTING STACKMAP LIVENESS: quick_sort **********
X86 Retpoline Thunks
	discovered a new reachable node %bb.0
	discovered a new reachable node %bb.1
	discovered a new reachable node %bb.2
	discovered a new reachable node %bb.3
	discovered a new reachable node %bb.4
	discovered a new reachable node %bb.5
	discovered a new reachable node %bb.6
	discovered a new reachable node %bb.7
	discovered a new reachable node %bb.8
	discovered a new reachable node %bb.9
	discovered a new reachable node %bb.10
	discovered a new reachable node %bb.11
	discovered a new reachable node %bb.12
	discovered a new reachable node %bb.13
	discovered a new reachable node %bb.14
	discovered a new reachable node %bb.15
	discovered a new reachable node %bb.16
	discovered a new reachable node %bb.17
	discovered a new reachable node %bb.18
	discovered a new reachable node %bb.19
